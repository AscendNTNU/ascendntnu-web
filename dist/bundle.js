/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(2);


/***/ }),
/* 1 */
/***/ (function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ]
	
	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    }
	
	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    }
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var list = this.map[name]
	    if (!list) {
	      list = []
	      this.map[name] = list
	    }
	    list.push(value)
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    var values = this.map[normalizeName(name)]
	    return values ? values[0] : null
	  }
	
	  Headers.prototype.getAll = function(name) {
	    return this.map[normalizeName(name)] || []
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = [normalizeValue(value)]
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    Object.getOwnPropertyNames(this.map).forEach(function(name) {
	      this.map[name].forEach(function(value) {
	        callback.call(thisArg, value, name, this)
	      }, this)
	    }, this)
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsArrayBuffer(blob)
	    return promise
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsText(blob)
	    return promise
	  }
	
	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf)
	    var chars = new Array(view.length)
	
	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i])
	    }
	    return chars.join('')
	  }
	
	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength)
	      view.set(new Uint8Array(buf))
	      return view.buffer
	    }
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (!body) {
	        this._bodyText = ''
	      } else if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer)
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer])
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body)
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      }
	    }
	
	    this.text = function() {
	      var rejected = consumed(this)
	      if (rejected) {
	        return rejected
	      }
	
	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	
	    if (typeof input === 'string') {
	      this.url = input
	    } else {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function parseHeaders(rawHeaders) {
	    var headers = new Headers()
	    rawHeaders.split('\r\n').forEach(function(line) {
	      var parts = line.split(':')
	      var key = parts.shift().trim()
	      if (key) {
	        var value = parts.join(':').trim()
	        headers.append(key, value)
	      }
	    })
	    return headers
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = 'status' in options ? options.status : 200
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = 'statusText' in options ? options.statusText : 'OK'
	    this.headers = new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init)
	      var xhr = new XMLHttpRequest()
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        }
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var react_dom_1 = __webpack_require__(4);
	var react_router_1 = __webpack_require__(5);
	//import { createHistory } from 'history'
	var App_1 = __webpack_require__(69);
	var FrontPage_1 = __webpack_require__(74);
	var BlogPage_1 = __webpack_require__(82);
	var DronePage_1 = __webpack_require__(131);
	var TeamPage_1 = __webpack_require__(132);
	var JoinPage_1 = __webpack_require__(133);
	var AboutPage_1 = __webpack_require__(134);
	var SponsorPage_1 = __webpack_require__(137);
	var MissionPage_1 = __webpack_require__(138);
	var CVPage_1 = __webpack_require__(139);
	var ContactPage_1 = __webpack_require__(136);
	var gotoTop = function (args) {
	    document.querySelector('body').scrollTop = 0;
	    document.querySelector('#app').scrollTop = 0;
	    var _a = args.location.pathname.slice(1) || 'home', first = _a[0], rest = _a.slice(1);
	    document.title = 'Ascend NTNU - ' + first.toUpperCase() + rest;
	};
	//const browserHistory = useRouterHistory(createHistory)({ basename: '/' })
	react_dom_1.render(React.createElement(react_router_1.Router, { history: react_router_1.browserHistory },
	    React.createElement(react_router_1.Route, { path: "/", component: App_1.default },
	        React.createElement(react_router_1.IndexRoute, { component: FrontPage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/about", component: AboutPage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/blog", component: BlogPage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/blog/tags(/:tags)", component: BlogPage_1.default }),
	        React.createElement(react_router_1.Route, { path: "/blog/:post", component: BlogPage_1.default }),
	        React.createElement(react_router_1.Route, { path: "/contact", component: ContactPage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/cv(/:key)", component: CVPage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/drones", component: DronePage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/join(/:language)", component: JoinPage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/missions", component: MissionPage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/sponsors", component: SponsorPage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/sponsors/:year", component: SponsorPage_1.default }),
	        React.createElement(react_router_1.Route, { path: "/team", component: TeamPage_1.default, onEnter: gotoTop }),
	        React.createElement(react_router_1.Route, { path: "/team/:year", component: TeamPage_1.default }))), document.querySelector('#app'));


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = React;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = ReactDOM;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.PropTypes = exports.RoutingContext = exports.RouterContext = exports.createRoutes = exports.useRoutes = exports.RouteContext = exports.Lifecycle = exports.History = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(6);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes2 = __webpack_require__(7);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(13);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(15);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(46);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(47);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(48);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(50);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(52);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(51);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(53);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _History2 = __webpack_require__(54);
	
	var _History3 = _interopRequireDefault(_History2);
	
	var _Lifecycle2 = __webpack_require__(55);
	
	var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);
	
	var _RouteContext2 = __webpack_require__(56);
	
	var _RouteContext3 = _interopRequireDefault(_RouteContext2);
	
	var _useRoutes2 = __webpack_require__(57);
	
	var _useRoutes3 = _interopRequireDefault(_useRoutes2);
	
	var _RouterContext2 = __webpack_require__(43);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _RoutingContext2 = __webpack_require__(58);
	
	var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);
	
	var _PropTypes3 = _interopRequireDefault(_PropTypes2);
	
	var _match2 = __webpack_require__(59);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(63);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(64);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(65);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(68);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(60);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* mixins */
	
	exports.History = _History3.default;
	exports.Lifecycle = _Lifecycle3.default;
	exports.RouteContext = _RouteContext3.default;
	
	/* utils */
	
	exports.useRoutes = _useRoutes3.default;
	exports.RouterContext = _RouterContext3.default;
	exports.RoutingContext = _RoutingContext3.default;
	exports.PropTypes = _PropTypes3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.router = exports.routes = exports.route = exports.components = exports.component = exports.location = exports.history = exports.falsy = exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(3);
	
	var _deprecateObjectProperties = __webpack_require__(9);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _InternalPropTypes = __webpack_require__(12);
	
	var InternalPropTypes = _interopRequireWildcard(_InternalPropTypes);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});
	
	// Deprecated stuff below:
	
	var falsy = exports.falsy = InternalPropTypes.falsy;
	var history = exports.history = InternalPropTypes.history;
	var location = exports.location = locationShape;
	var component = exports.component = InternalPropTypes.component;
	var components = exports.components = InternalPropTypes.components;
	var route = exports.route = InternalPropTypes.route;
	var routes = exports.routes = InternalPropTypes.routes;
	var router = exports.router = routerShape;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var deprecatePropType = function deprecatePropType(propType, message) {
	      return function () {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	        return propType.apply(undefined, arguments);
	      };
	    };
	
	    var deprecateInternalPropType = function deprecateInternalPropType(propType) {
	      return deprecatePropType(propType, 'This prop type is not intended for external use, and was previously exported by mistake. These internal prop types are deprecated for external use, and will be removed in a later version.');
	    };
	
	    var deprecateRenamedPropType = function deprecateRenamedPropType(propType, name) {
	      return deprecatePropType(propType, 'The `' + name + '` prop type is now exported as `' + name + 'Shape` to avoid name conflicts. This export is deprecated and will be removed in a later version.');
	    };
	
	    exports.falsy = falsy = deprecateInternalPropType(falsy);
	    exports.history = history = deprecateInternalPropType(history);
	    exports.component = component = deprecateInternalPropType(component);
	    exports.components = components = deprecateInternalPropType(components);
	    exports.route = route = deprecateInternalPropType(route);
	    exports.routes = routes = deprecateInternalPropType(routes);
	
	    exports.location = location = deprecateRenamedPropType(location, 'location');
	    exports.router = router = deprecateRenamedPropType(router, 'router');
	  })();
	}
	
	var defaultExport = {
	  falsy: falsy,
	  history: history,
	  location: location,
	  component: component,
	  components: components,
	  route: route,
	  // For some reason, routes was never here.
	  router: router
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  defaultExport = (0, _deprecateObjectProperties2.default)(defaultExport, 'The default export from `react-router/lib/PropTypes` is deprecated. Please use the named exports instead.');
	}
	
	exports.default = defaultExport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.canUseMembrane = undefined;
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseMembrane = exports.canUseMembrane = false;
	
	// No-op by default.
	var deprecateObjectProperties = function deprecateObjectProperties(object) {
	  return object;
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    if (Object.defineProperty({}, 'x', {
	      get: function get() {
	        return true;
	      }
	    }).x) {
	      exports.canUseMembrane = canUseMembrane = true;
	    }
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	
	  if (canUseMembrane) {
	    deprecateObjectProperties = function deprecateObjectProperties(object, message) {
	      // Wrap the deprecated object in a membrane to warn on property access.
	      var membrane = {};
	
	      var _loop = function _loop(prop) {
	        if (!Object.prototype.hasOwnProperty.call(object, prop)) {
	          return 'continue';
	        }
	
	        if (typeof object[prop] === 'function') {
	          // Can't use fat arrow here because of use of arguments below.
	          membrane[prop] = function () {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop].apply(object, arguments);
	          };
	          return 'continue';
	        }
	
	        // These properties are non-enumerable to prevent React dev tools from
	        // seeing them and causing spurious warnings when accessing them. In
	        // principle this could be done with a proxy, but support for the
	        // ownKeys trap on proxies is not universal, even among browsers that
	        // otherwise support proxies.
	        Object.defineProperty(membrane, prop, {
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop];
	          }
	        });
	      };
	
	      for (var prop in object) {
	        var _ret = _loop(prop);
	
	        if (_ret === 'continue') continue;
	      }
	
	      return membrane;
	    };
	  }
	}
	
	exports.default = deprecateObjectProperties;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(11);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }
	
	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}
	
	module.exports = warning;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(3);
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var arrayOf = _react.PropTypes.arrayOf;
	var oneOfType = _react.PropTypes.oneOfType;
	var element = _react.PropTypes.element;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern);
	
	  var regexpSource = _compilePattern2.regexpSource;
	  var paramNames = _compilePattern2.paramNames;
	  var tokens = _compilePattern2.tokens;
	
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames;
	  var paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern);
	
	  var tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0;
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenCount += 1;
	    } else if (token === ')') {
	      parenCount -= 1;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURIComponent(paramValue);
	    } else {
	      pathname += token;
	    }
	  }
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createHashHistory = __webpack_require__(16);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _useQueries = __webpack_require__(32);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager = __webpack_require__(35);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _InternalPropTypes = __webpack_require__(12);
	
	var _RouterContext = __webpack_require__(43);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(6);
	
	var _RouterUtils = __webpack_require__(45);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function isDeprecatedHistory(history) {
	  return !history || !history.__v2_compatible__;
	}
	
	/* istanbul ignore next: sanity check */
	function isUnsupportedHistory(history) {
	  // v3 histories expose getCurrentLocation, but aren't currently supported.
	  return history && history.getCurrentLocation;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // Deprecated:
	    parseQueryString: func,
	    stringifyQuery: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : void 0;
	
	    var _createRouterObjects = this.createRouterObjects();
	
	    var history = _createRouterObjects.history;
	    var transitionManager = _createRouterObjects.transitionManager;
	    var router = _createRouterObjects.router;
	
	
	    this._unlisten = transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	
	    this.history = history;
	    this.router = router;
	  },
	  createRouterObjects: function createRouterObjects() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext;
	    }
	
	    var history = this.props.history;
	    var _props2 = this.props;
	    var routes = _props2.routes;
	    var children = _props2.children;
	
	
	    !!isUnsupportedHistory(history) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v3.x. ' + 'This version of React Router is not compatible with v3 history ' + 'objects. Please use history v2.x instead.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isDeprecatedHistory(history)) {
	      history = this.wrapDeprecatedHistory(history);
	    }
	
	    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	    var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	    var routingHistory = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	    return { history: routingHistory, transitionManager: transitionManager, router: router };
	  },
	  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
	    var _props3 = this.props;
	    var parseQueryString = _props3.parseQueryString;
	    var stringifyQuery = _props3.stringifyQuery;
	
	
	    var createHistory = void 0;
	    if (history) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : void 0;
	      createHistory = function createHistory() {
	        return history;
	      };
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : void 0;
	      createHistory = _createHashHistory2.default;
	    }
	
	    return (0, _useQueries2.default)(createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
	  },
	
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state;
	    var location = _state.location;
	    var routes = _state.routes;
	    var params = _state.params;
	    var components = _state.components;
	    var _props4 = this.props;
	    var createElement = _props4.createElement;
	    var render = _props4.render;
	
	    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      history: this.history,
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(18);
	
	var _PathUtils = __webpack_require__(19);
	
	var _ExecutionEnvironment = __webpack_require__(20);
	
	var _DOMUtils = __webpack_require__(21);
	
	var _DOMStateStorage = __webpack_require__(22);
	
	var _createDOMHistory = __webpack_require__(23);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) {
	      path = addQueryStringValueToPath(path, queryKey, key);
	      _DOMStateStorage.saveState(key, state);
	    } else {
	      // Drop key and state.
	      location.key = location.state = null;
	    }
	
	    var currentHash = _DOMUtils.getHashPath();
	
	    if (action === _Actions.PUSH) {
	      if (currentHash !== path) {
	        window.location.hash = path;
	      } else {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
	      }
	    } else if (currentHash !== path) {
	      // REPLACE
	      _DOMUtils.replaceHashPath(path);
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function push(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.push(location);
	  }
	
	  function replace(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replace(location);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.pushState(state, path);
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replaceState(state, path);
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    push: push,
	    replace: replace,
	    go: go,
	    createHref: createHref,
	
	    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
	    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
	    pushState: pushState, // deprecated - warning is in createHistory
	    replaceState: replaceState // deprecated - warning is in createHistory
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error(
	        '`warning(condition, format, ...args)` requires a warning ' +
	        'message argument'
	      );
	    }
	
	    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
	      throw new Error(
	        'The warning format should be able to uniquely identify this ' +
	        'warning. Please, use a more descriptive format than: ' + format
	      );
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' +
	        format.replace(/%s/g, function() {
	          return args[argIndex++];
	        });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch(x) {}
	    }
	  };
	}
	
	module.exports = warning;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 18 */
/***/ (function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.extractPath = extractPath;
	exports.parsePath = parsePath;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 20 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];
	
	var SecurityError = 'SecurityError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;
	
	      return;
	    }
	
	    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = undefined;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;
	
	      return null;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(20);
	
	var _DOMUtils = __webpack_require__(21);
	
	var _createHistory = __webpack_require__(24);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _deepEqual = __webpack_require__(25);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _PathUtils = __webpack_require__(19);
	
	var _AsyncUtils = __webpack_require__(28);
	
	var _Actions = __webpack_require__(18);
	
	var _createLocation2 = __webpack_require__(29);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(30);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(31);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var getUserConfirmation = options.getUserConfirmation;
	  var keyLength = options.keyLength;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        // treat PUSH to current path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = createPath(location);
	          var nextPath = createPath(nextLocation);
	
	          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function push(location) {
	    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
	  }
	
	  function replace(location) {
	    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(location) {
	    if (location == null || typeof location === 'string') return location;
	
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(location) {
	    return createPath(location);
	  }
	
	  function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	
	    if (typeof action === 'object') {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      location = _extends({}, location, { state: action });
	
	      action = key;
	      key = arguments[3] || createKey();
	    }
	
	    return _createLocation3['default'](location, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    push(_extends({ state: state }, path));
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    replace(_extends({ state: state }, path));
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
	    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(26);
	var isArguments = __webpack_require__(27);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	}
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}


/***/ }),
/* 26 */
/***/ (function(module, exports) {

	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;
	
	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}


/***/ }),
/* 27 */
/***/ (function(module, exports) {

	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	};


/***/ }),
/* 28 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Actions = __webpack_require__(18);
	
	var _PathUtils = __webpack_require__(19);
	
	function createLocation() {
	  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	  if (typeof action === 'object') {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	    location = _extends({}, location, { state: action });
	
	    action = key || _Actions.POP;
	    key = _fourthArg;
	  }
	
	  var pathname = location.pathname || '/';
	  var search = location.search || '';
	  var hash = location.hash || '';
	  var state = location.state || null;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _queryString = __webpack_require__(33);
	
	var _runTransitionHook = __webpack_require__(30);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(19);
	
	var _deprecate = __webpack_require__(31);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	var SEARCH_BASE_KEY = '$searchBase';
	
	function defaultStringifyQuery(query) {
	  return _queryString.stringify(query).replace(/%20/g, '+');
	}
	
	var defaultParseQueryString = _queryString.parse;
	
	function isNestedObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p) && typeof object[p] === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
	  }return false;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    function addQuery(location) {
	      if (location.query == null) {
	        var search = location.search;
	
	        location.query = parseQueryString(search.substring(1));
	        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
	      }
	
	      // TODO: Instead of all the book-keeping here, this should just strip the
	      // stringified query from the search.
	
	      return location;
	    }
	
	    function appendQuery(location, query) {
	      var _extends2;
	
	      var searchBaseSpec = location[SEARCH_BASE_KEY];
	      var queryString = query ? stringifyQuery(query) : '';
	      if (!searchBaseSpec && !queryString) {
	        return location;
	      }
	
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var searchBase = undefined;
	      if (searchBaseSpec && location.search === searchBaseSpec.search) {
	        searchBase = searchBaseSpec.searchBase;
	      } else {
	        searchBase = location.search || '';
	      }
	
	      var search = searchBase;
	      if (queryString) {
	        search += (search ? '&' : '?') + queryString;
	      }
	
	      return _extends({}, location, (_extends2 = {
	        search: search
	      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
	    }
	
	    // Override all read methods with query-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addQuery(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addQuery(location));
	      });
	    }
	
	    // Override all write methods with query-aware versions.
	    function push(location) {
	      history.push(appendQuery(location, location.query));
	    }
	
	    function replace(location) {
	      history.replace(appendQuery(location, location.query));
	    }
	
	    function createPath(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createPath(appendQuery(location, query || location.query));
	    }
	
	    function createHref(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createHref(appendQuery(location, query || location.query));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
	      if (location.query) {
	        fullLocation.query = location.query;
	      }
	      return addQuery(fullLocation);
	    }
	
	    // deprecated
	    function pushState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path, { query: query }));
	    }
	
	    // deprecated
	    function replaceState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path, { query: query }));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useQueries;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var strictUriEncode = __webpack_require__(34);
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return {};
		}
	
		return str.split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
	
			return ret;
		}, {});
	};
	
	exports.stringify = function (obj) {
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return key;
			}
	
			if (Array.isArray(val)) {
				return val.slice().sort().map(function (val2) {
					return strictUriEncode(key) + '=' + strictUriEncode(val2);
				}).join('&');
			}
	
			return strictUriEncode(key) + '=' + strictUriEncode(val);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};


/***/ }),
/* 34 */
/***/ (function(module, exports) {

	'use strict';
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _computeChangedRoutes2 = __webpack_require__(36);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(37);
	
	var _isActive2 = __webpack_require__(39);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(40);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(42);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location) {
	    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var indexOnly = void 0;
	    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
	      indexOnly = deprecatedIndexOnly || false;
	    } else {
	      location = history.createLocation(location);
	      indexOnly = indexOnlyOrDeprecatedQuery;
	    }
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState);
	
	    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
	    var changeRoutes = _computeChangedRoutes.changeRoutes;
	    var enterRoutes = _computeChangedRoutes.enterRoutes;
	
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, redirectInfo);
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.reduce(function (hooks, route) {
	      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
	      return hooks;
	    }, []);
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route, false);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    // TODO: Warn if they register for a route that isn't currently
	    // active. They're probably doing something wrong, like re-creating
	    // route objects on every location change.
	    var routeID = getRouteID(route);
	    var hooks = RouteHooks[routeID];
	
	    if (!hooks) {
	      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	
	      RouteHooks[routeID] = [hook];
	
	      if (thereWereNoRouteHooks) {
	        // setup transition & beforeunload hooks
	        unlistenBefore = history.listenBefore(transitionHook);
	
	        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	      }
	    } else {
	      if (hooks.indexOf(hook) === -1) {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : void 0;
	
	        hooks.push(hook);
	      }
	    }
	
	    return function () {
	      var hooks = RouteHooks[routeID];
	
	      if (hooks) {
	        var newHooks = hooks.filter(function (item) {
	          return item !== hook;
	        });
	
	        if (newHooks.length === 0) {
	          removeListenBeforeHooksForRoute(route);
	        } else {
	          RouteHooks[routeID] = newHooks;
	        }
	      }
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    // TODO: Only use a single history listener. Otherwise we'll
	    // end up with multiple concurrent calls to match.
	    return history.listen(function (location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.replace(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    });
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	
	//export default useRoutes
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(13);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(38);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createTransitionHook(hook, route, asyncArity) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (hook.length < asyncArity) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3));
	
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location, deprecatedPathname, deprecatedQuery) {
	    if (deprecatedPathname) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      redirectInfo = {
	        pathname: deprecatedPathname,
	        query: deprecatedQuery,
	        state: location
	      };
	
	      return;
	    }
	
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](state, nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(13);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname;
	  var query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(38);
	
	var _makeStateWithLocation = __webpack_require__(41);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (!getComponent) {
	    callback();
	    return;
	  }
	
	  var location = nextState.location;
	
	  var nextStateWithLocation = (0, _makeStateWithLocation2.default)(nextState, location);
	
	  getComponent.call(route, nextStateWithLocation, callback);
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = makeStateWithLocation;
	
	var _deprecateObjectProperties = __webpack_require__(9);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function makeStateWithLocation(state, location) {
	  if (process.env.NODE_ENV !== 'production' && _deprecateObjectProperties.canUseMembrane) {
	    var stateWithLocation = _extends({}, state);
	
	    // I don't use deprecateObjectProperties here because I want to keep the
	    // same code path between development and production, in that we just
	    // assign extra properties to the copy of the state object in both cases.
	
	    var _loop = function _loop(prop) {
	      if (!Object.prototype.hasOwnProperty.call(location, prop)) {
	        return 'continue';
	      }
	
	      Object.defineProperty(stateWithLocation, prop, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Accessing location properties directly from the first argument to `getComponent`, `getComponents`, `getChildRoutes`, and `getIndexRoute` is deprecated. That argument is now the router state (`nextState` or `partialNextState`) rather than the location. To access the location, use `nextState.location` or `partialNextState.location`.') : void 0;
	          return location[prop];
	        }
	      });
	    };
	
	    for (var prop in location) {
	      var _ret = _loop(prop);
	
	      if (_ret === 'continue') continue;
	    }
	
	    return stateWithLocation;
	  }
	
	  return _extends({}, state, location);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(38);
	
	var _makeStateWithLocation = __webpack_require__(41);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	var _PatternUtils = __webpack_require__(13);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	  route.getChildRoutes(partialNextStateWithLocation, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	    route.getIndexRoute(partialNextStateWithLocation, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
	  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _deprecateObjectProperties = __webpack_require__(9);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _getRouteParams = __webpack_require__(44);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _RouteUtils = __webpack_require__(6);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var array = _React$PropTypes.array;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	
	  propTypes: {
	    history: object,
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	
	  childContextTypes: {
	    history: object,
	    location: object.isRequired,
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    var _props = this.props;
	    var router = _props.router;
	    var history = _props.history;
	    var location = _props.location;
	
	    if (!router) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`<RouterContext>` expects a `router` rather than a `history`') : void 0;
	
	      router = _extends({}, history, {
	        setRouteLeaveHook: history.listenBeforeLeavingRoute
	      });
	      delete router.listenBeforeLeavingRoute;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      location = (0, _deprecateObjectProperties2.default)(location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
	    }
	
	    return { history: history, location: location, router: router };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props2 = this.props;
	    var history = _props2.history;
	    var location = _props2.location;
	    var routes = _props2.routes;
	    var params = _props2.params;
	    var components = _props2.components;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          history: history,
	          location: location,
	          params: params,
	          route: route,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(13);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.createRouterObject = createRouterObject;
	exports.createRoutingHistory = createRoutingHistory;
	
	var _deprecateObjectProperties = __webpack_require__(9);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createRouterObject(history, transitionManager) {
	  return _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	}
	
	// deprecated
	function createRoutingHistory(history, transitionManager) {
	  history = _extends({}, history, transitionManager);
	
	  if (process.env.NODE_ENV !== 'production') {
	    history = (0, _deprecateObjectProperties2.default)(history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
	  }
	
	  return history;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(7);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var bool = _React$PropTypes.bool;
	var object = _React$PropTypes.object;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	var oneOfType = _React$PropTypes.oneOfType;
	
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function createLocationDescriptor(to, _ref) {
	  var query = _ref.query;
	  var hash = _ref.hash;
	  var state = _ref.state;
	
	  if (query || hash || state) {
	    return { pathname: to, query: query, hash: hash, state: state };
	  }
	
	  return to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object]),
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    !this.context.router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    var _props = this.props;
	    var to = _props.to;
	    var query = _props.query;
	    var hash = _props.hash;
	    var state = _props.state;
	
	    var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	
	    this.context.router.push(location);
	  },
	  render: function render() {
	    var _props2 = this.props;
	    var to = _props2.to;
	    var query = _props2.query;
	    var hash = _props2.hash;
	    var state = _props2.state;
	    var activeClassName = _props2.activeClassName;
	    var activeStyle = _props2.activeStyle;
	    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;
	
	    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : void 0;
	
	    // Ignore if rendered outside the context of router, simplifies unit testing.
	    var router = this.context.router;
	
	
	    if (router) {
	      // If user does not specify a `to` prop, return an empty anchor tag.
	      if (to == null) {
	        return _react2.default.createElement('a', props);
	      }
	
	      var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	      props.href = router.createHref(location);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(location, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(46);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(49);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _PropTypes = __webpack_require__(7);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var props = _extends({}, this.props, { router: router });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 49 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {
	
	                }
	            }
	        }
	    }
	
	    return targetComponent;
	};


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(51);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(12);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(6);
	
	var _PatternUtils = __webpack_require__(13);
	
	var _InternalPropTypes = __webpack_require__(12);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location;
	        var params = nextState.params;
	
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(6);
	
	var _InternalPropTypes = __webpack_require__(12);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(6);
	
	var _InternalPropTypes = __webpack_require__(12);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _InternalPropTypes = __webpack_require__(12);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A mixin that adds the "history" instance variable to components.
	 */
	var History = {
	
	  contextTypes: {
	    history: _InternalPropTypes.history
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : void 0;
	    this.history = this.context.history;
	  }
	};
	
	exports.default = History;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
	 * component that may be used to cancel a transition or prompt the user
	 * for confirmation.
	 *
	 * On standard transitions, routerWillLeave receives a single argument: the
	 * location we're transitioning to. To cancel the transition, return false.
	 * To prompt the user for confirmation, return a prompt message (string).
	 *
	 * During the beforeunload event (assuming you're using the useBeforeUnload
	 * history enhancer), routerWillLeave does not receive a location object
	 * because it isn't possible for us to know the location we're transitioning
	 * to. In this case routerWillLeave must return a prompt message to prevent
	 * the user from closing the window/tab.
	 */
	
	var Lifecycle = {
	
	  contextTypes: {
	    history: object.isRequired,
	    // Nested children receive the route as context, either
	    // set by the route component using the RouteContext mixin
	    // or by some other ancestor.
	    route: object
	  },
	
	  propTypes: {
	    // Route components receive the route object as a prop.
	    route: object
	  },
	
	  componentDidMount: function componentDidMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : void 0;
	    !this.routerWillLeave ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : (0, _invariant2.default)(false) : void 0;
	
	    var route = this.props.route || this.context.route;
	
	    !route ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : (0, _invariant2.default)(false) : void 0;
	
	    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
	  }
	};
	
	exports.default = Lifecycle;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The RouteContext mixin provides a convenient way for route
	 * components to set the route in context. This is needed for
	 * routes that render elements that want to use the Lifecycle
	 * mixin to prevent transitions.
	 */
	
	var RouteContext = {
	
	  propTypes: {
	    route: object.isRequired
	  },
	
	  childContextTypes: {
	    route: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      route: this.props.route
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : void 0;
	  }
	};
	
	exports.default = RouteContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _useQueries = __webpack_require__(32);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _createTransitionManager = __webpack_require__(35);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know about routing.
	 *
	 * Enhances history objects with the following methods:
	 *
	 * - listen((error, nextState) => {})
	 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
	 * - match(location, (error, redirectLocation, nextState) => {})
	 * - isActive(pathname, query, indexOnly=false)
	 */
	function useRoutes(createHistory) {
	  process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : void 0;
	
	  return function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var routes = _ref.routes;
	
	    var options = _objectWithoutProperties(_ref, ['routes']);
	
	    var history = (0, _useQueries2.default)(createHistory)(options);
	    var transitionManager = (0, _createTransitionManager2.default)(history, routes);
	    return _extends({}, history, transitionManager);
	  };
	}
	
	exports.default = useRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(43);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RoutingContext = _react2.default.createClass({
	  displayName: 'RoutingContext',
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : void 0;
	  },
	  render: function render() {
	    return _react2.default.createElement(_RouterContext2.default, this.props);
	  }
	});
	
	exports.default = RoutingContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _Actions = __webpack_require__(18);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(60);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(35);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(6);
	
	var _RouterUtils = __webpack_require__(45);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history;
	  var routes = _ref.routes;
	  var location = _ref.location;
	
	  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  var unlisten = void 0;
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    // Pick up the location from the history via synchronous history.listen
	    // call if needed.
	    unlisten = history.listen(function (historyLocation) {
	      location = historyLocation;
	    });
	  }
	
	  var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	  history = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    callback(error, redirectLocation && router.createLocation(redirectLocation, _Actions.REPLACE), nextState && _extends({}, nextState, {
	      history: history,
	      router: router,
	      matchContext: { history: history, transitionManager: transitionManager, router: router }
	    }));
	
	    // Defer removing the listener to here to prevent DOM histories from having
	    // to unwind DOM event listeners unnecessarily, in case callback renders a
	    // <Router> and attaches another history listener.
	    if (unlisten) {
	      unlisten();
	    }
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(32);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(61);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(62);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useRoutes` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  history.__v2_compatible__ = true;
	  return history;
	}
	module.exports = exports['default'];

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ExecutionEnvironment = __webpack_require__(20);
	
	var _PathUtils = __webpack_require__(19);
	
	var _runTransitionHook = __webpack_require__(30);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(31);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var basename = options.basename;
	
	    var checkedBaseHref = false;
	
	    function checkBaseHref() {
	      if (checkedBaseHref) {
	        return;
	      }
	
	      // Automatically use the value of <base href> in HTML
	      // documents as basename if it's not explicitly given.
	      if (basename == null && _ExecutionEnvironment.canUseDOM) {
	        var base = document.getElementsByTagName('base')[0];
	        var baseHref = base && base.getAttribute('href');
	
	        if (baseHref != null) {
	          basename = baseHref;
	
	          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
	        }
	      }
	
	      checkedBaseHref = true;
	    }
	
	    function addBasename(location) {
	      checkBaseHref();
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    }
	
	    function prependBasename(location) {
	      checkBaseHref();
	
	      if (!basename) return location;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var pname = location.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, location, {
	        pathname: pathname
	      });
	    }
	
	    // Override all read methods with basename-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addBasename(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addBasename(location));
	      });
	    }
	
	    // Override all write methods with basename-aware versions.
	    function push(location) {
	      history.push(prependBasename(location));
	    }
	
	    function replace(location) {
	      history.replace(prependBasename(location));
	    }
	
	    function createPath(location) {
	      return history.createPath(prependBasename(location));
	    }
	
	    function createHref(location) {
	      return history.createHref(prependBasename(location));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    }
	
	    // deprecated
	    function pushState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path));
	    }
	
	    // deprecated
	    function replaceState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useBasename;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _warning = __webpack_require__(17);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PathUtils = __webpack_require__(19);
	
	var _Actions = __webpack_require__(18);
	
	var _createHistory = __webpack_require__(24);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	}
	
	function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var history = _createHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: saveState,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    var key = history.createKey();
	
	    if (typeof entry === 'string') return { pathname: entry, key: key };
	
	    if (typeof entry === 'object' && entry) return _extends({}, entry, { key: key });
	
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
	  }
	
	  var storage = createStateStorage(entries);
	
	  function saveState(key, state) {
	    storage[key] = state;
	  }
	
	  function readState(key) {
	    return storage[key];
	  }
	
	  function getCurrentLocation() {
	    var entry = entries[current];
	    var basename = entry.basename;
	    var pathname = entry.pathname;
	    var search = entry.search;
	
	    var path = (basename || '') + pathname + (search || '');
	
	    var key = undefined,
	        state = undefined;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    } else {
	      key = history.createKey();
	      state = null;
	      entry.key = key;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  }
	
	  function go(n) {
	    if (n) {
	      if (!canGo(n)) {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
	        return;
	      }
	
	      current += n;
	
	      var currentLocation = getCurrentLocation();
	
	      // change action to POP
	      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	    }
	  }
	
	  function finishTransition(location) {
	    switch (location.action) {
	      case _Actions.PUSH:
	        current += 1;
	
	        // if we are not on the top of stack
	        // remove rest and push new
	        if (current < entries.length) entries.splice(current);
	
	        entries.push(location);
	        saveState(location.key, location.state);
	        break;
	      case _Actions.REPLACE:
	        entries[current] = location;
	        saveState(location.key, location.state);
	        break;
	    }
	  }
	
	  return history;
	}
	
	exports['default'] = createMemoryHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(32);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(61);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    history.__v2_compatible__ = true;
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _react = __webpack_require__(3);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(43);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(10);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length <= 0 || arguments[0] === undefined ? _react.createElement : arguments[0];
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(66);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(67);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	var _invariant = __webpack_require__(14);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(18);
	
	var _PathUtils = __webpack_require__(19);
	
	var _ExecutionEnvironment = __webpack_require__(20);
	
	var _DOMUtils = __webpack_require__(21);
	
	var _DOMStateStorage = __webpack_require__(22);
	
	var _createDOMHistory = __webpack_require__(23);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve URLs.
	 */
	function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var forceRefresh = options.forceRefresh;
	
	  var isSupported = _DOMUtils.supportsHistory();
	  var useRefresh = !isSupported || forceRefresh;
	
	  function getCurrentLocation(historyState) {
	    try {
	      historyState = historyState || window.history.state || {};
	    } catch (e) {
	      historyState = {};
	    }
	
	    var path = _DOMUtils.getWindowPath();
	    var _historyState = historyState;
	    var key = _historyState.key;
	
	    var state = undefined;
	    if (key) {
	      state = _DOMStateStorage.readState(key);
	    } else {
	      state = null;
	      key = history.createKey();
	
	      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startPopStateListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function popStateListener(event) {
	      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.
	
	      transitionTo(getCurrentLocation(event.state));
	    }
	
	    _DOMUtils.addEventListener(window, 'popstate', popStateListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    _DOMStateStorage.saveState(key, state);
	
	    var path = (basename || '') + pathname + search + hash;
	    var historyState = {
	      key: key
	    };
	
	    if (action === _Actions.PUSH) {
	      if (useRefresh) {
	        window.location.href = path;
	        return false; // Prevent location update.
	      } else {
	          window.history.pushState(historyState, null, path);
	        }
	    } else {
	      // REPLACE
	      if (useRefresh) {
	        window.location.replace(path);
	        return false; // Prevent location update.
	      } else {
	          window.history.replaceState(historyState, null, path);
	        }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopPopStateListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopPopStateListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createBrowserHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(63);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(16);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(67);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var Header_1 = __webpack_require__(70);
	var Footer_1 = __webpack_require__(71);
	var PageLayout_1 = __webpack_require__(72);
	var App = (function (_super) {
	    __extends(App, _super);
	    function App(props) {
	        var _this = _super.call(this, props) || this;
	        try {
	            if (!localStorage['theme'] || !localStorage['theme'].length)
	                localStorage['theme'] = 'dark';
	            _this.state = {
	                showMenu: false,
	                theme: localStorage['theme'],
	            };
	        }
	        catch (ex) {
	            _this.state = {
	                showMenu: false,
	                theme: 'dark',
	            };
	        }
	        return _this;
	    }
	    App.prototype.toggleMenu = function () {
	        this.setState({
	            showMenu: !this.state.showMenu,
	            theme: this.state.theme
	        });
	        if (this.state.showMenu)
	            document.body.classList.remove('no-scroll');
	        else
	            document.body.classList.add('no-scroll');
	    };
	    App.prototype.changeTheme = function (evt) {
	        try {
	            localStorage['theme'] = localStorage['theme'] == 'dark' ? 'light' : 'dark';
	            this.setState({
	                showMenu: this.state.showMenu,
	                theme: localStorage['theme']
	            });
	        }
	        catch (ex) {
	            this.setState({
	                showMenu: this.state.showMenu,
	                theme: this.state.theme == 'dark' ? 'light' : 'dark'
	            });
	        }
	    };
	    App.prototype.render = function () {
	        return (React.createElement("div", { className: 'app' + (this.state.showMenu ? ' menu-visible' : '') + (this.state.theme === 'dark' ? ' dark-theme' : '') },
	            React.createElement(Header_1.default, { toggleMenuHandler: this.toggleMenu.bind(this), toggle: this.state.showMenu }),
	            this.props.children,
	            React.createElement(PageLayout_1.ToTopButton, null),
	            React.createElement(Footer_1.default, { changeTheme: this.changeTheme.bind(this), theme: this.state.theme })));
	    };
	    return App;
	}(React.Component));
	exports.App = App;
	exports.default = App;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var react_router_1 = __webpack_require__(5);
	var Header = (function (_super) {
	    __extends(Header, _super);
	    function Header(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            hoverAbout: false
	        };
	        _this.toggleMenuHandler = _this.toggleMenuHandler.bind(_this);
	        return _this;
	    }
	    Header.prototype.hideMenu = function () {
	        if (this.props.toggle)
	            this.props.toggleMenuHandler;
	    };
	    Header.prototype.toggleMenuHandler = function (evt) {
	        this.props.toggleMenuHandler(evt);
	        this.setState(Object.assign({}, this.state, {
	            hoverAbout: false
	        }));
	    };
	    Header.prototype.render = function () {
	        var _this = this;
	        return (React.createElement("div", { className: "head" },
	            React.createElement("div", { className: "head-content page-container" },
	                React.createElement(react_router_1.IndexLink, { onClick: this.hideMenu, to: "/" },
	                    React.createElement("div", { className: "logo-title" },
	                        React.createElement("img", { className: "logo-img", src: "/images/logo/logo.png" }),
	                        React.createElement("div", { className: "logo-title-text" },
	                            "asc",
	                            React.createElement("span", { className: "logo-title-e" }, "e"),
	                            "nd"))),
	                React.createElement("div", { className: "toggle-menu", onClick: this.props.toggleMenuHandler },
	                    React.createElement("i", { className: "fa fa-" + (this.props.toggle ? "times" : "bars") })),
	                React.createElement("nav", { className: "nav-bar" },
	                    React.createElement(react_router_1.IndexLink, { onClick: this.toggleMenuHandler, className: "nav-element", activeClassName: "active", to: "/" }, "Home"),
	                    React.createElement(react_router_1.Link, { onClick: this.toggleMenuHandler, className: "nav-element", activeClassName: "active", to: "/blog" }, "Blog"),
	                    React.createElement(react_router_1.Link, { onClick: this.toggleMenuHandler, className: "nav-element", activeClassName: "active", to: "/drones" }, "Drones"),
	                    React.createElement(react_router_1.Link, { onClick: this.toggleMenuHandler, className: "nav-element", activeClassName: "active", to: "/join" }, "Join Us"),
	                    React.createElement(react_router_1.Link, { onClick: this.toggleMenuHandler, className: "nav-element", activeClassName: "active", to: "/team" }, "Team"),
	                    React.createElement("div", { className: "nav-element dropdown " + (this.state.hoverAbout ? 'show' : ''), onClick: function () { _this.setState({ hoverAbout: !_this.state.hoverAbout }); } },
	                        React.createElement("div", { className: "toggle-menu" },
	                            "More ",
	                            React.createElement("i", { className: "fa fa-" + (this.state.hoverAbout ? 'caret-up' : 'caret-down') })),
	                        React.createElement("div", { className: "toggle-menu-small-screen" },
	                            "More ",
	                            React.createElement("i", { className: "fa fa-caret-" + (this.state.hoverAbout ? 'up' : 'down') })),
	                        React.createElement("div", { className: "links" },
	                            React.createElement(react_router_1.Link, { onClick: this.props.toggleMenuHandler, className: "nav-element", activeClassName: "active", to: "/sponsors" }, "Sponsors"),
	                            React.createElement(react_router_1.Link, { onClick: this.props.toggleMenuHandler, className: "nav-element", activeClassName: "active", to: "/missions" }, "Missions"),
	                            React.createElement(react_router_1.Link, { onClick: this.props.toggleMenuHandler, className: "nav-element", activeClassName: "active", to: "/about" }, "About"),
	                            React.createElement(react_router_1.Link, { onClick: this.props.toggleMenuHandler, className: "nav-element", activeClassName: "active", to: "/contact" }, "Contact")))))));
	    };
	    return Header;
	}(React.Component));
	exports.Header = Header;
	exports.default = Header;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var Footer = (function (_super) {
	    __extends(Footer, _super);
	    function Footer(props) {
	        var _this = _super.call(this, props) || this;
	        _this.links = [
	            { href: "mailto:hi@ascendntnu.no", icon: "envelope-o", content: "hi@ascendntnu.no" },
	            { href: "https://twitter.com/ascendntnu/", icon: "twitter", content: "Twitter/@ascendntnu" },
	            { href: "https://instagram.com/ascendntnu/", icon: "instagram", content: "Instagram/@ascendntnu" },
	            { href: "https://www.facebook.com/ascendntnu", icon: "facebook-official", content: "Facebook" },
	            { href: "https://github.com/ascendntnu", icon: "github", content: "Github" },
	            { href: "https://www.linkedin.com/company/ascend-ntnu", icon: "linkedin", content: "LinkedIn" },
	            { href: "https://ascendntnu.no/blog/rss", icon: "rss", content: "RSS" },
	        ];
	        return _this;
	    }
	    Footer.prototype.render = function () {
	        var links = this.links.map(function (link, i) {
	            return (React.createElement("a", { className: 'link icon icon-' + link.icon, target: "_blank", href: link.href, key: i },
	                React.createElement("i", { className: link.icon ? "fa fa-" + link.icon : "" })));
	        });
	        return (React.createElement("div", { className: "foot" },
	            React.createElement("div", { className: "foot-content page-container" },
	                React.createElement("div", { className: "foot-element" },
	                    React.createElement("a", { className: "link foot-image", href: "http://kongsberg.com", target: "_blank" },
	                        React.createElement("img", { src: "/images/sponsors/kongsberg_dark_bg.svg", alt: "Kongsberg logo" }))),
	                React.createElement("div", { className: "foot-element" },
	                    links,
	                    React.createElement("div", { className: "fb-like", "data-href": "https://www.facebook.com/ascendntnu/?fref=ts", "data-width": "100", "data-layout": "standard", "data-action": "like", "data-size": "small", "data-colorscheme": "dark", "data-show-faces": "false", "data-share": "true" })),
	                React.createElement("div", { className: "foot-element" },
	                    React.createElement("p", null, "Autonomus aerial robotics. Ascend NTNU is The Norwegian University of Science and Technology's team in the International Aerial Robotics Competition (IARC)."),
	                    React.createElement("div", { onClick: this.props.changeTheme.bind(this), className: "styled-link" },
	                        "Change to ",
	                        this.props.theme == 'dark' ? 'light' : 'dark',
	                        " theme")))));
	    };
	    return Footer;
	}(React.Component));
	exports.Footer = Footer;
	exports.default = Footer;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var eventHandler_1 = __webpack_require__(73);
	var Title = (function (_super) {
	    __extends(Title, _super);
	    function Title() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Title.prototype.render = function () {
	        return (React.createElement("h1", { className: "section-title" }, this.props.children));
	    };
	    return Title;
	}(React.Component));
	exports.Title = Title;
	var SubTitle = (function (_super) {
	    __extends(SubTitle, _super);
	    function SubTitle() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    SubTitle.prototype.render = function () {
	        return (React.createElement("h2", { className: "sub-section-title" }, this.props.children));
	    };
	    return SubTitle;
	}(React.Component));
	exports.SubTitle = SubTitle;
	var SubSubTitle = (function (_super) {
	    __extends(SubSubTitle, _super);
	    function SubSubTitle() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    SubSubTitle.prototype.render = function () {
	        return (React.createElement("h3", { className: "sub-sub-section-title" }, this.props.children));
	    };
	    return SubSubTitle;
	}(React.Component));
	exports.SubSubTitle = SubSubTitle;
	var Section = (function (_super) {
	    __extends(Section, _super);
	    function Section(props) {
	        var _this = _super.call(this, props) || this;
	        _this.className = 'section page-container';
	        if (_this.props.className)
	            _this.className += ' ' + _this.props.className;
	        if (_this.props.theme) {
	            var theme = '';
	            switch (_this.props.theme) {
	                case 'dark':
	                    theme = 'dark';
	                    break;
	                default:
	                    theme = 'light';
	                    break;
	            }
	            _this.className += ' ' + theme;
	        }
	        return _this;
	    }
	    Section.prototype.render = function () {
	        if (this.props.titleText) {
	            this.title = (React.createElement(Title, null, this.props.titleText));
	        }
	        var props = Object.assign({}, this.props);
	        delete props.titleText;
	        return (React.createElement("div", __assign({}, props, { className: this.className }),
	            this.title,
	            this.props.children));
	    };
	    return Section;
	}(React.Component));
	exports.Section = Section;
	var SubSection = (function (_super) {
	    __extends(SubSection, _super);
	    function SubSection(props) {
	        var _this = _super.call(this, props) || this;
	        _this.className = 'sub-section page-container';
	        if (_this.props.className)
	            _this.className += ' ' + _this.props.className;
	        if (_this.props.theme) {
	            var theme = '';
	            switch (_this.props.theme) {
	                case 'dark':
	                    theme = 'dark';
	                    break;
	                default:
	                    theme = 'light';
	                    break;
	            }
	        }
	        return _this;
	    }
	    SubSection.prototype.render = function () {
	        if (this.props.titleText) {
	            this.title = (React.createElement(SubTitle, null, this.props.titleText));
	        }
	        var props = Object.assign({}, this.props);
	        delete props.titleText;
	        return (React.createElement("div", __assign({}, props, { className: this.className }),
	            this.title,
	            this.props.children));
	    };
	    return SubSection;
	}(React.Component));
	exports.SubSection = SubSection;
	var SubSubSection = (function (_super) {
	    __extends(SubSubSection, _super);
	    function SubSubSection(props) {
	        var _this = _super.call(this, props) || this;
	        _this.className = 'sub-sub-section page-container';
	        if (_this.props.className)
	            _this.className += ' ' + _this.props.className;
	        if (_this.props.theme) {
	            var theme = '';
	            switch (_this.props.theme) {
	                case 'dark':
	                    theme = 'dark';
	                    break;
	                default:
	                    theme = 'light';
	                    break;
	            }
	        }
	        return _this;
	    }
	    SubSubSection.prototype.render = function () {
	        if (this.props.titleText) {
	            this.title = (React.createElement(SubSubTitle, null, this.props.titleText));
	        }
	        var props = Object.assign({}, this.props);
	        delete props.titleText;
	        return (React.createElement("div", __assign({}, props, { className: this.className }),
	            this.title,
	            this.props.children));
	    };
	    return SubSubSection;
	}(React.Component));
	exports.SubSubSection = SubSubSection;
	var ToTopButton = (function (_super) {
	    __extends(ToTopButton, _super);
	    function ToTopButton(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            onTop: true
	        };
	        document.querySelector('#app').addEventListener('scroll', _this.scrollHandler.bind(_this));
	        document.querySelector('#app').addEventListener('touchmove', _this.scrollHandler.bind(_this));
	        document.querySelector('#app').addEventListener('touchend', _this.scrollHandler.bind(_this));
	        return _this;
	    }
	    ToTopButton.prototype.scrollHandler = function (evt) {
	        var app = document.querySelector('#app');
	        if ((app.scrollTop || document.body.scrollTop) > 100 && this.state.onTop) {
	            this.setState({
	                onTop: false
	            });
	        }
	        else if ((app.scrollTop || document.body.scrollTop) <= 100 && !this.state.onTop) {
	            this.setState({
	                onTop: true
	            });
	        }
	    };
	    ToTopButton.prototype.clickHandler = function (evt) {
	        var _this = this;
	        var app = document.querySelector('#app');
	        var startScroll = (app.scrollTop || document.body.scrollTop);
	        var interval = setInterval(function () {
	            app.scrollTop -= 10 / (.1 + Math.pow(app.scrollTop / startScroll - .5, 2));
	            document.body.scrollTop -= 10 / (.1 + Math.pow(document.body.scrollTop / startScroll - .5, 2));
	            if ((app.scrollTop || document.body.scrollTop) <= 0) {
	                clearInterval(interval);
	                _this.setState({
	                    onTop: true
	                });
	            }
	        }, 10);
	    };
	    ToTopButton.prototype.render = function () {
	        return (React.createElement(eventHandler_1.AddHover, { type: "div", className: 'totop-button' + (this.state.onTop ? ' on-top' : ''), onClick: this.clickHandler.bind(this) },
	            React.createElement("svg", { viewBox: "0 0 64 64" },
	                React.createElement("path", { fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "5", d: "M 16 38 L 32 25 L 48 38" }))));
	    };
	    return ToTopButton;
	}(React.Component));
	exports.ToTopButton = ToTopButton;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (this && this.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var AddHover = (function (_super) {
	    __extends(AddHover, _super);
	    function AddHover(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            hover: false,
	            touch: false,
	        };
	        return _this;
	    }
	    /**
	     * Updating the hover class on the element. Touch is triggered before mouse events,
	     * but as touch triggers by both touch and mouse - we need a way of detecting the
	     * first start/end sequence.
	     *
	     * @param hoverOn {boolean} Telling if event is for turning on/off the hover class.
	     * @param isTouch {boolean} Telling if it is a touchevent.
	     */
	    AddHover.prototype.updateHover = function (hoverOn, isTouch) {
	        var _this = this;
	        if (hoverOn) {
	            this.setState(Object.assign({}, this.state, {
	                hover: true,
	                touch: isTouch,
	            }));
	        }
	        else {
	            if (this.state.touch == isTouch) {
	                this.setState(Object.assign({}, this.state, {
	                    hover: false,
	                    touch: isTouch,
	                }));
	                if (isTouch) {
	                    setTimeout(function () {
	                        _this.setState(Object.assign({}, _this.state, { hover: false }));
	                    }, 100);
	                }
	            }
	        }
	    };
	    AddHover.prototype.render = function () {
	        var _this = this;
	        var className = this.props.className.replace(/(^| )hover( |$)/g, '') + (this.state.hover ? ' hover' : '');
	        var Container = this.props.type || 'div';
	        return (React.createElement(Container, __assign({}, this.props, { className: className, onClick: this.props.onClick, onTouchStart: function () { return _this.updateHover(true, true); }, onTouchEnd: function () { return _this.updateHover(false, true); }, onTouchCancel: function () { return _this.updateHover(false, true); }, onMouseEnter: function () { return _this.updateHover(true, false); }, onMouseMove: function () { return _this.updateHover(true, false); }, onMouseLeave: function () { return _this.updateHover(false, false); } }), this.props.children));
	    };
	    return AddHover;
	}(React.Component));
	exports.AddHover = AddHover;


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var splash_1 = __webpack_require__(75);
	var sponsorlist_1 = __webpack_require__(79);
	var PageLayout_1 = __webpack_require__(72);
	var FrontPage = (function (_super) {
	    __extends(FrontPage, _super);
	    function FrontPage() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    FrontPage.prototype.render = function () {
	        return (React.createElement("div", { className: "page page-front" },
	            React.createElement(splash_1.default, null),
	            React.createElement(PageLayout_1.Section, { titleText: "Our sponsors", className: "centered" },
	                React.createElement(sponsorlist_1.default, null))));
	    };
	    return FrontPage;
	}(React.Component));
	exports.FrontPage = FrontPage;
	exports.default = FrontPage;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var model_1 = __webpack_require__(76);
	var Splash = (function (_super) {
	    __extends(Splash, _super);
	    function Splash(props) {
	        var _this = _super.call(this, props) || this;
	        _this.dirty = false;
	        _this.width = window.innerWidth;
	        _this.height = 640;
	        _this.distance = _this.width < 560 ? _this.height : _this.width;
	        _this.svgAnimate = !navigator.userAgent.match(/Trident|Firefox/);
	        _this.state = {
	            pos: _this.width / 2,
	            down: false,
	            startPos: {
	                x: 0,
	                y: 0
	            },
	            smallScreen: _this.width < 560
	        };
	        _this.fitSplashToContainerHandler = _this.fitSplashToContainerHandler.bind(_this);
	        _this.mouseMoveHandler = _this.mouseMoveHandler.bind(_this);
	        _this.mouseUpHandler = _this.mouseUpHandler.bind(_this);
	        return _this;
	    }
	    Splash.prototype.componentDidMount = function () {
	        window.addEventListener('resize', this.fitSplashToContainerHandler);
	        window.addEventListener('mousemove', this.mouseMoveHandler);
	        window.addEventListener('mouseup', this.mouseUpHandler);
	        var passive = { passive: true };
	        window.addEventListener('touchmove', this.mouseMoveHandler, passive);
	        window.addEventListener('touchend', this.mouseUpHandler, passive);
	        window.addEventListener('touchcancel', this.mouseUpHandler, passive);
	        this.height = document.querySelector('.front-splash').clientHeight;
	        this.distance = this.width < 560 ? this.height : this.width;
	        if (this.width < 560) {
	            this.setState(Object.assign({}, this.state, {
	                pos: document.querySelector('.front-splash p').clientHeight
	            }));
	        }
	    };
	    Splash.prototype.componentWillUnmount = function () {
	        window.removeEventListener('resize', this.fitSplashToContainerHandler);
	        window.removeEventListener('mousemove', this.mouseMoveHandler);
	        window.removeEventListener('mouseup', this.mouseUpHandler);
	        window.removeEventListener('touchmove', this.mouseMoveHandler);
	        window.removeEventListener('touchend', this.mouseUpHandler);
	        window.removeEventListener('touchcancel', this.mouseUpHandler);
	    };
	    Splash.prototype.fitSplashToContainerHandler = function (evt) {
	        var splash = document.querySelector('.front-splash');
	        this.width = window.innerWidth;
	        this.height = splash.clientHeight;
	        this.process = this.state.pos / this.distance;
	        this.distance = this.width < 560 ? this.height : this.width;
	        if (!this.dirty && this.width < 560) {
	            this.setState(Object.assign({}, this.state, {
	                smallScreen: true,
	                pos: splash.querySelector('p').clientHeight
	            }));
	        }
	        else {
	            if (!this.dirty) {
	                this.setState(Object.assign({}, this.state, {
	                    smallScreen: this.width < 560,
	                    pos: this.width / 2
	                }));
	            }
	            else {
	                if (this.state.smallScreen !== this.width < 560) {
	                    this.setState(Object.assign({}, this.state, {
	                        smallScreen: this.width < 560,
	                        pos: Math.max(Math.min(this.process * this.distance, this.distance * (this.state.smallScreen ? .85 : .9)), this.distance * .1)
	                    }));
	                }
	            }
	        }
	    };
	    Splash.prototype.mouseMoveHandler = function (evt) {
	        if (this.state.down) {
	            var pos = {
	                x: 0,
	                y: 0
	            };
	            if (evt.type === 'mousemove') {
	                pos = {
	                    x: evt.clientX,
	                    y: evt.clientY
	                };
	            }
	            else {
	                pos = {
	                    x: evt.touches[0].clientX,
	                    y: evt.touches[0].clientY
	                };
	            }
	            this.setState(Object.assign({}, this.state, {
	                pos: Math.max(Math.min(this.state.smallScreen
	                    ? this.distance - pos.y + this.state.startPos.y
	                    : pos.x - this.state.startPos.x, this.distance * (this.state.smallScreen ? .85 : .9)), this.distance * .1)
	            }));
	        }
	    };
	    Splash.prototype.mouseDownHandler = function (evt) {
	        var pos = {
	            x: 0,
	            y: 0
	        };
	        if (evt.type === 'mousedown') {
	            pos = {
	                x: evt.clientX - this.state.pos,
	                y: evt.clientY - (this.height - this.state.pos)
	            };
	        }
	        else {
	            evt.preventDefault();
	            pos = {
	                x: evt.touches[0].clientX - this.state.pos,
	                y: evt.touches[0].clientY - (this.height - this.state.pos)
	            };
	        }
	        this.dirty = true;
	        this.setState(Object.assign({}, this.state, {
	            down: true,
	            startPos: pos
	        }));
	    };
	    Splash.prototype.mouseUpHandler = function (evt) {
	        if (this.state.down) {
	            this.setState(Object.assign({}, this.state, {
	                down: false
	            }));
	        }
	    };
	    Splash.prototype.render = function () {
	        var centerPos = this.distance / 2;
	        var process = this.state.pos / this.distance;
	        if (this.state.smallScreen)
	            process = 1 - process;
	        var growLeft = centerPos / (1 - process) - centerPos;
	        var growRight = centerPos;
	        if (process > .5) {
	            growLeft = centerPos;
	            growRight = centerPos / process - centerPos;
	        }
	        var styles = {
	            leftStyle: {
	                flexGrow: this.state.smallScreen ? growRight : growLeft
	            },
	            centerStyle: {
	                position: this.state.smallScreen ? 'static' : 'absolute',
	                left: this.state.smallScreen ? '50%' : Math.min(this.width, 100 * this.state.pos / this.width) + '%'
	            },
	            rightStyle: {
	                flexGrow: this.state.smallScreen ? growLeft : growRight
	            }
	        };
	        return (React.createElement("div", { className: "front-splash" },
	            React.createElement(model_1.ModelRenderer, { models: ['/images/drones/drone2.stl'], process: Date.now(), autospin: true, wireframe: true, style: { position: 'absolute' } }),
	            React.createElement("div", { className: "front-splash-left", style: styles.leftStyle },
	                React.createElement("p", null,
	                    "Autonomus aerial robotics for fun and learning. Ascend NTNU is the ",
	                    React.createElement("a", { href: "http://www.ntnu.edu/" }, "Norwegian University Of Science and Technology's"),
	                    " team in the ",
	                    React.createElement("a", { href: "http://www.aerialroboticscompetition.org/" }, "International Aerial Robotics Competition"),
	                    ".")),
	            React.createElement("div", { className: "front-splash-center", style: styles.centerStyle, onMouseDown: this.mouseDownHandler.bind(this), onTouchStart: this.mouseDownHandler.bind(this) },
	                React.createElement("img", { src: "/images/logo/logo-ascend-below-shadow" + (this.svgAnimate ? '-animation' : '') + ".svg", draggable: false })),
	            React.createElement("div", { className: "front-splash-right", style: styles.rightStyle },
	                React.createElement(model_1.ModelRenderer, { models: ['/images/drones/drone2.stl'], process: Date.now(), autospin: true, style: { position: 'absolute' } }))));
	    };
	    return Splash;
	}(React.Component));
	exports.Splash = Splash;
	exports.default = Splash;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var THREE = __webpack_require__(77);
	var THREESTLLoader = __webpack_require__(78);
	var ModelRenderer = (function (_super) {
	    __extends(ModelRenderer, _super);
	    function ModelRenderer(props) {
	        var _this = _super.call(this, props) || this;
	        _this.scene = new THREE.Scene();
	        _this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
	        _this.camera.position.x = 0;
	        _this.camera.position.y = 200;
	        _this.camera.position.z = 0;
	        var geometry = new THREE.BoxGeometry(10, 10, 10);
	        var material = new THREE.MeshNormalMaterial();
	        if (_this.props.wireframe) {
	            material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
	        }
	        else {
	            material = new THREE.MeshStandardMaterial({
	                color: 0xff8800,
	                roughness: 0.95,
	                metalness: 0.0
	            });
	        }
	        var mesh = new THREE.Mesh(geometry, material);
	        mesh.position.x = 0;
	        mesh.position.y = 0;
	        mesh.position.z = 0;
	        //this.scene.add(mesh)
	        var STLLoader = new THREESTLLoader(THREE);
	        _this.loader = new STLLoader();
	        _this.updateModels(props.models || []);
	        var light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
	        _this.scene.add(light);
	        _this.fitToContainerHandler = _this.fitToContainerHandler.bind(_this);
	        return _this;
	    }
	    ModelRenderer.prototype.componentDidMount = function () {
	        this.renderer = new THREE.WebGLRenderer({
	            canvas: this.canvas,
	            alpha: true
	        });
	        this.renderer.setPixelRatio(window.devicePixelRatio);
	        this.fitToContainerHandler();
	        window.addEventListener('resize', this.fitToContainerHandler);
	        if (this.props.autospin) {
	            this.raf = window.requestAnimationFrame(this.animationStep.bind(this));
	        }
	        else {
	            this.updateRendering();
	        }
	    };
	    ModelRenderer.prototype.animationStep = function (timestamp) {
	        this.updateRendering();
	        window.requestAnimationFrame(this.animationStep.bind(this));
	    };
	    ModelRenderer.prototype.componentWillUnmount = function () {
	        if (this.raf)
	            window.cancelAnimationFrame(this.raf);
	        window.removeEventListener('resize', this.fitToContainerHandler);
	    };
	    ModelRenderer.prototype.fitToContainerHandler = function (evt) {
	        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight, false);
	        this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;
	        this.camera.updateProjectionMatrix();
	    };
	    ModelRenderer.prototype.updateModels = function (models) {
	        var _this = this;
	        try {
	            models.forEach(function (model) {
	                _this.loader.load(model, function (geometry) {
	                    var meshMaterial = null;
	                    if (_this.props.wireframe) {
	                        meshMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
	                    }
	                    else {
	                        meshMaterial = new THREE.MeshStandardMaterial({
	                            color: 0xff8800,
	                            roughness: 0.95,
	                            metalness: 0.0,
	                            side: THREE.DoubleSide
	                        });
	                    }
	                    //if (geometry.hasColors) {
	                    //  meshMaterial = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors })
	                    //}
	                    geometry.translate(-360, 0, -300);
	                    var mesh = new THREE.Mesh(geometry, meshMaterial);
	                    mesh.position.set(0, 0, 0);
	                    mesh.rotation.set(0, 0, 0);
	                    var scale = .5;
	                    mesh.scale.set(scale, scale, scale);
	                    mesh.castShadow = true;
	                    mesh.receiveShadow = true;
	                    _this.scene.add(mesh);
	                    _this.updateRendering();
	                });
	            });
	        }
	        catch (ex) {
	            console.error('Mangler modellen(e): ' + models.join(', ') + ', eller s kan THREE.js vre utdatert.');
	        }
	    };
	    ModelRenderer.prototype.updateRendering = function () {
	        if (typeof this.props.process === 'number') {
	            var process = this.props.autospin ? Date.now() : (this.props.process || Date.now());
	            this.camera.position.x = 200 * Math.sin(process / 4000);
	            this.camera.position.z = 200 * Math.cos(process / 4000);
	            this.camera.position.y = 200 * Math.cos(process / 5000);
	        }
	        else {
	            var process = this.props.process;
	            this.camera.position.x = process[0];
	            this.camera.position.z = process[1];
	            this.camera.position.y = process[2];
	        }
	        this.camera.lookAt(this.scene.position);
	        this.renderer.render(this.scene, this.camera);
	        this.renderer.setClearColor(0, 0);
	    };
	    ModelRenderer.prototype.render = function () {
	        var _this = this;
	        return React.createElement("canvas", { className: "model-renderer", ref: function (c) { _this.canvas = c; }, style: this.props.style });
	    };
	    return ModelRenderer;
	}(React.Component));
	exports.ModelRenderer = ModelRenderer;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.THREE = global.THREE || {})));
	}(this, (function (exports) { 'use strict';
	
		// Polyfills
	
		if ( Number.EPSILON === undefined ) {
	
			Number.EPSILON = Math.pow( 2, - 52 );
	
		}
	
		if ( Number.isInteger === undefined ) {
	
			// Missing in IE
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
	
			Number.isInteger = function ( value ) {
	
				return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;
	
			};
	
		}
	
		//
	
		if ( Math.sign === undefined ) {
	
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
			Math.sign = function ( x ) {
	
				return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	
			};
	
		}
	
		if ( Function.prototype.name === undefined ) {
	
			// Missing in IE
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	
			Object.defineProperty( Function.prototype, 'name', {
	
				get: function () {
	
					return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];
	
				}
	
			} );
	
		}
	
		if ( Object.assign === undefined ) {
	
			// Missing in IE
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
			( function () {
	
				Object.assign = function ( target ) {
	
					'use strict';
	
					if ( target === undefined || target === null ) {
	
						throw new TypeError( 'Cannot convert undefined or null to object' );
	
					}
	
					var output = Object( target );
	
					for ( var index = 1; index < arguments.length; index ++ ) {
	
						var source = arguments[ index ];
	
						if ( source !== undefined && source !== null ) {
	
							for ( var nextKey in source ) {
	
								if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {
	
									output[ nextKey ] = source[ nextKey ];
	
								}
	
							}
	
						}
	
					}
	
					return output;
	
				};
	
			} )();
	
		}
	
		/**
		 * https://github.com/mrdoob/eventdispatcher.js/
		 */
	
		function EventDispatcher() {}
	
		Object.assign( EventDispatcher.prototype, {
	
			addEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) this._listeners = {};
	
				var listeners = this._listeners;
	
				if ( listeners[ type ] === undefined ) {
	
					listeners[ type ] = [];
	
				}
	
				if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
					listeners[ type ].push( listener );
	
				}
	
			},
	
			hasEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) return false;
	
				var listeners = this._listeners;
	
				return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;
	
			},
	
			removeEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) return;
	
				var listeners = this._listeners;
				var listenerArray = listeners[ type ];
	
				if ( listenerArray !== undefined ) {
	
					var index = listenerArray.indexOf( listener );
	
					if ( index !== - 1 ) {
	
						listenerArray.splice( index, 1 );
	
					}
	
				}
	
			},
	
			dispatchEvent: function ( event ) {
	
				if ( this._listeners === undefined ) return;
	
				var listeners = this._listeners;
				var listenerArray = listeners[ event.type ];
	
				if ( listenerArray !== undefined ) {
	
					event.target = this;
	
					var array = listenerArray.slice( 0 );
	
					for ( var i = 0, l = array.length; i < l; i ++ ) {
	
						array[ i ].call( this, event );
	
					}
	
				}
	
			}
	
		} );
	
		var REVISION = '86';
		var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
		var CullFaceNone = 0;
		var CullFaceBack = 1;
		var CullFaceFront = 2;
		var CullFaceFrontBack = 3;
		var FrontFaceDirectionCW = 0;
		var FrontFaceDirectionCCW = 1;
		var BasicShadowMap = 0;
		var PCFShadowMap = 1;
		var PCFSoftShadowMap = 2;
		var FrontSide = 0;
		var BackSide = 1;
		var DoubleSide = 2;
		var FlatShading = 1;
		var SmoothShading = 2;
		var NoColors = 0;
		var FaceColors = 1;
		var VertexColors = 2;
		var NoBlending = 0;
		var NormalBlending = 1;
		var AdditiveBlending = 2;
		var SubtractiveBlending = 3;
		var MultiplyBlending = 4;
		var CustomBlending = 5;
		var AddEquation = 100;
		var SubtractEquation = 101;
		var ReverseSubtractEquation = 102;
		var MinEquation = 103;
		var MaxEquation = 104;
		var ZeroFactor = 200;
		var OneFactor = 201;
		var SrcColorFactor = 202;
		var OneMinusSrcColorFactor = 203;
		var SrcAlphaFactor = 204;
		var OneMinusSrcAlphaFactor = 205;
		var DstAlphaFactor = 206;
		var OneMinusDstAlphaFactor = 207;
		var DstColorFactor = 208;
		var OneMinusDstColorFactor = 209;
		var SrcAlphaSaturateFactor = 210;
		var NeverDepth = 0;
		var AlwaysDepth = 1;
		var LessDepth = 2;
		var LessEqualDepth = 3;
		var EqualDepth = 4;
		var GreaterEqualDepth = 5;
		var GreaterDepth = 6;
		var NotEqualDepth = 7;
		var MultiplyOperation = 0;
		var MixOperation = 1;
		var AddOperation = 2;
		var NoToneMapping = 0;
		var LinearToneMapping = 1;
		var ReinhardToneMapping = 2;
		var Uncharted2ToneMapping = 3;
		var CineonToneMapping = 4;
		var UVMapping = 300;
		var CubeReflectionMapping = 301;
		var CubeRefractionMapping = 302;
		var EquirectangularReflectionMapping = 303;
		var EquirectangularRefractionMapping = 304;
		var SphericalReflectionMapping = 305;
		var CubeUVReflectionMapping = 306;
		var CubeUVRefractionMapping = 307;
		var RepeatWrapping = 1000;
		var ClampToEdgeWrapping = 1001;
		var MirroredRepeatWrapping = 1002;
		var NearestFilter = 1003;
		var NearestMipMapNearestFilter = 1004;
		var NearestMipMapLinearFilter = 1005;
		var LinearFilter = 1006;
		var LinearMipMapNearestFilter = 1007;
		var LinearMipMapLinearFilter = 1008;
		var UnsignedByteType = 1009;
		var ByteType = 1010;
		var ShortType = 1011;
		var UnsignedShortType = 1012;
		var IntType = 1013;
		var UnsignedIntType = 1014;
		var FloatType = 1015;
		var HalfFloatType = 1016;
		var UnsignedShort4444Type = 1017;
		var UnsignedShort5551Type = 1018;
		var UnsignedShort565Type = 1019;
		var UnsignedInt248Type = 1020;
		var AlphaFormat = 1021;
		var RGBFormat = 1022;
		var RGBAFormat = 1023;
		var LuminanceFormat = 1024;
		var LuminanceAlphaFormat = 1025;
		var RGBEFormat = RGBAFormat;
		var DepthFormat = 1026;
		var DepthStencilFormat = 1027;
		var RGB_S3TC_DXT1_Format = 2001;
		var RGBA_S3TC_DXT1_Format = 2002;
		var RGBA_S3TC_DXT3_Format = 2003;
		var RGBA_S3TC_DXT5_Format = 2004;
		var RGB_PVRTC_4BPPV1_Format = 2100;
		var RGB_PVRTC_2BPPV1_Format = 2101;
		var RGBA_PVRTC_4BPPV1_Format = 2102;
		var RGBA_PVRTC_2BPPV1_Format = 2103;
		var RGB_ETC1_Format = 2151;
		var LoopOnce = 2200;
		var LoopRepeat = 2201;
		var LoopPingPong = 2202;
		var InterpolateDiscrete = 2300;
		var InterpolateLinear = 2301;
		var InterpolateSmooth = 2302;
		var ZeroCurvatureEnding = 2400;
		var ZeroSlopeEnding = 2401;
		var WrapAroundEnding = 2402;
		var TrianglesDrawMode = 0;
		var TriangleStripDrawMode = 1;
		var TriangleFanDrawMode = 2;
		var LinearEncoding = 3000;
		var sRGBEncoding = 3001;
		var GammaEncoding = 3007;
		var RGBEEncoding = 3002;
		var LogLuvEncoding = 3003;
		var RGBM7Encoding = 3004;
		var RGBM16Encoding = 3005;
		var RGBDEncoding = 3006;
		var BasicDepthPacking = 3200;
		var RGBADepthPacking = 3201;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var _Math = {
	
			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,
	
			generateUUID: function () {
	
				// http://www.broofa.com/Tools/Math.uuid.htm
	
				var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
				var uuid = new Array( 36 );
				var rnd = 0, r;
	
				return function generateUUID() {
	
					for ( var i = 0; i < 36; i ++ ) {
	
						if ( i === 8 || i === 13 || i === 18 || i === 23 ) {
	
							uuid[ i ] = '-';
	
						} else if ( i === 14 ) {
	
							uuid[ i ] = '4';
	
						} else {
	
							if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
							r = rnd & 0xf;
							rnd = rnd >> 4;
							uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
						}
	
					}
	
					return uuid.join( '' );
	
				};
	
			}(),
	
			clamp: function ( value, min, max ) {
	
				return Math.max( min, Math.min( max, value ) );
	
			},
	
			// compute euclidian modulo of m % n
			// https://en.wikipedia.org/wiki/Modulo_operation
	
			euclideanModulo: function ( n, m ) {
	
				return ( ( n % m ) + m ) % m;
	
			},
	
			// Linear mapping from range <a1, a2> to range <b1, b2>
	
			mapLinear: function ( x, a1, a2, b1, b2 ) {
	
				return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
			},
	
			// https://en.wikipedia.org/wiki/Linear_interpolation
	
			lerp: function ( x, y, t ) {
	
				return ( 1 - t ) * x + t * y;
	
			},
	
			// http://en.wikipedia.org/wiki/Smoothstep
	
			smoothstep: function ( x, min, max ) {
	
				if ( x <= min ) return 0;
				if ( x >= max ) return 1;
	
				x = ( x - min ) / ( max - min );
	
				return x * x * ( 3 - 2 * x );
	
			},
	
			smootherstep: function ( x, min, max ) {
	
				if ( x <= min ) return 0;
				if ( x >= max ) return 1;
	
				x = ( x - min ) / ( max - min );
	
				return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
			},
	
			// Random integer from <low, high> interval
	
			randInt: function ( low, high ) {
	
				return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
			},
	
			// Random float from <low, high> interval
	
			randFloat: function ( low, high ) {
	
				return low + Math.random() * ( high - low );
	
			},
	
			// Random float from <-range/2, range/2> interval
	
			randFloatSpread: function ( range ) {
	
				return range * ( 0.5 - Math.random() );
	
			},
	
			degToRad: function ( degrees ) {
	
				return degrees * _Math.DEG2RAD;
	
			},
	
			radToDeg: function ( radians ) {
	
				return radians * _Math.RAD2DEG;
	
			},
	
			isPowerOfTwo: function ( value ) {
	
				return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
			},
	
			nearestPowerOfTwo: function ( value ) {
	
				return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );
	
			},
	
			nextPowerOfTwo: function ( value ) {
	
				value --;
				value |= value >> 1;
				value |= value >> 2;
				value |= value >> 4;
				value |= value >> 8;
				value |= value >> 16;
				value ++;
	
				return value;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author philogb / http://blog.thejit.org/
		 * @author egraether / http://egraether.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */
	
		function Vector2( x, y ) {
	
			this.x = x || 0;
			this.y = y || 0;
	
		}
	
		Object.defineProperties( Vector2.prototype, {
	
			"width" : {
	
				get: function () {
	
					return this.x;
	
				},
	
				set: function ( value ) {
	
					this.x = value;
	
				}
	
			},
	
			"height" : {
	
				get: function () {
	
					return this.y;
	
				},
	
				set: function ( value ) {
	
					this.y = value;
	
				}
	
			}
	
		} );
	
		Object.assign( Vector2.prototype, {
	
			isVector2: true,
	
			set: function ( x, y ) {
	
				this.x = x;
				this.y = y;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
	
				return this;
	
			},
	
			multiply: function ( v ) {
	
				this.x *= v.x;
				this.y *= v.y;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				this.x *= scalar;
				this.y *= scalar;
	
				return this;
	
			},
	
			divide: function ( v ) {
	
				this.x /= v.x;
				this.y /= v.y;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// assumes min < max, componentwise
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min = new Vector2();
				var max = new Vector2();
	
				return function clampScalar( minVal, maxVal ) {
	
					min.set( minVal, minVal );
					max.set( maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			clampLength: function ( min, max ) {
	
				var length = this.length();
	
				return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
	
			},
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y );
	
			},
	
			lengthManhattan: function() {
	
				return Math.abs( this.x ) + Math.abs( this.y );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() || 1 );
	
			},
	
			angle: function () {
	
				// computes the angle in radians with respect to the positive x-axis
	
				var angle = Math.atan2( this.y, this.x );
	
				if ( angle < 0 ) angle += 2 * Math.PI;
	
				return angle;
	
			},
	
			distanceTo: function ( v ) {
	
				return Math.sqrt( this.distanceToSquared( v ) );
	
			},
	
			distanceToSquared: function ( v ) {
	
				var dx = this.x - v.x, dy = this.y - v.y;
				return dx * dx + dy * dy;
	
			},
	
			distanceToManhattan: function ( v ) {
	
				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
	
			},
	
			setLength: function ( length ) {
	
				return this.normalize().multiplyScalar( length );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
	
				return array;
	
			},
	
			fromBufferAttribute: function ( attribute, index, offset ) {
	
				if ( offset !== undefined ) {
	
					console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );
	
				}
	
				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
	
				return this;
	
			},
	
			rotateAround: function ( center, angle ) {
	
				var c = Math.cos( angle ), s = Math.sin( angle );
	
				var x = this.x - center.x;
				var y = this.y - center.y;
	
				this.x = x * c - y * s + center.x;
				this.y = x * s + y * c + center.y;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */
	
		var textureId = 0;
	
		function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
			Object.defineProperty( this, 'id', { value: textureId ++ } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
	
			this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
			this.mipmaps = [];
	
			this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
	
			this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
			this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
	
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
	
			this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
			this.format = format !== undefined ? format : RGBAFormat;
			this.type = type !== undefined ? type : UnsignedByteType;
	
			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
	
			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding !== undefined ? encoding : LinearEncoding;
	
			this.version = 0;
			this.onUpdate = null;
	
		}
	
		Texture.DEFAULT_IMAGE = undefined;
		Texture.DEFAULT_MAPPING = UVMapping;
	
		Object.defineProperty( Texture.prototype, "needsUpdate", {
	
			set: function ( value ) {
	
				if ( value === true ) this.version ++;
	
			}
	
		} );
	
		Object.assign( Texture.prototype, EventDispatcher.prototype, {
	
			constructor: Texture,
	
			isTexture: true,
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.name = source.name;
	
				this.image = source.image;
				this.mipmaps = source.mipmaps.slice( 0 );
	
				this.mapping = source.mapping;
	
				this.wrapS = source.wrapS;
				this.wrapT = source.wrapT;
	
				this.magFilter = source.magFilter;
				this.minFilter = source.minFilter;
	
				this.anisotropy = source.anisotropy;
	
				this.format = source.format;
				this.type = source.type;
	
				this.offset.copy( source.offset );
				this.repeat.copy( source.repeat );
	
				this.generateMipmaps = source.generateMipmaps;
				this.premultiplyAlpha = source.premultiplyAlpha;
				this.flipY = source.flipY;
				this.unpackAlignment = source.unpackAlignment;
				this.encoding = source.encoding;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				if ( meta.textures[ this.uuid ] !== undefined ) {
	
					return meta.textures[ this.uuid ];
	
				}
	
				function getDataURL( image ) {
	
					var canvas;
	
					if ( image.toDataURL !== undefined ) {
	
						canvas = image;
	
					} else {
	
						canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
						canvas.width = image.width;
						canvas.height = image.height;
	
						canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );
	
					}
	
					if ( canvas.width > 2048 || canvas.height > 2048 ) {
	
						return canvas.toDataURL( 'image/jpeg', 0.6 );
	
					} else {
	
						return canvas.toDataURL( 'image/png' );
	
					}
	
				}
	
				var output = {
					metadata: {
						version: 4.5,
						type: 'Texture',
						generator: 'Texture.toJSON'
					},
	
					uuid: this.uuid,
					name: this.name,
	
					mapping: this.mapping,
	
					repeat: [ this.repeat.x, this.repeat.y ],
					offset: [ this.offset.x, this.offset.y ],
					wrap: [ this.wrapS, this.wrapT ],
	
					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,
	
					flipY: this.flipY
				};
	
				if ( this.image !== undefined ) {
	
					// TODO: Move to THREE.Image
	
					var image = this.image;
	
					if ( image.uuid === undefined ) {
	
						image.uuid = _Math.generateUUID(); // UGH
	
					}
	
					if ( meta.images[ image.uuid ] === undefined ) {
	
						meta.images[ image.uuid ] = {
							uuid: image.uuid,
							url: getDataURL( image )
						};
	
					}
	
					output.image = image.uuid;
	
				}
	
				meta.textures[ this.uuid ] = output;
	
				return output;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			},
	
			transformUv: function ( uv ) {
	
				if ( this.mapping !== UVMapping ) return;
	
				uv.multiply( this.repeat );
				uv.add( this.offset );
	
				if ( uv.x < 0 || uv.x > 1 ) {
	
					switch ( this.wrapS ) {
	
						case RepeatWrapping:
	
							uv.x = uv.x - Math.floor( uv.x );
							break;
	
						case ClampToEdgeWrapping:
	
							uv.x = uv.x < 0 ? 0 : 1;
							break;
	
						case MirroredRepeatWrapping:
	
							if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
	
								uv.x = Math.ceil( uv.x ) - uv.x;
	
							} else {
	
								uv.x = uv.x - Math.floor( uv.x );
	
							}
							break;
	
					}
	
				}
	
				if ( uv.y < 0 || uv.y > 1 ) {
	
					switch ( this.wrapT ) {
	
						case RepeatWrapping:
	
							uv.y = uv.y - Math.floor( uv.y );
							break;
	
						case ClampToEdgeWrapping:
	
							uv.y = uv.y < 0 ? 0 : 1;
							break;
	
						case MirroredRepeatWrapping:
	
							if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
	
								uv.y = Math.ceil( uv.y ) - uv.y;
	
							} else {
	
								uv.y = uv.y - Math.floor( uv.y );
	
							}
							break;
	
					}
	
				}
	
				if ( this.flipY ) {
	
					uv.y = 1 - uv.y;
	
				}
	
			}
	
		} );
	
		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Vector4( x, y, z, w ) {
	
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;
	
		}
	
		Object.assign( Vector4.prototype, {
	
			isVector4: true,
	
			set: function ( x, y, z, w ) {
	
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
				this.w = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setZ: function ( z ) {
	
				this.z = z;
	
				return this;
	
			},
	
			setW: function ( w ) {
	
				this.w = w;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					case 3: this.w = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					case 3: return this.w;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y, this.z, this.w );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				this.w = ( v.w !== undefined ) ? v.w : 1;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
				this.z += s;
				this.w += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
				this.w = a.w + b.w;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
				this.z -= s;
				this.w -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
				this.w = a.w - b.w;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
				this.w *= scalar;
	
				return this;
	
			},
	
			applyMatrix4: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z, w = this.w;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
				this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			setAxisAngleFromQuaternion: function ( q ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
				// q is assumed to be normalized
	
				this.w = 2 * Math.acos( q.w );
	
				var s = Math.sqrt( 1 - q.w * q.w );
	
				if ( s < 0.0001 ) {
	
					 this.x = 1;
					 this.y = 0;
					 this.z = 0;
	
				} else {
	
					 this.x = q.x / s;
					 this.y = q.y / s;
					 this.z = q.z / s;
	
				}
	
				return this;
	
			},
	
			setAxisAngleFromRotationMatrix: function ( m ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var angle, x, y, z,		// variables for result
					epsilon = 0.01,		// margin to allow for rounding errors
					epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
					te = m.elements,
	
					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
				if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
				     ( Math.abs( m13 - m31 ) < epsilon ) &&
				     ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
					// singularity found
					// first check for identity matrix which must have +1 for all terms
					// in leading diagonal and zero in other terms
	
					if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
					     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
					     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
					     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
						// this singularity is identity matrix so angle = 0
	
						this.set( 1, 0, 0, 0 );
	
						return this; // zero angle, arbitrary axis
	
					}
	
					// otherwise this singularity is angle = 180
	
					angle = Math.PI;
	
					var xx = ( m11 + 1 ) / 2;
					var yy = ( m22 + 1 ) / 2;
					var zz = ( m33 + 1 ) / 2;
					var xy = ( m12 + m21 ) / 4;
					var xz = ( m13 + m31 ) / 4;
					var yz = ( m23 + m32 ) / 4;
	
					if ( ( xx > yy ) && ( xx > zz ) ) {
	
						// m11 is the largest diagonal term
	
						if ( xx < epsilon ) {
	
							x = 0;
							y = 0.707106781;
							z = 0.707106781;
	
						} else {
	
							x = Math.sqrt( xx );
							y = xy / x;
							z = xz / x;
	
						}
	
					} else if ( yy > zz ) {
	
						// m22 is the largest diagonal term
	
						if ( yy < epsilon ) {
	
							x = 0.707106781;
							y = 0;
							z = 0.707106781;
	
						} else {
	
							y = Math.sqrt( yy );
							x = xy / y;
							z = yz / y;
	
						}
	
					} else {
	
						// m33 is the largest diagonal term so base result on this
	
						if ( zz < epsilon ) {
	
							x = 0.707106781;
							y = 0.707106781;
							z = 0;
	
						} else {
	
							z = Math.sqrt( zz );
							x = xz / z;
							y = yz / z;
	
						}
	
					}
	
					this.set( x, y, z, angle );
	
					return this; // return 180 deg rotation
	
				}
	
				// as we have reached here there are no singularities so we can handle normally
	
				var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				                   ( m13 - m31 ) * ( m13 - m31 ) +
				                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
				if ( Math.abs( s ) < 0.001 ) s = 1;
	
				// prevent divide by zero, should not happen if matrix is orthogonal and should be
				// caught by singularity test above, but I've left it in just in case
	
				this.x = ( m32 - m23 ) / s;
				this.y = ( m13 - m31 ) / s;
				this.z = ( m21 - m12 ) / s;
				this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
				return this;
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
				this.w = Math.min( this.w, v.w );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
				this.w = Math.max( this.w, v.w );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// assumes min < max, componentwise
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
				this.w = Math.max( min.w, Math.min( max.w, this.w ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector4();
						max = new Vector4();
	
					}
	
					min.set( minVal, minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			clampLength: function ( min, max ) {
	
				var length = this.length();
	
				return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
	
			},
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
				this.w = Math.floor( this.w );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
				this.w = Math.ceil( this.w );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
				this.w = Math.round( this.w );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
				this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
				this.w = - this.w;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
			},
	
			lengthManhattan: function () {
	
				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() || 1 );
	
			},
	
			setLength: function ( length ) {
	
				return this.normalize().multiplyScalar( length );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
				this.w += ( v.w - this.w ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
				this.w = array[ offset + 3 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
				array[ offset + 3 ] = this.w;
	
				return array;
	
			},
	
			fromBufferAttribute: function ( attribute, index, offset ) {
	
				if ( offset !== undefined ) {
	
					console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );
	
				}
	
				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );
				this.w = attribute.getW( index );
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author szimek / https://github.com/szimek/
		 * @author alteredq / http://alteredqualia.com/
		 * @author Marius Kintel / https://github.com/kintel
		 */
	
		/*
		 In options, we can specify:
		 * Texture parameters for an auto-generated target texture
		 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
		*/
		function WebGLRenderTarget( width, height, options ) {
	
			this.uuid = _Math.generateUUID();
	
			this.width = width;
			this.height = height;
	
			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;
	
			this.viewport = new Vector4( 0, 0, width, height );
	
			options = options || {};
	
			if ( options.minFilter === undefined ) options.minFilter = LinearFilter;
	
			this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
	
			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
	
		}
	
		Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {
	
			isWebGLRenderTarget: true,
	
			setSize: function ( width, height ) {
	
				if ( this.width !== width || this.height !== height ) {
	
					this.width = width;
					this.height = height;
	
					this.dispose();
	
				}
	
				this.viewport.set( 0, 0, width, height );
				this.scissor.set( 0, 0, width, height );
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.width = source.width;
				this.height = source.height;
	
				this.viewport.copy( source.viewport );
	
				this.texture = source.texture.clone();
	
				this.depthBuffer = source.depthBuffer;
				this.stencilBuffer = source.stencilBuffer;
				this.depthTexture = source.depthTexture;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com
		 */
	
		function WebGLRenderTargetCube( width, height, options ) {
	
			WebGLRenderTarget.call( this, width, height, options );
	
			this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
			this.activeMipMapLevel = 0;
	
		}
	
		WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
		WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
	
		WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */
	
		function Quaternion( x, y, z, w ) {
	
			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;
	
		}
	
		Object.assign( Quaternion, {
	
			slerp: function ( qa, qb, qm, t ) {
	
				return qm.copy( qa ).slerp( qb, t );
	
			},
	
			slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
	
				// fuzz-free, array-based Quaternion SLERP operation
	
				var x0 = src0[ srcOffset0 + 0 ],
					y0 = src0[ srcOffset0 + 1 ],
					z0 = src0[ srcOffset0 + 2 ],
					w0 = src0[ srcOffset0 + 3 ],
	
					x1 = src1[ srcOffset1 + 0 ],
					y1 = src1[ srcOffset1 + 1 ],
					z1 = src1[ srcOffset1 + 2 ],
					w1 = src1[ srcOffset1 + 3 ];
	
				if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
	
					var s = 1 - t,
	
						cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	
						dir = ( cos >= 0 ? 1 : - 1 ),
						sqrSin = 1 - cos * cos;
	
					// Skip the Slerp for tiny steps to avoid numeric problems:
					if ( sqrSin > Number.EPSILON ) {
	
						var sin = Math.sqrt( sqrSin ),
							len = Math.atan2( sin, cos * dir );
	
						s = Math.sin( s * len ) / sin;
						t = Math.sin( t * len ) / sin;
	
					}
	
					var tDir = t * dir;
	
					x0 = x0 * s + x1 * tDir;
					y0 = y0 * s + y1 * tDir;
					z0 = z0 * s + z1 * tDir;
					w0 = w0 * s + w1 * tDir;
	
					// Normalize in case we just did a lerp:
					if ( s === 1 - t ) {
	
						var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
	
						x0 *= f;
						y0 *= f;
						z0 *= f;
						w0 *= f;
	
					}
	
				}
	
				dst[ dstOffset ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;
	
			}
	
		} );
	
		Object.defineProperties( Quaternion.prototype, {
	
			x: {
	
				get: function () {
	
					return this._x;
	
				},
	
				set: function ( value ) {
	
					this._x = value;
					this.onChangeCallback();
	
				}
	
			},
	
			y: {
	
				get: function () {
	
					return this._y;
	
				},
	
				set: function ( value ) {
	
					this._y = value;
					this.onChangeCallback();
	
				}
	
			},
	
			z: {
	
				get: function () {
	
					return this._z;
	
				},
	
				set: function ( value ) {
	
					this._z = value;
					this.onChangeCallback();
	
				}
	
			},
	
			w: {
	
				get: function () {
	
					return this._w;
	
				},
	
				set: function ( value ) {
	
					this._w = value;
					this.onChangeCallback();
	
				}
	
			}
	
		} );
	
		Object.assign( Quaternion.prototype, {
	
			set: function ( x, y, z, w ) {
	
				this._x = x;
				this._y = y;
				this._z = z;
				this._w = w;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this._x, this._y, this._z, this._w );
	
			},
	
			copy: function ( quaternion ) {
	
				this._x = quaternion.x;
				this._y = quaternion.y;
				this._z = quaternion.z;
				this._w = quaternion.w;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromEuler: function ( euler, update ) {
	
				if ( ! ( euler && euler.isEuler ) ) {
	
					throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
				}
	
				var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
	
				// http://www.mathworks.com/matlabcentral/fileexchange/
				// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
				//	content/SpinCalc.m
	
				var cos = Math.cos;
				var sin = Math.sin;
	
				var c1 = cos( x / 2 );
				var c2 = cos( y / 2 );
				var c3 = cos( z / 2 );
	
				var s1 = sin( x / 2 );
				var s2 = sin( y / 2 );
				var s3 = sin( z / 2 );
	
				if ( order === 'XYZ' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'YXZ' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				} else if ( order === 'ZXY' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'ZYX' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				} else if ( order === 'YZX' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'XZY' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				}
	
				if ( update !== false ) this.onChangeCallback();
	
				return this;
	
			},
	
			setFromAxisAngle: function ( axis, angle ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
				// assumes axis is normalized
	
				var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
				this._x = axis.x * s;
				this._y = axis.y * s;
				this._z = axis.z * s;
				this._w = Math.cos( halfAngle );
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromRotationMatrix: function ( m ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var te = m.elements,
	
					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
					trace = m11 + m22 + m33,
					s;
	
				if ( trace > 0 ) {
	
					s = 0.5 / Math.sqrt( trace + 1.0 );
	
					this._w = 0.25 / s;
					this._x = ( m32 - m23 ) * s;
					this._y = ( m13 - m31 ) * s;
					this._z = ( m21 - m12 ) * s;
	
				} else if ( m11 > m22 && m11 > m33 ) {
	
					s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
					this._w = ( m32 - m23 ) / s;
					this._x = 0.25 * s;
					this._y = ( m12 + m21 ) / s;
					this._z = ( m13 + m31 ) / s;
	
				} else if ( m22 > m33 ) {
	
					s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
					this._w = ( m13 - m31 ) / s;
					this._x = ( m12 + m21 ) / s;
					this._y = 0.25 * s;
					this._z = ( m23 + m32 ) / s;
	
				} else {
	
					s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
					this._w = ( m21 - m12 ) / s;
					this._x = ( m13 + m31 ) / s;
					this._y = ( m23 + m32 ) / s;
					this._z = 0.25 * s;
	
				}
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromUnitVectors: function () {
	
				// assumes direction vectors vFrom and vTo are normalized
	
				var v1 = new Vector3();
				var r;
	
				var EPS = 0.000001;
	
				return function setFromUnitVectors( vFrom, vTo ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					r = vFrom.dot( vTo ) + 1;
	
					if ( r < EPS ) {
	
						r = 0;
	
						if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
							v1.set( - vFrom.y, vFrom.x, 0 );
	
						} else {
	
							v1.set( 0, - vFrom.z, vFrom.y );
	
						}
	
					} else {
	
						v1.crossVectors( vFrom, vTo );
	
					}
	
					this._x = v1.x;
					this._y = v1.y;
					this._z = v1.z;
					this._w = r;
	
					return this.normalize();
	
				};
	
			}(),
	
			inverse: function () {
	
				return this.conjugate().normalize();
	
			},
	
			conjugate: function () {
	
				this._x *= - 1;
				this._y *= - 1;
				this._z *= - 1;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
			},
	
			lengthSq: function () {
	
				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
			},
	
			length: function () {
	
				return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
			},
	
			normalize: function () {
	
				var l = this.length();
	
				if ( l === 0 ) {
	
					this._x = 0;
					this._y = 0;
					this._z = 0;
					this._w = 1;
	
				} else {
	
					l = 1 / l;
	
					this._x = this._x * l;
					this._y = this._y * l;
					this._z = this._z * l;
					this._w = this._w * l;
	
				}
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			multiply: function ( q, p ) {
	
				if ( p !== undefined ) {
	
					console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
					return this.multiplyQuaternions( q, p );
	
				}
	
				return this.multiplyQuaternions( this, q );
	
			},
	
			premultiply: function ( q ) {
	
				return this.multiplyQuaternions( q, this );
	
			},
	
			multiplyQuaternions: function ( a, b ) {
	
				// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
				var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
				var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
				this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
				this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
				this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
				this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			slerp: function ( qb, t ) {
	
				if ( t === 0 ) return this;
				if ( t === 1 ) return this.copy( qb );
	
				var x = this._x, y = this._y, z = this._z, w = this._w;
	
				// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
				var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
				if ( cosHalfTheta < 0 ) {
	
					this._w = - qb._w;
					this._x = - qb._x;
					this._y = - qb._y;
					this._z = - qb._z;
	
					cosHalfTheta = - cosHalfTheta;
	
				} else {
	
					this.copy( qb );
	
				}
	
				if ( cosHalfTheta >= 1.0 ) {
	
					this._w = w;
					this._x = x;
					this._y = y;
					this._z = z;
	
					return this;
	
				}
	
				var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
				if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
					this._w = 0.5 * ( w + this._w );
					this._x = 0.5 * ( x + this._x );
					this._y = 0.5 * ( y + this._y );
					this._z = 0.5 * ( z + this._z );
	
					return this;
	
				}
	
				var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
				var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
					ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
				this._w = ( w * ratioA + this._w * ratioB );
				this._x = ( x * ratioA + this._x * ratioB );
				this._y = ( y * ratioA + this._y * ratioB );
				this._z = ( z * ratioA + this._z * ratioB );
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			equals: function ( quaternion ) {
	
				return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this._x = array[ offset ];
				this._y = array[ offset + 1 ];
				this._z = array[ offset + 2 ];
				this._w = array[ offset + 3 ];
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._w;
	
				return array;
	
			},
	
			onChange: function ( callback ) {
	
				this.onChangeCallback = callback;
	
				return this;
	
			},
	
			onChangeCallback: function () {}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Vector3( x, y, z ) {
	
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
	
		}
	
		Object.assign( Vector3.prototype, {
	
			isVector3: true,
	
			set: function ( x, y, z ) {
	
				this.x = x;
				this.y = y;
				this.z = z;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setZ: function ( z ) {
	
				this.z = z;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y, this.z );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
				this.z += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
				this.z -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
	
				return this;
	
			},
	
			multiply: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
					return this.multiplyVectors( v, w );
	
				}
	
				this.x *= v.x;
				this.y *= v.y;
				this.z *= v.z;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				this.x *= scalar;
				this.y *= scalar;
				this.z *= scalar;
	
				return this;
	
			},
	
			multiplyVectors: function ( a, b ) {
	
				this.x = a.x * b.x;
				this.y = a.y * b.y;
				this.z = a.z * b.z;
	
				return this;
	
			},
	
			applyEuler: function () {
	
				var quaternion = new Quaternion();
	
				return function applyEuler( euler ) {
	
					if ( ! ( euler && euler.isEuler ) ) {
	
						console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
					}
	
					return this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				};
	
			}(),
	
			applyAxisAngle: function () {
	
				var quaternion = new Quaternion();
	
				return function applyAxisAngle( axis, angle ) {
	
					return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				};
	
			}(),
	
			applyMatrix3: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
				this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
				this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
				return this;
	
			},
	
			applyMatrix4: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );
	
				this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * w;
				this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * w;
				this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;
	
				return this;
	
			},
	
			applyQuaternion: function ( q ) {
	
				var x = this.x, y = this.y, z = this.z;
				var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	
				// calculate quat * vector
	
				var ix =  qw * x + qy * z - qz * y;
				var iy =  qw * y + qz * x - qx * z;
				var iz =  qw * z + qx * y - qy * x;
				var iw = - qx * x - qy * y - qz * z;
	
				// calculate result * inverse quat
	
				this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
				this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
				this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
				return this;
	
			},
	
			project: function () {
	
				var matrix = new Matrix4();
	
				return function project( camera ) {
	
					matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
					return this.applyMatrix4( matrix );
	
				};
	
			}(),
	
			unproject: function () {
	
				var matrix = new Matrix4();
	
				return function unproject( camera ) {
	
					matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
					return this.applyMatrix4( matrix );
	
				};
	
			}(),
	
			transformDirection: function ( m ) {
	
				// input: THREE.Matrix4 affine matrix
				// vector interpreted as a direction
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
				return this.normalize();
	
			},
	
			divide: function ( v ) {
	
				this.x /= v.x;
				this.y /= v.y;
				this.z /= v.z;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// assumes min < max, componentwise
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min = new Vector3();
				var max = new Vector3();
	
				return function clampScalar( minVal, maxVal ) {
	
					min.set( minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			clampLength: function ( min, max ) {
	
				var length = this.length();
	
				return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
	
			},
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y + this.z * v.z;
	
			},
	
			// TODO lengthSquared?
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y + this.z * this.z;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
			},
	
			lengthManhattan: function () {
	
				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() || 1 );
	
			},
	
			setLength: function ( length ) {
	
				return this.normalize().multiplyScalar( length );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			cross: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
					return this.crossVectors( v, w );
	
				}
	
				var x = this.x, y = this.y, z = this.z;
	
				this.x = y * v.z - z * v.y;
				this.y = z * v.x - x * v.z;
				this.z = x * v.y - y * v.x;
	
				return this;
	
			},
	
			crossVectors: function ( a, b ) {
	
				var ax = a.x, ay = a.y, az = a.z;
				var bx = b.x, by = b.y, bz = b.z;
	
				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;
	
				return this;
	
			},
	
			projectOnVector: function ( vector ) {
	
				var scalar = vector.dot( this ) / vector.lengthSq();
	
				return this.copy( vector ).multiplyScalar( scalar );
	
			},
	
			projectOnPlane: function () {
	
				var v1 = new Vector3();
	
				return function projectOnPlane( planeNormal ) {
	
					v1.copy( this ).projectOnVector( planeNormal );
	
					return this.sub( v1 );
	
				};
	
			}(),
	
			reflect: function () {
	
				// reflect incident vector off plane orthogonal to normal
				// normal is assumed to have unit length
	
				var v1 = new Vector3();
	
				return function reflect( normal ) {
	
					return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
				};
	
			}(),
	
			angleTo: function ( v ) {
	
				var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
	
				// clamp, to handle numerical problems
	
				return Math.acos( _Math.clamp( theta, - 1, 1 ) );
	
			},
	
			distanceTo: function ( v ) {
	
				return Math.sqrt( this.distanceToSquared( v ) );
	
			},
	
			distanceToSquared: function ( v ) {
	
				var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	
				return dx * dx + dy * dy + dz * dz;
	
			},
	
			distanceToManhattan: function ( v ) {
	
				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
	
			},
	
			setFromSpherical: function ( s ) {
	
				var sinPhiRadius = Math.sin( s.phi ) * s.radius;
	
				this.x = sinPhiRadius * Math.sin( s.theta );
				this.y = Math.cos( s.phi ) * s.radius;
				this.z = sinPhiRadius * Math.cos( s.theta );
	
				return this;
	
			},
	
			setFromCylindrical: function ( c ) {
	
				this.x = c.radius * Math.sin( c.theta );
				this.y = c.y;
				this.z = c.radius * Math.cos( c.theta );
	
				return this;
	
			},
	
			setFromMatrixPosition: function ( m ) {
	
				var e = m.elements;
	
				this.x = e[ 12 ];
				this.y = e[ 13 ];
				this.z = e[ 14 ];
	
				return this;
	
			},
	
			setFromMatrixScale: function ( m ) {
	
				var sx = this.setFromMatrixColumn( m, 0 ).length();
				var sy = this.setFromMatrixColumn( m, 1 ).length();
				var sz = this.setFromMatrixColumn( m, 2 ).length();
	
				this.x = sx;
				this.y = sy;
				this.z = sz;
	
				return this;
	
			},
	
			setFromMatrixColumn: function ( m, index ) {
	
				return this.fromArray( m.elements, index * 4 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
	
				return array;
	
			},
	
			fromBufferAttribute: function ( attribute, index, offset ) {
	
				if ( offset !== undefined ) {
	
					console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );
	
				}
	
				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author jordi_ros / http://plattsoft.com
		 * @author D1plo1d / http://github.com/D1plo1d
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author timknip / http://www.floorplanner.com/
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Matrix4() {
	
			this.elements = [
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			];
	
			if ( arguments.length > 0 ) {
	
				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
			}
	
		}
	
		Object.assign( Matrix4.prototype, {
	
			isMatrix4: true,
	
			set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
				var te = this.elements;
	
				te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
				te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
				te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
				te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
				return this;
	
			},
	
			identity: function () {
	
				this.set(
	
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			clone: function () {
	
				return new Matrix4().fromArray( this.elements );
	
			},
	
			copy: function ( m ) {
	
				var te = this.elements;
				var me = m.elements;
	
				te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
				te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
				te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
				te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];
	
				return this;
	
			},
	
			copyPosition: function ( m ) {
	
				var te = this.elements, me = m.elements;
	
				te[ 12 ] = me[ 12 ];
				te[ 13 ] = me[ 13 ];
				te[ 14 ] = me[ 14 ];
	
				return this;
	
			},
	
			extractBasis: function ( xAxis, yAxis, zAxis ) {
	
				xAxis.setFromMatrixColumn( this, 0 );
				yAxis.setFromMatrixColumn( this, 1 );
				zAxis.setFromMatrixColumn( this, 2 );
	
				return this;
	
			},
	
			makeBasis: function ( xAxis, yAxis, zAxis ) {
	
				this.set(
					xAxis.x, yAxis.x, zAxis.x, 0,
					xAxis.y, yAxis.y, zAxis.y, 0,
					xAxis.z, yAxis.z, zAxis.z, 0,
					0,       0,       0,       1
				);
	
				return this;
	
			},
	
			extractRotation: function () {
	
				var v1 = new Vector3();
	
				return function extractRotation( m ) {
	
					var te = this.elements;
					var me = m.elements;
	
					var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
					var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
					var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();
	
					te[ 0 ] = me[ 0 ] * scaleX;
					te[ 1 ] = me[ 1 ] * scaleX;
					te[ 2 ] = me[ 2 ] * scaleX;
	
					te[ 4 ] = me[ 4 ] * scaleY;
					te[ 5 ] = me[ 5 ] * scaleY;
					te[ 6 ] = me[ 6 ] * scaleY;
	
					te[ 8 ] = me[ 8 ] * scaleZ;
					te[ 9 ] = me[ 9 ] * scaleZ;
					te[ 10 ] = me[ 10 ] * scaleZ;
	
					return this;
	
				};
	
			}(),
	
			makeRotationFromEuler: function ( euler ) {
	
				if ( ! ( euler && euler.isEuler ) ) {
	
					console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
				}
	
				var te = this.elements;
	
				var x = euler.x, y = euler.y, z = euler.z;
				var a = Math.cos( x ), b = Math.sin( x );
				var c = Math.cos( y ), d = Math.sin( y );
				var e = Math.cos( z ), f = Math.sin( z );
	
				if ( euler.order === 'XYZ' ) {
	
					var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
					te[ 0 ] = c * e;
					te[ 4 ] = - c * f;
					te[ 8 ] = d;
	
					te[ 1 ] = af + be * d;
					te[ 5 ] = ae - bf * d;
					te[ 9 ] = - b * c;
	
					te[ 2 ] = bf - ae * d;
					te[ 6 ] = be + af * d;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'YXZ' ) {
	
					var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
					te[ 0 ] = ce + df * b;
					te[ 4 ] = de * b - cf;
					te[ 8 ] = a * d;
	
					te[ 1 ] = a * f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b;
	
					te[ 2 ] = cf * b - de;
					te[ 6 ] = df + ce * b;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'ZXY' ) {
	
					var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
					te[ 0 ] = ce - df * b;
					te[ 4 ] = - a * f;
					te[ 8 ] = de + cf * b;
	
					te[ 1 ] = cf + de * b;
					te[ 5 ] = a * e;
					te[ 9 ] = df - ce * b;
	
					te[ 2 ] = - a * d;
					te[ 6 ] = b;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'ZYX' ) {
	
					var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
					te[ 0 ] = c * e;
					te[ 4 ] = be * d - af;
					te[ 8 ] = ae * d + bf;
	
					te[ 1 ] = c * f;
					te[ 5 ] = bf * d + ae;
					te[ 9 ] = af * d - be;
	
					te[ 2 ] = - d;
					te[ 6 ] = b * c;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'YZX' ) {
	
					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
					te[ 0 ] = c * e;
					te[ 4 ] = bd - ac * f;
					te[ 8 ] = bc * f + ad;
	
					te[ 1 ] = f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b * e;
	
					te[ 2 ] = - d * e;
					te[ 6 ] = ad * f + bc;
					te[ 10 ] = ac - bd * f;
	
				} else if ( euler.order === 'XZY' ) {
	
					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
					te[ 0 ] = c * e;
					te[ 4 ] = - f;
					te[ 8 ] = d * e;
	
					te[ 1 ] = ac * f + bd;
					te[ 5 ] = a * e;
					te[ 9 ] = ad * f - bc;
	
					te[ 2 ] = bc * f - ad;
					te[ 6 ] = b * e;
					te[ 10 ] = bd * f + ac;
	
				}
	
				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;
	
				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
	
				return this;
	
			},
	
			makeRotationFromQuaternion: function ( q ) {
	
				var te = this.elements;
	
				var x = q._x, y = q._y, z = q._z, w = q._w;
				var x2 = x + x, y2 = y + y, z2 = z + z;
				var xx = x * x2, xy = x * y2, xz = x * z2;
				var yy = y * y2, yz = y * z2, zz = z * z2;
				var wx = w * x2, wy = w * y2, wz = w * z2;
	
				te[ 0 ] = 1 - ( yy + zz );
				te[ 4 ] = xy - wz;
				te[ 8 ] = xz + wy;
	
				te[ 1 ] = xy + wz;
				te[ 5 ] = 1 - ( xx + zz );
				te[ 9 ] = yz - wx;
	
				te[ 2 ] = xz - wy;
				te[ 6 ] = yz + wx;
				te[ 10 ] = 1 - ( xx + yy );
	
				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;
	
				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
	
				return this;
	
			},
	
			lookAt: function () {
	
				var x = new Vector3();
				var y = new Vector3();
				var z = new Vector3();
	
				return function lookAt( eye, target, up ) {
	
					var te = this.elements;
	
					z.subVectors( eye, target );
	
					if ( z.lengthSq() === 0 ) {
	
						// eye and target are in the same position
	
						z.z = 1;
	
					}
	
					z.normalize();
					x.crossVectors( up, z );
	
					if ( x.lengthSq() === 0 ) {
	
						// up and z are parallel
	
						if ( Math.abs( up.z ) === 1 ) {
	
							z.x += 0.0001;
	
						} else {
	
							z.z += 0.0001;
	
						}
	
						z.normalize();
						x.crossVectors( up, z );
	
					}
	
					x.normalize();
					y.crossVectors( z, x );
	
					te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
					te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
					te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
					return this;
	
				};
	
			}(),
	
			multiply: function ( m, n ) {
	
				if ( n !== undefined ) {
	
					console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
					return this.multiplyMatrices( m, n );
	
				}
	
				return this.multiplyMatrices( this, m );
	
			},
	
			premultiply: function ( m ) {
	
				return this.multiplyMatrices( m, this );
	
			},
	
			multiplyMatrices: function ( a, b ) {
	
				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;
	
				var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
				var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
				var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
				var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
				var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
				var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
				var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
				var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
				te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
				te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
				te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
				te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
				te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
				te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
				te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
				te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
				te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
				te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
				te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
				te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
				te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
				return this;
	
			},
	
			multiplyScalar: function ( s ) {
	
				var te = this.elements;
	
				te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
				te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
				te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
				te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
				return this;
	
			},
	
			applyToBufferAttribute: function () {
	
				var v1 = new Vector3();
	
				return function applyToBufferAttribute( attribute ) {
	
					for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
						v1.x = attribute.getX( i );
						v1.y = attribute.getY( i );
						v1.z = attribute.getZ( i );
	
						v1.applyMatrix4( this );
	
						attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
					}
	
					return attribute;
	
				};
	
			}(),
	
			determinant: function () {
	
				var te = this.elements;
	
				var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
				var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
				var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
				var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
				//TODO: make this more efficient
				//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
				return (
					n41 * (
						+ n14 * n23 * n32
						 - n13 * n24 * n32
						 - n14 * n22 * n33
						 + n12 * n24 * n33
						 + n13 * n22 * n34
						 - n12 * n23 * n34
					) +
					n42 * (
						+ n11 * n23 * n34
						 - n11 * n24 * n33
						 + n14 * n21 * n33
						 - n13 * n21 * n34
						 + n13 * n24 * n31
						 - n14 * n23 * n31
					) +
					n43 * (
						+ n11 * n24 * n32
						 - n11 * n22 * n34
						 - n14 * n21 * n32
						 + n12 * n21 * n34
						 + n14 * n22 * n31
						 - n12 * n24 * n31
					) +
					n44 * (
						- n13 * n22 * n31
						 - n11 * n23 * n32
						 + n11 * n22 * n33
						 + n13 * n21 * n32
						 - n12 * n21 * n33
						 + n12 * n23 * n31
					)
	
				);
	
			},
	
			transpose: function () {
	
				var te = this.elements;
				var tmp;
	
				tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
				tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
				tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
				tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
				tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
				tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
				return this;
	
			},
	
			setPosition: function ( v ) {
	
				var te = this.elements;
	
				te[ 12 ] = v.x;
				te[ 13 ] = v.y;
				te[ 14 ] = v.z;
	
				return this;
	
			},
	
			getInverse: function ( m, throwOnDegenerate ) {
	
				// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
				var te = this.elements,
					me = m.elements,
	
					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
					n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
					n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
					n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
	
					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	
				var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	
				if ( det === 0 ) {
	
					var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
					if ( throwOnDegenerate === true ) {
	
						throw new Error( msg );
	
					} else {
	
						console.warn( msg );
	
					}
	
					return this.identity();
	
				}
	
				var detInv = 1 / det;
	
				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
				te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
				te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
	
				te[ 4 ] = t12 * detInv;
				te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
				te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
				te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
	
				te[ 8 ] = t13 * detInv;
				te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
				te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
				te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
	
				te[ 12 ] = t14 * detInv;
				te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
				te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
				te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
	
				return this;
	
			},
	
			scale: function ( v ) {
	
				var te = this.elements;
				var x = v.x, y = v.y, z = v.z;
	
				te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
				te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
				te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
				te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
				return this;
	
			},
	
			getMaxScaleOnAxis: function () {
	
				var te = this.elements;
	
				var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
				var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
				var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
				return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
			},
	
			makeTranslation: function ( x, y, z ) {
	
				this.set(
	
					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationX: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					1, 0,  0, 0,
					0, c, - s, 0,
					0, s,  c, 0,
					0, 0,  0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationY: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					 c, 0, s, 0,
					 0, 1, 0, 0,
					- s, 0, c, 0,
					 0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationZ: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					c, - s, 0, 0,
					s,  c, 0, 0,
					0,  0, 1, 0,
					0,  0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationAxis: function ( axis, angle ) {
	
				// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
				var c = Math.cos( angle );
				var s = Math.sin( angle );
				var t = 1 - c;
				var x = axis.x, y = axis.y, z = axis.z;
				var tx = t * x, ty = t * y;
	
				this.set(
	
					tx * x + c, tx * y - s * z, tx * z + s * y, 0,
					tx * y + s * z, ty * y + c, ty * z - s * x, 0,
					tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
					0, 0, 0, 1
	
				);
	
				 return this;
	
			},
	
			makeScale: function ( x, y, z ) {
	
				this.set(
	
					x, 0, 0, 0,
					0, y, 0, 0,
					0, 0, z, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeShear: function ( x, y, z ) {
	
				this.set(
	
					1, y, z, 0,
					x, 1, z, 0,
					x, y, 1, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			compose: function ( position, quaternion, scale ) {
	
				this.makeRotationFromQuaternion( quaternion );
				this.scale( scale );
				this.setPosition( position );
	
				return this;
	
			},
	
			decompose: function () {
	
				var vector = new Vector3();
				var matrix = new Matrix4();
	
				return function decompose( position, quaternion, scale ) {
	
					var te = this.elements;
	
					var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
					var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
					var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
					// if determine is negative, we need to invert one scale
					var det = this.determinant();
					if ( det < 0 ) sx = - sx;
	
					position.x = te[ 12 ];
					position.y = te[ 13 ];
					position.z = te[ 14 ];
	
					// scale the rotation part
					matrix.copy( this );
	
					var invSX = 1 / sx;
					var invSY = 1 / sy;
					var invSZ = 1 / sz;
	
					matrix.elements[ 0 ] *= invSX;
					matrix.elements[ 1 ] *= invSX;
					matrix.elements[ 2 ] *= invSX;
	
					matrix.elements[ 4 ] *= invSY;
					matrix.elements[ 5 ] *= invSY;
					matrix.elements[ 6 ] *= invSY;
	
					matrix.elements[ 8 ] *= invSZ;
					matrix.elements[ 9 ] *= invSZ;
					matrix.elements[ 10 ] *= invSZ;
	
					quaternion.setFromRotationMatrix( matrix );
	
					scale.x = sx;
					scale.y = sy;
					scale.z = sz;
	
					return this;
	
				};
	
			}(),
	
			makePerspective: function ( left, right, top, bottom, near, far ) {
	
				if ( far === undefined ) {
	
					console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );
	
				}
	
				var te = this.elements;
				var x = 2 * near / ( right - left );
				var y = 2 * near / ( top - bottom );
	
				var a = ( right + left ) / ( right - left );
				var b = ( top + bottom ) / ( top - bottom );
				var c = - ( far + near ) / ( far - near );
				var d = - 2 * far * near / ( far - near );
	
				te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
				te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
				return this;
	
			},
	
			makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
				var te = this.elements;
				var w = 1.0 / ( right - left );
				var h = 1.0 / ( top - bottom );
				var p = 1.0 / ( far - near );
	
				var x = ( right + left ) * w;
				var y = ( top + bottom ) * h;
				var z = ( far + near ) * p;
	
				te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
				te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
				return this;
	
			},
	
			equals: function ( matrix ) {
	
				var te = this.elements;
				var me = matrix.elements;
	
				for ( var i = 0; i < 16; i ++ ) {
	
					if ( te[ i ] !== me[ i ] ) return false;
	
				}
	
				return true;
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				for ( var i = 0; i < 16; i ++ ) {
	
					this.elements[ i ] = array[ i + offset ];
	
				}
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				var te = this.elements;
	
				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
				array[ offset + 3 ] = te[ 3 ];
	
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
	
				array[ offset + 8 ] = te[ 8 ];
				array[ offset + 9 ] = te[ 9 ];
				array[ offset + 10 ] = te[ 10 ];
				array[ offset + 11 ] = te[ 11 ];
	
				array[ offset + 12 ] = te[ 12 ];
				array[ offset + 13 ] = te[ 13 ];
				array[ offset + 14 ] = te[ 14 ];
				array[ offset + 15 ] = te[ 15 ];
	
				return array;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.image = { data: data, width: width, height: height };
	
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
	
		}
	
		DataTexture.prototype = Object.create( Texture.prototype );
		DataTexture.prototype.constructor = DataTexture;
	
		DataTexture.prototype.isDataTexture = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	
			Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.flipY = false;
	
		}
	
		CubeTexture.prototype = Object.create( Texture.prototype );
		CubeTexture.prototype.constructor = CubeTexture;
	
		CubeTexture.prototype.isCubeTexture = true;
	
		Object.defineProperty( CubeTexture.prototype, 'images', {
	
			get: function () {
	
				return this.image;
	
			},
	
			set: function ( value ) {
	
				this.image = value;
	
			}
	
		} );
	
		/**
		 * @author tschw
		 *
		 * Uniforms of a program.
		 * Those form a tree structure with a special top-level container for the root,
		 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
		 *
		 *
		 * Properties of inner nodes including the top-level container:
		 *
		 * .seq - array of nested uniforms
		 * .map - nested uniforms by name
		 *
		 *
		 * Methods of all nodes except the top-level container:
		 *
		 * .setValue( gl, value, [renderer] )
		 *
		 * 		uploads a uniform value(s)
		 *  	the 'renderer' parameter is needed for sampler uniforms
		 *
		 *
		 * Static methods of the top-level container (renderer factorizations):
		 *
		 * .upload( gl, seq, values, renderer )
		 *
		 * 		sets uniforms in 'seq' to 'values[id].value'
		 *
		 * .seqWithValue( seq, values ) : filteredSeq
		 *
		 * 		filters 'seq' entries with corresponding entry in values
		 *
		 *
		 * Methods of the top-level container (renderer factorizations):
		 *
		 * .setValue( gl, name, value )
		 *
		 * 		sets uniform with  name 'name' to 'value'
		 *
		 * .set( gl, obj, prop )
		 *
		 * 		sets uniform from object and property with same name than uniform
		 *
		 * .setOptional( gl, obj, prop )
		 *
		 * 		like .set for an optional property of the object
		 *
		 */
	
		var emptyTexture = new Texture();
		var emptyCubeTexture = new CubeTexture();
	
		// --- Base for inner nodes (including the root) ---
	
		function UniformContainer() {
	
			this.seq = [];
			this.map = {};
	
		}
	
		// --- Utilities ---
	
		// Array Caches (provide typed arrays for temporary by size)
	
		var arrayCacheF32 = [];
		var arrayCacheI32 = [];
	
		// Float32Array caches used for uploading Matrix uniforms
	
		var mat4array = new Float32Array( 16 );
		var mat3array = new Float32Array( 9 );
	
		// Flattening for arrays of vectors and matrices
	
		function flatten( array, nBlocks, blockSize ) {
	
			var firstElem = array[ 0 ];
	
			if ( firstElem <= 0 || firstElem > 0 ) return array;
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983
	
			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];
	
			if ( r === undefined ) {
	
				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;
	
			}
	
			if ( nBlocks !== 0 ) {
	
				firstElem.toArray( r, 0 );
	
				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {
	
					offset += blockSize;
					array[ i ].toArray( r, offset );
	
				}
	
			}
	
			return r;
	
		}
	
		// Texture unit allocation
	
		function allocTexUnits( renderer, n ) {
	
			var r = arrayCacheI32[ n ];
	
			if ( r === undefined ) {
	
				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;
	
			}
	
			for ( var i = 0; i !== n; ++ i )
				r[ i ] = renderer.allocTextureUnit();
	
			return r;
	
		}
	
		// --- Setters ---
	
		// Note: Defining these methods externally, because they come in a bunch
		// and this way their names minify.
	
		// Single scalar
	
		function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
		function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }
	
		// Single float vector (from flat array or THREE.VectorN)
	
		function setValue2fv( gl, v ) {
	
			if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
			else gl.uniform2f( this.addr, v.x, v.y );
	
		}
	
		function setValue3fv( gl, v ) {
	
			if ( v.x !== undefined )
				gl.uniform3f( this.addr, v.x, v.y, v.z );
			else if ( v.r !== undefined )
				gl.uniform3f( this.addr, v.r, v.g, v.b );
			else
				gl.uniform3fv( this.addr, v );
	
		}
	
		function setValue4fv( gl, v ) {
	
			if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
			else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
	
		}
	
		// Single matrix (from flat array or MatrixN)
	
		function setValue2fm( gl, v ) {
	
			gl.uniformMatrix2fv( this.addr, false, v.elements || v );
	
		}
	
		function setValue3fm( gl, v ) {
	
			if ( v.elements === undefined ) {
	
				gl.uniformMatrix3fv( this.addr, false, v );
	
			} else {
	
				mat3array.set( v.elements );
				gl.uniformMatrix3fv( this.addr, false, mat3array );
	
			}
	
		}
	
		function setValue4fm( gl, v ) {
	
			if ( v.elements === undefined ) {
	
				gl.uniformMatrix4fv( this.addr, false, v );
	
			} else {
	
				mat4array.set( v.elements );
				gl.uniformMatrix4fv( this.addr, false, mat4array );
	
			}
	
		}
	
		// Single texture (2D / Cube)
	
		function setValueT1( gl, v, renderer ) {
	
			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTexture2D( v || emptyTexture, unit );
	
		}
	
		function setValueT6( gl, v, renderer ) {
	
			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTextureCube( v || emptyCubeTexture, unit );
	
		}
	
		// Integer / Boolean vectors or arrays thereof (always flat arrays)
	
		function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
		function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
		function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }
	
		// Helper to pick the right setter for the singular case
	
		function getSingularSetter( type ) {
	
			switch ( type ) {
	
				case 0x1406: return setValue1f; // FLOAT
				case 0x8b50: return setValue2fv; // _VEC2
				case 0x8b51: return setValue3fv; // _VEC3
				case 0x8b52: return setValue4fv; // _VEC4
	
				case 0x8b5a: return setValue2fm; // _MAT2
				case 0x8b5b: return setValue3fm; // _MAT3
				case 0x8b5c: return setValue4fm; // _MAT4
	
				case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
				case 0x8b60: return setValueT6; // SAMPLER_CUBE
	
				case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
			}
	
		}
	
		// Array of scalars
	
		function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
		function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }
	
		// Array of vectors (flat or from THREE classes)
	
		function setValueV2a( gl, v ) {
	
			gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );
	
		}
	
		function setValueV3a( gl, v ) {
	
			gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );
	
		}
	
		function setValueV4a( gl, v ) {
	
			gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );
	
		}
	
		// Array of matrices (flat or from THREE clases)
	
		function setValueM2a( gl, v ) {
	
			gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );
	
		}
	
		function setValueM3a( gl, v ) {
	
			gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );
	
		}
	
		function setValueM4a( gl, v ) {
	
			gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );
	
		}
	
		// Array of textures (2D / Cube)
	
		function setValueT1a( gl, v, renderer ) {
	
			var n = v.length,
				units = allocTexUnits( renderer, n );
	
			gl.uniform1iv( this.addr, units );
	
			for ( var i = 0; i !== n; ++ i ) {
	
				renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );
	
			}
	
		}
	
		function setValueT6a( gl, v, renderer ) {
	
			var n = v.length,
				units = allocTexUnits( renderer, n );
	
			gl.uniform1iv( this.addr, units );
	
			for ( var i = 0; i !== n; ++ i ) {
	
				renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );
	
			}
	
		}
	
		// Helper to pick the right setter for a pure (bottom-level) array
	
		function getPureArraySetter( type ) {
	
			switch ( type ) {
	
				case 0x1406: return setValue1fv; // FLOAT
				case 0x8b50: return setValueV2a; // _VEC2
				case 0x8b51: return setValueV3a; // _VEC3
				case 0x8b52: return setValueV4a; // _VEC4
	
				case 0x8b5a: return setValueM2a; // _MAT2
				case 0x8b5b: return setValueM3a; // _MAT3
				case 0x8b5c: return setValueM4a; // _MAT4
	
				case 0x8b5e: return setValueT1a; // SAMPLER_2D
				case 0x8b60: return setValueT6a; // SAMPLER_CUBE
	
				case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
			}
	
		}
	
		// --- Uniform Classes ---
	
		function SingleUniform( id, activeInfo, addr ) {
	
			this.id = id;
			this.addr = addr;
			this.setValue = getSingularSetter( activeInfo.type );
	
			// this.path = activeInfo.name; // DEBUG
	
		}
	
		function PureArrayUniform( id, activeInfo, addr ) {
	
			this.id = id;
			this.addr = addr;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );
	
			// this.path = activeInfo.name; // DEBUG
	
		}
	
		function StructuredUniform( id ) {
	
			this.id = id;
	
			UniformContainer.call( this ); // mix-in
	
		}
	
		StructuredUniform.prototype.setValue = function ( gl, value ) {
	
			// Note: Don't need an extra 'renderer' parameter, since samplers
			// are not allowed in structured uniforms.
	
			var seq = this.seq;
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				u.setValue( gl, value[ u.id ] );
	
			}
	
		};
	
		// --- Top-level ---
	
		// Parser - builds up the property tree from the path strings
	
		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
	
		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.
	
		function addUniform( container, uniformObject ) {
	
			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;
	
		}
	
		function parseUniform( activeInfo, addr, container ) {
	
			var path = activeInfo.name,
				pathLength = path.length;
	
			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;
	
			for ( ; ; ) {
	
				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,
	
					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];
	
				if ( idIsIndex ) id = id | 0; // convert to integer
	
				if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {
	
					// bare name or "pure" bottom-level array "[0]" suffix
	
					addUniform( container, subscript === undefined ?
							new SingleUniform( id, activeInfo, addr ) :
							new PureArrayUniform( id, activeInfo, addr ) );
	
					break;
	
				} else {
	
					// step into inner node / create it in case it doesn't exist
	
					var map = container.map, next = map[ id ];
	
					if ( next === undefined ) {
	
						next = new StructuredUniform( id );
						addUniform( container, next );
	
					}
	
					container = next;
	
				}
	
			}
	
		}
	
		// Root Container
	
		function WebGLUniforms( gl, program, renderer ) {
	
			UniformContainer.call( this );
	
			this.renderer = renderer;
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
	
			for ( var i = 0; i < n; ++ i ) {
	
				var info = gl.getActiveUniform( program, i ),
					path = info.name,
					addr = gl.getUniformLocation( program, path );
	
				parseUniform( info, addr, this );
	
			}
	
		}
	
		WebGLUniforms.prototype.setValue = function ( gl, name, value ) {
	
			var u = this.map[ name ];
	
			if ( u !== undefined ) u.setValue( gl, value, this.renderer );
	
		};
	
		WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {
	
			var v = object[ name ];
	
			if ( v !== undefined ) this.setValue( gl, name, v );
	
		};
	
	
		// Static interface
	
		WebGLUniforms.upload = function ( gl, seq, values, renderer ) {
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ],
					v = values[ u.id ];
	
				if ( v.needsUpdate !== false ) {
	
					// note: always updating when .needsUpdate is undefined
					u.setValue( gl, v.value, renderer );
	
				}
	
			}
	
		};
	
		WebGLUniforms.seqWithValue = function ( seq, values ) {
	
			var r = [];
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				if ( u.id in values ) r.push( u );
	
			}
	
			return r;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
			'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
			'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
			'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
			'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
			'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
			'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
			'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
			'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
			'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
			'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
			'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
			'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
			'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
			'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
			'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
			'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
			'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
			'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
			'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
			'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
			'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
			'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
			'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
		function Color( r, g, b ) {
	
			if ( g === undefined && b === undefined ) {
	
				// r is THREE.Color, hex or string
				return this.set( r );
	
			}
	
			return this.setRGB( r, g, b );
	
		}
	
		Object.assign( Color.prototype, {
	
			isColor: true,
	
			r: 1, g: 1, b: 1,
	
			set: function ( value ) {
	
				if ( value && value.isColor ) {
	
					this.copy( value );
	
				} else if ( typeof value === 'number' ) {
	
					this.setHex( value );
	
				} else if ( typeof value === 'string' ) {
	
					this.setStyle( value );
	
				}
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.r = scalar;
				this.g = scalar;
				this.b = scalar;
	
				return this;
	
			},
	
			setHex: function ( hex ) {
	
				hex = Math.floor( hex );
	
				this.r = ( hex >> 16 & 255 ) / 255;
				this.g = ( hex >> 8 & 255 ) / 255;
				this.b = ( hex & 255 ) / 255;
	
				return this;
	
			},
	
			setRGB: function ( r, g, b ) {
	
				this.r = r;
				this.g = g;
				this.b = b;
	
				return this;
	
			},
	
			setHSL: function () {
	
				function hue2rgb( p, q, t ) {
	
					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;
	
				}
	
				return function setHSL( h, s, l ) {
	
					// h,s,l ranges are in 0.0 - 1.0
					h = _Math.euclideanModulo( h, 1 );
					s = _Math.clamp( s, 0, 1 );
					l = _Math.clamp( l, 0, 1 );
	
					if ( s === 0 ) {
	
						this.r = this.g = this.b = l;
	
					} else {
	
						var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
						var q = ( 2 * l ) - p;
	
						this.r = hue2rgb( q, p, h + 1 / 3 );
						this.g = hue2rgb( q, p, h );
						this.b = hue2rgb( q, p, h - 1 / 3 );
	
					}
	
					return this;
	
				};
	
			}(),
	
			setStyle: function ( style ) {
	
				function handleAlpha( string ) {
	
					if ( string === undefined ) return;
	
					if ( parseFloat( string ) < 1 ) {
	
						console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
	
					}
	
				}
	
	
				var m;
	
				if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	
					// rgb / hsl
	
					var color;
					var name = m[ 1 ];
					var components = m[ 2 ];
	
					switch ( name ) {
	
						case 'rgb':
						case 'rgba':
	
							if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// rgb(255,0,0) rgba(255,0,0,0.5)
								this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
								this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
								this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
								handleAlpha( color[ 5 ] );
	
								return this;
	
							}
	
							if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
								this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
								this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
								this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
								handleAlpha( color[ 5 ] );
	
								return this;
	
							}
	
							break;
	
						case 'hsl':
						case 'hsla':
	
							if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
								var h = parseFloat( color[ 1 ] ) / 360;
								var s = parseInt( color[ 2 ], 10 ) / 100;
								var l = parseInt( color[ 3 ], 10 ) / 100;
	
								handleAlpha( color[ 5 ] );
	
								return this.setHSL( h, s, l );
	
							}
	
							break;
	
					}
	
				} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	
					// hex color
	
					var hex = m[ 1 ];
					var size = hex.length;
	
					if ( size === 3 ) {
	
						// #ff0
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
	
						return this;
	
					} else if ( size === 6 ) {
	
						// #ff0000
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
	
						return this;
	
					}
	
				}
	
				if ( style && style.length > 0 ) {
	
					// color keywords
					var hex = ColorKeywords[ style ];
	
					if ( hex !== undefined ) {
	
						// red
						this.setHex( hex );
	
					} else {
	
						// unknown color
						console.warn( 'THREE.Color: Unknown color ' + style );
	
					}
	
				}
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this.r, this.g, this.b );
	
			},
	
			copy: function ( color ) {
	
				this.r = color.r;
				this.g = color.g;
				this.b = color.b;
	
				return this;
	
			},
	
			copyGammaToLinear: function ( color, gammaFactor ) {
	
				if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
				this.r = Math.pow( color.r, gammaFactor );
				this.g = Math.pow( color.g, gammaFactor );
				this.b = Math.pow( color.b, gammaFactor );
	
				return this;
	
			},
	
			copyLinearToGamma: function ( color, gammaFactor ) {
	
				if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
				var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
				this.r = Math.pow( color.r, safeInverse );
				this.g = Math.pow( color.g, safeInverse );
				this.b = Math.pow( color.b, safeInverse );
	
				return this;
	
			},
	
			convertGammaToLinear: function () {
	
				var r = this.r, g = this.g, b = this.b;
	
				this.r = r * r;
				this.g = g * g;
				this.b = b * b;
	
				return this;
	
			},
	
			convertLinearToGamma: function () {
	
				this.r = Math.sqrt( this.r );
				this.g = Math.sqrt( this.g );
				this.b = Math.sqrt( this.b );
	
				return this;
	
			},
	
			getHex: function () {
	
				return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
			},
	
			getHexString: function () {
	
				return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
			},
	
			getHSL: function ( optionalTarget ) {
	
				// h,s,l ranges are in 0.0 - 1.0
	
				var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
				var r = this.r, g = this.g, b = this.b;
	
				var max = Math.max( r, g, b );
				var min = Math.min( r, g, b );
	
				var hue, saturation;
				var lightness = ( min + max ) / 2.0;
	
				if ( min === max ) {
	
					hue = 0;
					saturation = 0;
	
				} else {
	
					var delta = max - min;
	
					saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
					switch ( max ) {
	
						case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
						case g: hue = ( b - r ) / delta + 2; break;
						case b: hue = ( r - g ) / delta + 4; break;
	
					}
	
					hue /= 6;
	
				}
	
				hsl.h = hue;
				hsl.s = saturation;
				hsl.l = lightness;
	
				return hsl;
	
			},
	
			getStyle: function () {
	
				return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
			},
	
			offsetHSL: function ( h, s, l ) {
	
				var hsl = this.getHSL();
	
				hsl.h += h; hsl.s += s; hsl.l += l;
	
				this.setHSL( hsl.h, hsl.s, hsl.l );
	
				return this;
	
			},
	
			add: function ( color ) {
	
				this.r += color.r;
				this.g += color.g;
				this.b += color.b;
	
				return this;
	
			},
	
			addColors: function ( color1, color2 ) {
	
				this.r = color1.r + color2.r;
				this.g = color1.g + color2.g;
				this.b = color1.b + color2.b;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.r += s;
				this.g += s;
				this.b += s;
	
				return this;
	
			},
	
			sub: function( color ) {
	
				this.r = Math.max( 0, this.r - color.r );
				this.g = Math.max( 0, this.g - color.g );
				this.b = Math.max( 0, this.b - color.b );
	
				return this;
	
			},
	
			multiply: function ( color ) {
	
				this.r *= color.r;
				this.g *= color.g;
				this.b *= color.b;
	
				return this;
	
			},
	
			multiplyScalar: function ( s ) {
	
				this.r *= s;
				this.g *= s;
				this.b *= s;
	
				return this;
	
			},
	
			lerp: function ( color, alpha ) {
	
				this.r += ( color.r - this.r ) * alpha;
				this.g += ( color.g - this.g ) * alpha;
				this.b += ( color.b - this.b ) * alpha;
	
				return this;
	
			},
	
			equals: function ( c ) {
	
				return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.r = array[ offset ];
				this.g = array[ offset + 1 ];
				this.b = array[ offset + 2 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.r;
				array[ offset + 1 ] = this.g;
				array[ offset + 2 ] = this.b;
	
				return array;
	
			},
	
			toJSON: function () {
	
				return this.getHex();
	
			}
	
		} );
	
		/**
		 * Uniforms library for shared webgl shaders
		 */
	
		var UniformsLib = {
	
			common: {
	
				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
	
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },
	
				specularMap: { value: null },
				alphaMap: { value: null },
	
				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				reflectivity: { value: 1.0 },
				refractionRatio: { value: 0.98 }
	
			},
	
			aomap: {
	
				aoMap: { value: null },
				aoMapIntensity: { value: 1 }
	
			},
	
			lightmap: {
	
				lightMap: { value: null },
				lightMapIntensity: { value: 1 }
	
			},
	
			emissivemap: {
	
				emissiveMap: { value: null }
	
			},
	
			bumpmap: {
	
				bumpMap: { value: null },
				bumpScale: { value: 1 }
	
			},
	
			normalmap: {
	
				normalMap: { value: null },
				normalScale: { value: new Vector2( 1, 1 ) }
	
			},
	
			displacementmap: {
	
				displacementMap: { value: null },
				displacementScale: { value: 1 },
				displacementBias: { value: 0 }
	
			},
	
			roughnessmap: {
	
				roughnessMap: { value: null }
	
			},
	
			metalnessmap: {
	
				metalnessMap: { value: null }
	
			},
	
			gradientmap: {
	
				gradientMap: { value: null }
	
			},
	
			fog: {
	
				fogDensity: { value: 0.00025 },
				fogNear: { value: 1 },
				fogFar: { value: 2000 },
				fogColor: { value: new Color( 0xffffff ) }
	
			},
	
			lights: {
	
				ambientLightColor: { value: [] },
	
				directionalLights: { value: [], properties: {
					direction: {},
					color: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },
	
				spotLights: { value: [], properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },
	
				pointLights: { value: [], properties: {
					color: {},
					position: {},
					decay: {},
					distance: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },
	
				hemisphereLights: { value: [], properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				} },
	
				// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
				rectAreaLights: { value: [], properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				} }
	
			},
	
			points: {
	
				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
				size: { value: 1.0 },
				scale: { value: 1.0 },
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }
	
			}
	
		};
	
		/**
		 * Uniform Utilities
		 */
	
		var UniformsUtils = {
	
			merge: function ( uniforms ) {
	
				var merged = {};
	
				for ( var u = 0; u < uniforms.length; u ++ ) {
	
					var tmp = this.clone( uniforms[ u ] );
	
					for ( var p in tmp ) {
	
						merged[ p ] = tmp[ p ];
	
					}
	
				}
	
				return merged;
	
			},
	
			clone: function ( uniforms_src ) {
	
				var uniforms_dst = {};
	
				for ( var u in uniforms_src ) {
	
					uniforms_dst[ u ] = {};
	
					for ( var p in uniforms_src[ u ] ) {
	
						var parameter_src = uniforms_src[ u ][ p ];
	
						if ( parameter_src && ( parameter_src.isColor ||
							parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
							parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
							parameter_src.isTexture ) ) {
	
							uniforms_dst[ u ][ p ] = parameter_src.clone();
	
						} else if ( Array.isArray( parameter_src ) ) {
	
							uniforms_dst[ u ][ p ] = parameter_src.slice();
	
						} else {
	
							uniforms_dst[ u ][ p ] = parameter_src;
	
						}
	
					}
	
				}
	
				return uniforms_dst;
	
			}
	
		};
	
		var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
	
		var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
	
		var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
	
		var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
	
		var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
	
		var begin_vertex = "\nvec3 transformed = vec3( position );\n";
	
		var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
	
		var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
	
		var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
	
		var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";
	
		var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
	
		var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
	
		var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
	
		var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
	
		var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
	
		var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
	
		var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
	
		var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";
	
		var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
	
		var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";
	
		var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
	
		var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
	
		var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
	
		var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
	
		var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
	
		var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
	
		var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = asin( flipNormal * reflectVec.y ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
	
		var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
	
		var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
	
		var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
	
		var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
	
		var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
	
		var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
	
		var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
	
		var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
	
		var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
	
		var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
	
		var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
	
		var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
	
		var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
	
		var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
	
		var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
	
		var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
	
		var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
	
		var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
	
		var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
	
		var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
	
		var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";
	
		var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
	
		var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
	
		var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
	
		var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";
	
		var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";
	
		var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
	
		var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
	
		var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
	
		var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
	
		var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";
	
		var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
	
		var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
	
		var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
	
		var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
	
		var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";
	
		var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";
	
		var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";
	
		var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";
	
		var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
	
		var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
	
		var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
	
		var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
	
		var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
	
		var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
	
		var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
	
		var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";
	
		var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
	
		var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
	
		var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
	
		var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
	
		var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
	
		var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
	
		var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";
	
		var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
	
		var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
	
		var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
	
		var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
	
		var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";
	
		var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
	
		var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
	
		var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
	
		var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
	
		var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
	
		var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";
	
		var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
	
		var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
	
		var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
	
		var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
	
		var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
	
		var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
	
		var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";
	
		var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";
	
		var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
	
		var ShaderChunk = {
			alphamap_fragment: alphamap_fragment,
			alphamap_pars_fragment: alphamap_pars_fragment,
			alphatest_fragment: alphatest_fragment,
			aomap_fragment: aomap_fragment,
			aomap_pars_fragment: aomap_pars_fragment,
			begin_vertex: begin_vertex,
			beginnormal_vertex: beginnormal_vertex,
			bsdfs: bsdfs,
			bumpmap_pars_fragment: bumpmap_pars_fragment,
			clipping_planes_fragment: clipping_planes_fragment,
			clipping_planes_pars_fragment: clipping_planes_pars_fragment,
			clipping_planes_pars_vertex: clipping_planes_pars_vertex,
			clipping_planes_vertex: clipping_planes_vertex,
			color_fragment: color_fragment,
			color_pars_fragment: color_pars_fragment,
			color_pars_vertex: color_pars_vertex,
			color_vertex: color_vertex,
			common: common,
			cube_uv_reflection_fragment: cube_uv_reflection_fragment,
			defaultnormal_vertex: defaultnormal_vertex,
			displacementmap_pars_vertex: displacementmap_pars_vertex,
			displacementmap_vertex: displacementmap_vertex,
			emissivemap_fragment: emissivemap_fragment,
			emissivemap_pars_fragment: emissivemap_pars_fragment,
			encodings_fragment: encodings_fragment,
			encodings_pars_fragment: encodings_pars_fragment,
			envmap_fragment: envmap_fragment,
			envmap_pars_fragment: envmap_pars_fragment,
			envmap_pars_vertex: envmap_pars_vertex,
			envmap_vertex: envmap_vertex,
			fog_vertex: fog_vertex,
			fog_pars_vertex: fog_pars_vertex,
			fog_fragment: fog_fragment,
			fog_pars_fragment: fog_pars_fragment,
			gradientmap_pars_fragment: gradientmap_pars_fragment,
			lightmap_fragment: lightmap_fragment,
			lightmap_pars_fragment: lightmap_pars_fragment,
			lights_lambert_vertex: lights_lambert_vertex,
			lights_pars: lights_pars,
			lights_phong_fragment: lights_phong_fragment,
			lights_phong_pars_fragment: lights_phong_pars_fragment,
			lights_physical_fragment: lights_physical_fragment,
			lights_physical_pars_fragment: lights_physical_pars_fragment,
			lights_template: lights_template,
			logdepthbuf_fragment: logdepthbuf_fragment,
			logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
			logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
			logdepthbuf_vertex: logdepthbuf_vertex,
			map_fragment: map_fragment,
			map_pars_fragment: map_pars_fragment,
			map_particle_fragment: map_particle_fragment,
			map_particle_pars_fragment: map_particle_pars_fragment,
			metalnessmap_fragment: metalnessmap_fragment,
			metalnessmap_pars_fragment: metalnessmap_pars_fragment,
			morphnormal_vertex: morphnormal_vertex,
			morphtarget_pars_vertex: morphtarget_pars_vertex,
			morphtarget_vertex: morphtarget_vertex,
			normal_flip: normal_flip,
			normal_fragment: normal_fragment,
			normalmap_pars_fragment: normalmap_pars_fragment,
			packing: packing,
			premultiplied_alpha_fragment: premultiplied_alpha_fragment,
			project_vertex: project_vertex,
			dithering_fragment: dithering_fragment,
			dithering_pars_fragment: dithering_pars_fragment,
			roughnessmap_fragment: roughnessmap_fragment,
			roughnessmap_pars_fragment: roughnessmap_pars_fragment,
			shadowmap_pars_fragment: shadowmap_pars_fragment,
			shadowmap_pars_vertex: shadowmap_pars_vertex,
			shadowmap_vertex: shadowmap_vertex,
			shadowmask_pars_fragment: shadowmask_pars_fragment,
			skinbase_vertex: skinbase_vertex,
			skinning_pars_vertex: skinning_pars_vertex,
			skinning_vertex: skinning_vertex,
			skinnormal_vertex: skinnormal_vertex,
			specularmap_fragment: specularmap_fragment,
			specularmap_pars_fragment: specularmap_pars_fragment,
			tonemapping_fragment: tonemapping_fragment,
			tonemapping_pars_fragment: tonemapping_pars_fragment,
			uv_pars_fragment: uv_pars_fragment,
			uv_pars_vertex: uv_pars_vertex,
			uv_vertex: uv_vertex,
			uv2_pars_fragment: uv2_pars_fragment,
			uv2_pars_vertex: uv2_pars_vertex,
			uv2_vertex: uv2_vertex,
			worldpos_vertex: worldpos_vertex,
	
			cube_frag: cube_frag,
			cube_vert: cube_vert,
			depth_frag: depth_frag,
			depth_vert: depth_vert,
			distanceRGBA_frag: distanceRGBA_frag,
			distanceRGBA_vert: distanceRGBA_vert,
			equirect_frag: equirect_frag,
			equirect_vert: equirect_vert,
			linedashed_frag: linedashed_frag,
			linedashed_vert: linedashed_vert,
			meshbasic_frag: meshbasic_frag,
			meshbasic_vert: meshbasic_vert,
			meshlambert_frag: meshlambert_frag,
			meshlambert_vert: meshlambert_vert,
			meshphong_frag: meshphong_frag,
			meshphong_vert: meshphong_vert,
			meshphysical_frag: meshphysical_frag,
			meshphysical_vert: meshphysical_vert,
			normal_frag: normal_frag,
			normal_vert: normal_vert,
			points_frag: points_frag,
			points_vert: points_vert,
			shadow_frag: shadow_frag,
			shadow_vert: shadow_vert
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 */
	
		var ShaderLib = {
	
			basic: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.fog
				] ),
	
				vertexShader: ShaderChunk.meshbasic_vert,
				fragmentShader: ShaderChunk.meshbasic_frag
	
			},
	
			lambert: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) }
					}
				] ),
	
				vertexShader: ShaderChunk.meshlambert_vert,
				fragmentShader: ShaderChunk.meshlambert_frag
	
			},
	
			phong: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.gradientmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						specular: { value: new Color( 0x111111 ) },
						shininess: { value: 30 }
					}
				] ),
	
				vertexShader: ShaderChunk.meshphong_vert,
				fragmentShader: ShaderChunk.meshphong_frag
	
			},
	
			standard: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.roughnessmap,
					UniformsLib.metalnessmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0.5 },
						envMapIntensity: { value: 1 } // temporary
					}
				] ),
	
				vertexShader: ShaderChunk.meshphysical_vert,
				fragmentShader: ShaderChunk.meshphysical_frag
	
			},
	
			points: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.points,
					UniformsLib.fog
				] ),
	
				vertexShader: ShaderChunk.points_vert,
				fragmentShader: ShaderChunk.points_frag
	
			},
	
			dashed: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.fog,
					{
						scale: { value: 1 },
						dashSize: { value: 1 },
						totalSize: { value: 2 }
					}
				] ),
	
				vertexShader: ShaderChunk.linedashed_vert,
				fragmentShader: ShaderChunk.linedashed_frag
	
			},
	
			depth: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.displacementmap
				] ),
	
				vertexShader: ShaderChunk.depth_vert,
				fragmentShader: ShaderChunk.depth_frag
	
			},
	
			normal: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					{
						opacity: { value: 1.0 }
					}
				] ),
	
				vertexShader: ShaderChunk.normal_vert,
				fragmentShader: ShaderChunk.normal_frag
	
			},
	
			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */
	
			cube: {
	
				uniforms: {
					tCube: { value: null },
					tFlip: { value: - 1 },
					opacity: { value: 1.0 }
				},
	
				vertexShader: ShaderChunk.cube_vert,
				fragmentShader: ShaderChunk.cube_frag
	
			},
	
			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */
	
			equirect: {
	
				uniforms: {
					tEquirect: { value: null },
					tFlip: { value: - 1 }
				},
	
				vertexShader: ShaderChunk.equirect_vert,
				fragmentShader: ShaderChunk.equirect_frag
	
			},
	
			distanceRGBA: {
	
				uniforms: {
					lightPos: { value: new Vector3() }
				},
	
				vertexShader: ShaderChunk.distanceRGBA_vert,
				fragmentShader: ShaderChunk.distanceRGBA_frag
	
			}
	
		};
	
		ShaderLib.physical = {
	
			uniforms: UniformsUtils.merge( [
				ShaderLib.standard.uniforms,
				{
					clearCoat: { value: 0 },
					clearCoatRoughness: { value: 0 }
				}
			] ),
	
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Box2( min, max ) {
	
			this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );
	
		}
	
		Object.assign( Box2.prototype, {
	
			set: function ( min, max ) {
	
				this.min.copy( min );
				this.max.copy( max );
	
				return this;
	
			},
	
			setFromPoints: function ( points ) {
	
				this.makeEmpty();
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					this.expandByPoint( points[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromCenterAndSize: function () {
	
				var v1 = new Vector2();
	
				return function setFromCenterAndSize( center, size ) {
	
					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( box ) {
	
				this.min.copy( box.min );
				this.max.copy( box.max );
	
				return this;
	
			},
	
			makeEmpty: function () {
	
				this.min.x = this.min.y = + Infinity;
				this.max.x = this.max.y = - Infinity;
	
				return this;
	
			},
	
			isEmpty: function () {
	
				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
			},
	
			getSize: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );
	
			},
	
			expandByPoint: function ( point ) {
	
				this.min.min( point );
				this.max.max( point );
	
				return this;
	
			},
	
			expandByVector: function ( vector ) {
	
				this.min.sub( vector );
				this.max.add( vector );
	
				return this;
	
			},
	
			expandByScalar: function ( scalar ) {
	
				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );
	
				return this;
	
			},
	
			containsPoint: function ( point ) {
	
				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ? false : true;
	
			},
	
			containsBox: function ( box ) {
	
				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y;
	
			},
	
			getParameter: function ( point, optionalTarget ) {
	
				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.
	
				var result = optionalTarget || new Vector2();
	
				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y )
				);
	
			},
	
			intersectsBox: function ( box ) {
	
				// using 4 splitting planes to rule out intersections
	
				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return result.copy( point ).clamp( this.min, this.max );
	
			},
	
			distanceToPoint: function () {
	
				var v1 = new Vector2();
	
				return function distanceToPoint( point ) {
	
					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();
	
				};
	
			}(),
	
			intersect: function ( box ) {
	
				this.min.max( box.min );
				this.max.min( box.max );
	
				return this;
	
			},
	
			union: function ( box ) {
	
				this.min.min( box.min );
				this.max.max( box.max );
	
				return this;
	
			},
	
			translate: function ( offset ) {
	
				this.min.add( offset );
				this.max.add( offset );
	
				return this;
	
			},
	
			equals: function ( box ) {
	
				return box.min.equals( this.min ) && box.max.equals( this.max );
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function LensFlarePlugin( renderer, flares ) {
	
			var gl = renderer.context;
			var state = renderer.state;
	
			var vertexBuffer, elementBuffer;
			var shader, program, attributes, uniforms;
	
			var tempTexture, occlusionTexture;
	
			function init() {
	
				var vertices = new Float32Array( [
					- 1, - 1,  0, 0,
					 1, - 1,  1, 0,
					 1,  1,  1, 1,
					- 1,  1,  0, 1
				] );
	
				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );
	
				// buffers
	
				vertexBuffer     = gl.createBuffer();
				elementBuffer    = gl.createBuffer();
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
				// textures
	
				tempTexture      = gl.createTexture();
				occlusionTexture = gl.createTexture();
	
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"uniform sampler2D occlusionMap;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
				program = createProgram( shader );
	
				attributes = {
					vertex: gl.getAttribLocation ( program, "position" ),
					uv:     gl.getAttribLocation ( program, "uv" )
				};
	
				uniforms = {
					renderType:     gl.getUniformLocation( program, "renderType" ),
					map:            gl.getUniformLocation( program, "map" ),
					occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
					opacity:        gl.getUniformLocation( program, "opacity" ),
					color:          gl.getUniformLocation( program, "color" ),
					scale:          gl.getUniformLocation( program, "scale" ),
					rotation:       gl.getUniformLocation( program, "rotation" ),
					screenPosition: gl.getUniformLocation( program, "screenPosition" )
				};
	
			}
	
			/*
			 * Render lens flares
			 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
			 *         reads these back and calculates occlusion.
			 */
	
			this.render = function ( scene, camera, viewport ) {
	
				if ( flares.length === 0 ) return;
	
				var tempPosition = new Vector3();
	
				var invAspect = viewport.w / viewport.z,
					halfViewportWidth = viewport.z * 0.5,
					halfViewportHeight = viewport.w * 0.5;
	
				var size = 16 / viewport.w,
					scale = new Vector2( size * invAspect, size );
	
				var screenPosition = new Vector3( 1, 1, 0 ),
					screenPositionPixels = new Vector2( 1, 1 );
	
				var validArea = new Box2();
	
				validArea.min.set( viewport.x, viewport.y );
				validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );
	
				if ( program === undefined ) {
	
					init();
	
				}
	
				gl.useProgram( program );
	
				state.initAttributes();
				state.enableAttribute( attributes.vertex );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();
	
				// loop through all lens flares to update their occlusion and positions
				// setup gl and common used attribs/uniforms
	
				gl.uniform1i( uniforms.occlusionMap, 0 );
				gl.uniform1i( uniforms.map, 1 );
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
				state.disable( gl.CULL_FACE );
				state.buffers.depth.setMask( false );
	
				for ( var i = 0, l = flares.length; i < l; i ++ ) {
	
					size = 16 / viewport.w;
					scale.set( size * invAspect, size );
	
					// calc object screen position
	
					var flare = flares[ i ];
	
					tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );
	
					tempPosition.applyMatrix4( camera.matrixWorldInverse );
					tempPosition.applyMatrix4( camera.projectionMatrix );
	
					// setup arrays for gl programs
	
					screenPosition.copy( tempPosition );
	
					// horizontal and vertical coordinate of the lower left corner of the pixels to copy
	
					screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
					screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;
	
					// screen cull
	
					if ( validArea.containsPoint( screenPositionPixels ) === true ) {
	
						// save current RGB to temp texture
	
						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, null );
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
						// render pink quad
	
						gl.uniform1i( uniforms.renderType, 0 );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
						state.disable( gl.BLEND );
						state.enable( gl.DEPTH_TEST );
	
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
						// copy result to occlusionMap
	
						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
						// restore graphics
	
						gl.uniform1i( uniforms.renderType, 1 );
						state.disable( gl.DEPTH_TEST );
	
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
						// update object positions
	
						flare.positionScreen.copy( screenPosition );
	
						if ( flare.customUpdateCallback ) {
	
							flare.customUpdateCallback( flare );
	
						} else {
	
							flare.updateLensFlares();
	
						}
	
						// render flares
	
						gl.uniform1i( uniforms.renderType, 2 );
						state.enable( gl.BLEND );
	
						for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
							var sprite = flare.lensFlares[ j ];
	
							if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
								screenPosition.x = sprite.x;
								screenPosition.y = sprite.y;
								screenPosition.z = sprite.z;
	
								size = sprite.size * sprite.scale / viewport.w;
	
								scale.x = size * invAspect;
								scale.y = size;
	
								gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
								gl.uniform2f( uniforms.scale, scale.x, scale.y );
								gl.uniform1f( uniforms.rotation, sprite.rotation );
	
								gl.uniform1f( uniforms.opacity, sprite.opacity );
								gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
								state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
								renderer.setTexture2D( sprite.texture, 1 );
	
								gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
							}
	
						}
	
					}
	
				}
	
				// restore gl
	
				state.enable( gl.CULL_FACE );
				state.enable( gl.DEPTH_TEST );
				state.buffers.depth.setMask( true );
	
				renderer.resetGLState();
	
			};
	
			function createProgram( shader ) {
	
				var program = gl.createProgram();
	
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
	
				var prefix = "precision " + renderer.getPrecision() + " float;\n";
	
				gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
				gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
				gl.compileShader( fragmentShader );
				gl.compileShader( vertexShader );
	
				gl.attachShader( program, fragmentShader );
				gl.attachShader( program, vertexShader );
	
				gl.linkProgram( program );
	
				return program;
	
			}
	
		}
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function SpritePlugin( renderer, sprites ) {
	
			var gl = renderer.context;
			var state = renderer.state;
	
			var vertexBuffer, elementBuffer;
			var program, attributes, uniforms;
	
			var texture;
	
			// decompose matrixWorld
	
			var spritePosition = new Vector3();
			var spriteRotation = new Quaternion();
			var spriteScale = new Vector3();
	
			function init() {
	
				var vertices = new Float32Array( [
					- 0.5, - 0.5,  0, 0,
					  0.5, - 0.5,  1, 0,
					  0.5,   0.5,  1, 1,
					- 0.5,   0.5,  0, 1
				] );
	
				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );
	
				vertexBuffer  = gl.createBuffer();
				elementBuffer = gl.createBuffer();
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
				program = createProgram();
	
				attributes = {
					position:			gl.getAttribLocation ( program, 'position' ),
					uv:					gl.getAttribLocation ( program, 'uv' )
				};
	
				uniforms = {
					uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
					uvScale:			gl.getUniformLocation( program, 'uvScale' ),
	
					rotation:			gl.getUniformLocation( program, 'rotation' ),
					scale:				gl.getUniformLocation( program, 'scale' ),
	
					color:				gl.getUniformLocation( program, 'color' ),
					map:				gl.getUniformLocation( program, 'map' ),
					opacity:			gl.getUniformLocation( program, 'opacity' ),
	
					modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
					projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),
	
					fogType:			gl.getUniformLocation( program, 'fogType' ),
					fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
					fogNear:			gl.getUniformLocation( program, 'fogNear' ),
					fogFar:				gl.getUniformLocation( program, 'fogFar' ),
					fogColor:			gl.getUniformLocation( program, 'fogColor' ),
	
					alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
				};
	
				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = 8;
				canvas.height = 8;
	
				var context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 0, 8, 8 );
	
				texture = new Texture( canvas );
				texture.needsUpdate = true;
	
			}
	
			this.render = function ( scene, camera ) {
	
				if ( sprites.length === 0 ) return;
	
				// setup gl
	
				if ( program === undefined ) {
	
					init();
	
				}
	
				gl.useProgram( program );
	
				state.initAttributes();
				state.enableAttribute( attributes.position );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();
	
				state.disable( gl.CULL_FACE );
				state.enable( gl.BLEND );
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
				gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				state.activeTexture( gl.TEXTURE0 );
				gl.uniform1i( uniforms.map, 0 );
	
				var oldFogType = 0;
				var sceneFogType = 0;
				var fog = scene.fog;
	
				if ( fog ) {
	
					gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
					if ( fog.isFog ) {
	
						gl.uniform1f( uniforms.fogNear, fog.near );
						gl.uniform1f( uniforms.fogFar, fog.far );
	
						gl.uniform1i( uniforms.fogType, 1 );
						oldFogType = 1;
						sceneFogType = 1;
	
					} else if ( fog.isFogExp2 ) {
	
						gl.uniform1f( uniforms.fogDensity, fog.density );
	
						gl.uniform1i( uniforms.fogType, 2 );
						oldFogType = 2;
						sceneFogType = 2;
	
					}
	
				} else {
	
					gl.uniform1i( uniforms.fogType, 0 );
					oldFogType = 0;
					sceneFogType = 0;
	
				}
	
	
				// update positions and sort
	
				for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
					var sprite = sprites[ i ];
	
					sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
					sprite.z = - sprite.modelViewMatrix.elements[ 14 ];
	
				}
	
				sprites.sort( painterSortStable );
	
				// render all sprites
	
				var scale = [];
	
				for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
					var sprite = sprites[ i ];
					var material = sprite.material;
	
					if ( material.visible === false ) continue;
	
					sprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );
	
					gl.uniform1f( uniforms.alphaTest, material.alphaTest );
					gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );
	
					sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
	
					scale[ 0 ] = spriteScale.x;
					scale[ 1 ] = spriteScale.y;
	
					var fogType = 0;
	
					if ( scene.fog && material.fog ) {
	
						fogType = sceneFogType;
	
					}
	
					if ( oldFogType !== fogType ) {
	
						gl.uniform1i( uniforms.fogType, fogType );
						oldFogType = fogType;
	
					}
	
					if ( material.map !== null ) {
	
						gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
						gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
					} else {
	
						gl.uniform2f( uniforms.uvOffset, 0, 0 );
						gl.uniform2f( uniforms.uvScale, 1, 1 );
	
					}
	
					gl.uniform1f( uniforms.opacity, material.opacity );
					gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
					gl.uniform1f( uniforms.rotation, material.rotation );
					gl.uniform2fv( uniforms.scale, scale );
	
					state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
					state.buffers.depth.setTest( material.depthTest );
					state.buffers.depth.setMask( material.depthWrite );
	
					if ( material.map ) {
	
						renderer.setTexture2D( material.map, 0 );
	
					} else {
	
						renderer.setTexture2D( texture, 0 );
	
					}
	
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
					sprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );
	
				}
	
				// restore gl
	
				state.enable( gl.CULL_FACE );
	
				renderer.resetGLState();
	
			};
	
			function createProgram() {
	
				var program = gl.createProgram();
	
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
	
				gl.shaderSource( vertexShader, [
	
					'precision ' + renderer.getPrecision() + ' float;',
	
					'#define SHADER_NAME ' + 'SpriteMaterial',
	
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform float rotation;',
					'uniform vec2 scale;',
					'uniform vec2 uvOffset;',
					'uniform vec2 uvScale;',
	
					'attribute vec2 position;',
					'attribute vec2 uv;',
	
					'varying vec2 vUV;',
	
					'void main() {',
	
						'vUV = uvOffset + uv * uvScale;',
	
						'vec2 alignedPosition = position * scale;',
	
						'vec2 rotatedPosition;',
						'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
						'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
						'vec4 finalPosition;',
	
						'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
						'finalPosition.xy += rotatedPosition;',
						'finalPosition = projectionMatrix * finalPosition;',
	
						'gl_Position = finalPosition;',
	
					'}'
	
				].join( '\n' ) );
	
				gl.shaderSource( fragmentShader, [
	
					'precision ' + renderer.getPrecision() + ' float;',
	
					'#define SHADER_NAME ' + 'SpriteMaterial',
	
					'uniform vec3 color;',
					'uniform sampler2D map;',
					'uniform float opacity;',
	
					'uniform int fogType;',
					'uniform vec3 fogColor;',
					'uniform float fogDensity;',
					'uniform float fogNear;',
					'uniform float fogFar;',
					'uniform float alphaTest;',
	
					'varying vec2 vUV;',
	
					'void main() {',
	
						'vec4 texture = texture2D( map, vUV );',
	
						'if ( texture.a < alphaTest ) discard;',
	
						'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
						'if ( fogType > 0 ) {',
	
							'float depth = gl_FragCoord.z / gl_FragCoord.w;',
							'float fogFactor = 0.0;',
	
							'if ( fogType == 1 ) {',
	
								'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
							'} else {',
	
								'const float LOG2 = 1.442695;',
								'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
								'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
							'}',
	
							'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
						'}',
	
					'}'
	
				].join( '\n' ) );
	
				gl.compileShader( vertexShader );
				gl.compileShader( fragmentShader );
	
				gl.attachShader( program, vertexShader );
				gl.attachShader( program, fragmentShader );
	
				gl.linkProgram( program );
	
				return program;
	
			}
	
			function painterSortStable( a, b ) {
	
				if ( a.renderOrder !== b.renderOrder ) {
	
					return a.renderOrder - b.renderOrder;
	
				} else if ( a.z !== b.z ) {
	
					return b.z - a.z;
	
				} else {
	
					return b.id - a.id;
	
				}
	
			}
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		var materialId = 0;
	
		function Material() {
	
			Object.defineProperty( this, 'id', { value: materialId ++ } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Material';
	
			this.fog = true;
			this.lights = true;
	
			this.blending = NormalBlending;
			this.side = FrontSide;
			this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
			this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
	
			this.opacity = 1;
			this.transparent = false;
	
			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;
	
			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;
	
			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;
	
			this.colorWrite = true;
	
			this.precision = null; // override the renderer's default precision for this material
	
			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;
	
			this.dithering = false;
	
			this.alphaTest = 0;
			this.premultipliedAlpha = false;
	
			this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
			this.visible = true;
	
			this.needsUpdate = true;
	
		}
	
		Object.assign( Material.prototype, EventDispatcher.prototype, {
	
			isMaterial: true,
	
			onBeforeCompile: function () {},
	
			setValues: function ( values ) {
	
				if ( values === undefined ) return;
	
				for ( var key in values ) {
	
					var newValue = values[ key ];
	
					if ( newValue === undefined ) {
	
						console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
						continue;
	
					}
	
					var currentValue = this[ key ];
	
					if ( currentValue === undefined ) {
	
						console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
						continue;
	
					}
	
					if ( currentValue && currentValue.isColor ) {
	
						currentValue.set( newValue );
	
					} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {
	
						currentValue.copy( newValue );
	
					} else if ( key === 'overdraw' ) {
	
						// ensure overdraw is backwards-compatible with legacy boolean type
						this[ key ] = Number( newValue );
	
					} else {
	
						this[ key ] = newValue;
	
					}
	
				}
	
			},
	
			toJSON: function ( meta ) {
	
				var isRoot = meta === undefined;
	
				if ( isRoot ) {
	
					meta = {
						textures: {},
						images: {}
					};
	
				}
	
				var data = {
					metadata: {
						version: 4.5,
						type: 'Material',
						generator: 'Material.toJSON'
					}
				};
	
				// standard Material serialization
				data.uuid = this.uuid;
				data.type = this.type;
	
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.color && this.color.isColor ) data.color = this.color.getHex();
	
				if ( this.roughness !== undefined ) data.roughness = this.roughness;
				if ( this.metalness !== undefined ) data.metalness = this.metalness;
	
				if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
				if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
				if ( this.shininess !== undefined ) data.shininess = this.shininess;
				if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
				if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;
	
				if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
				if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
				if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
				if ( this.bumpMap && this.bumpMap.isTexture ) {
	
					data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
					data.bumpScale = this.bumpScale;
	
				}
				if ( this.normalMap && this.normalMap.isTexture ) {
	
					data.normalMap = this.normalMap.toJSON( meta ).uuid;
					data.normalScale = this.normalScale.toArray();
	
				}
				if ( this.displacementMap && this.displacementMap.isTexture ) {
	
					data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
					data.displacementScale = this.displacementScale;
					data.displacementBias = this.displacementBias;
	
				}
				if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
				if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
	
				if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
				if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
	
				if ( this.envMap && this.envMap.isTexture ) {
	
					data.envMap = this.envMap.toJSON( meta ).uuid;
					data.reflectivity = this.reflectivity; // Scale behind envMap
	
				}
	
				if ( this.gradientMap && this.gradientMap.isTexture ) {
	
					data.gradientMap = this.gradientMap.toJSON( meta ).uuid;
	
				}
	
				if ( this.size !== undefined ) data.size = this.size;
				if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
	
				if ( this.blending !== NormalBlending ) data.blending = this.blending;
				if ( this.shading !== SmoothShading ) data.shading = this.shading;
				if ( this.side !== FrontSide ) data.side = this.side;
				if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;
	
				if ( this.opacity < 1 ) data.opacity = this.opacity;
				if ( this.transparent === true ) data.transparent = this.transparent;
	
				data.depthFunc = this.depthFunc;
				data.depthTest = this.depthTest;
				data.depthWrite = this.depthWrite;
	
				if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
				if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
				if ( this.wireframe === true ) data.wireframe = this.wireframe;
				if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
				if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
				if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
	
				data.skinning = this.skinning;
				data.morphTargets = this.morphTargets;
	
				data.dithering = this.dithering;
	
				// TODO: Copied from Object3D.toJSON
	
				function extractFromCache( cache ) {
	
					var values = [];
	
					for ( var key in cache ) {
	
						var data = cache[ key ];
						delete data.metadata;
						values.push( data );
	
					}
	
					return values;
	
				}
	
				if ( isRoot ) {
	
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );
	
					if ( textures.length > 0 ) data.textures = textures;
					if ( images.length > 0 ) data.images = images;
	
				}
	
				return data;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.name = source.name;
	
				this.fog = source.fog;
				this.lights = source.lights;
	
				this.blending = source.blending;
				this.side = source.side;
				this.shading = source.shading;
				this.vertexColors = source.vertexColors;
	
				this.opacity = source.opacity;
				this.transparent = source.transparent;
	
				this.blendSrc = source.blendSrc;
				this.blendDst = source.blendDst;
				this.blendEquation = source.blendEquation;
				this.blendSrcAlpha = source.blendSrcAlpha;
				this.blendDstAlpha = source.blendDstAlpha;
				this.blendEquationAlpha = source.blendEquationAlpha;
	
				this.depthFunc = source.depthFunc;
				this.depthTest = source.depthTest;
				this.depthWrite = source.depthWrite;
	
				this.colorWrite = source.colorWrite;
	
				this.precision = source.precision;
	
				this.polygonOffset = source.polygonOffset;
				this.polygonOffsetFactor = source.polygonOffsetFactor;
				this.polygonOffsetUnits = source.polygonOffsetUnits;
	
				this.dithering = source.dithering;
	
				this.alphaTest = source.alphaTest;
	
				this.premultipliedAlpha = source.premultipliedAlpha;
	
				this.overdraw = source.overdraw;
	
				this.visible = source.visible;
				this.clipShadows = source.clipShadows;
				this.clipIntersection = source.clipIntersection;
	
				var srcPlanes = source.clippingPlanes,
					dstPlanes = null;
	
				if ( srcPlanes !== null ) {
	
					var n = srcPlanes.length;
					dstPlanes = new Array( n );
	
					for ( var i = 0; i !== n; ++ i )
						dstPlanes[ i ] = srcPlanes[ i ].clone();
	
				}
	
				this.clippingPlanes = dstPlanes;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  defines: { "label" : "value" },
		 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
		 *
		 *  fragmentShader: <string>,
		 *  vertexShader: <string>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  lights: <bool>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function ShaderMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'ShaderMaterial';
	
			this.defines = {};
			this.uniforms = {};
	
			this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
			this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
			this.linewidth = 1;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes
	
			this.skinning = false; // set to use skinning attribute streams
			this.morphTargets = false; // set to use morph targets
			this.morphNormals = false; // set to use morph normals
	
			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};
	
			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};
	
			this.index0AttributeName = undefined;
	
			if ( parameters !== undefined ) {
	
				if ( parameters.attributes !== undefined ) {
	
					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
	
				}
	
				this.setValues( parameters );
	
			}
	
		}
	
		ShaderMaterial.prototype = Object.create( Material.prototype );
		ShaderMaterial.prototype.constructor = ShaderMaterial;
	
		ShaderMaterial.prototype.isShaderMaterial = true;
	
		ShaderMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
	
			this.uniforms = UniformsUtils.clone( source.uniforms );
	
			this.defines = source.defines;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			this.lights = source.lights;
			this.clipping = source.clipping;
	
			this.skinning = source.skinning;
	
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			this.extensions = source.extensions;
	
			return this;
	
		};
	
		ShaderMaterial.prototype.toJSON = function ( meta ) {
	
			var data = Material.prototype.toJSON.call( this, meta );
	
			data.uniforms = this.uniforms;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
	
			return data;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / https://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */
	
		function MeshDepthMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshDepthMaterial';
	
			this.depthPacking = BasicDepthPacking;
	
			this.skinning = false;
			this.morphTargets = false;
	
			this.map = null;
	
			this.alphaMap = null;
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false;
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		MeshDepthMaterial.prototype = Object.create( Material.prototype );
		MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
	
		MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
	
		MeshDepthMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.depthPacking = source.depthPacking;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
	
			this.map = source.map;
	
			this.alphaMap = source.alphaMap;
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			return this;
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Box3( min, max ) {
	
			this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );
	
		}
	
		Object.assign( Box3.prototype, {
	
			isBox3: true,
	
			set: function ( min, max ) {
	
				this.min.copy( min );
				this.max.copy( max );
	
				return this;
	
			},
	
			setFromArray: function ( array ) {
	
				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;
	
				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;
	
				for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
					var x = array[ i ];
					var y = array[ i + 1 ];
					var z = array[ i + 2 ];
	
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;
	
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;
	
				}
	
				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );
	
				return this;
	
			},
	
			setFromBufferAttribute: function ( attribute ) {
	
				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;
	
				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;
	
				for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
					var x = attribute.getX( i );
					var y = attribute.getY( i );
					var z = attribute.getZ( i );
	
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;
	
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;
	
				}
	
				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );
	
				return this;
	
			},
	
			setFromPoints: function ( points ) {
	
				this.makeEmpty();
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					this.expandByPoint( points[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromCenterAndSize: function () {
	
				var v1 = new Vector3();
	
				return function setFromCenterAndSize( center, size ) {
	
					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );
	
					return this;
	
				};
	
			}(),
	
			setFromObject: function ( object ) {
	
				this.makeEmpty();
	
				return this.expandByObject( object );
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( box ) {
	
				this.min.copy( box.min );
				this.max.copy( box.max );
	
				return this;
	
			},
	
			makeEmpty: function () {
	
				this.min.x = this.min.y = this.min.z = + Infinity;
				this.max.x = this.max.y = this.max.z = - Infinity;
	
				return this;
	
			},
	
			isEmpty: function () {
	
				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
			},
	
			getSize: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );
	
			},
	
			expandByPoint: function ( point ) {
	
				this.min.min( point );
				this.max.max( point );
	
				return this;
	
			},
	
			expandByVector: function ( vector ) {
	
				this.min.sub( vector );
				this.max.add( vector );
	
				return this;
	
			},
	
			expandByScalar: function ( scalar ) {
	
				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );
	
				return this;
	
			},
	
			expandByObject: function () {
	
				// Computes the world-axis-aligned bounding box of an object (including its children),
				// accounting for both the object's, and children's, world transforms
	
				var v1 = new Vector3();
	
				return function expandByObject( object ) {
	
					var scope = this;
	
					object.updateMatrixWorld( true );
	
					object.traverse( function ( node ) {
	
						var i, l;
	
						var geometry = node.geometry;
	
						if ( geometry !== undefined ) {
	
							if ( geometry.isGeometry ) {
	
								var vertices = geometry.vertices;
	
								for ( i = 0, l = vertices.length; i < l; i ++ ) {
	
									v1.copy( vertices[ i ] );
									v1.applyMatrix4( node.matrixWorld );
	
									scope.expandByPoint( v1 );
	
								}
	
							} else if ( geometry.isBufferGeometry ) {
	
								var attribute = geometry.attributes.position;
	
								if ( attribute !== undefined ) {
	
									for ( i = 0, l = attribute.count; i < l; i ++ ) {
	
										v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );
	
										scope.expandByPoint( v1 );
	
									}
	
								}
	
							}
	
						}
	
					} );
	
					return this;
	
				};
	
			}(),
	
			containsPoint: function ( point ) {
	
				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ||
					point.z < this.min.z || point.z > this.max.z ? false : true;
	
			},
	
			containsBox: function ( box ) {
	
				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y &&
					this.min.z <= box.min.z && box.max.z <= this.max.z;
	
			},
	
			getParameter: function ( point, optionalTarget ) {
	
				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.
	
				var result = optionalTarget || new Vector3();
	
				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y ),
					( point.z - this.min.z ) / ( this.max.z - this.min.z )
				);
	
			},
	
			intersectsBox: function ( box ) {
	
				// using 6 splitting planes to rule out intersections.
				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ||
					box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	
			},
	
			intersectsSphere: ( function () {
	
				var closestPoint = new Vector3();
	
				return function intersectsSphere( sphere ) {
	
					// Find the point on the AABB closest to the sphere center.
					this.clampPoint( sphere.center, closestPoint );
	
					// If that point is inside the sphere, the AABB and sphere intersect.
					return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
	
				};
	
			} )(),
	
			intersectsPlane: function ( plane ) {
	
				// We compute the minimum and maximum dot product values. If those values
				// are on the same side (back or front) of the plane, then there is no intersection.
	
				var min, max;
	
				if ( plane.normal.x > 0 ) {
	
					min = plane.normal.x * this.min.x;
					max = plane.normal.x * this.max.x;
	
				} else {
	
					min = plane.normal.x * this.max.x;
					max = plane.normal.x * this.min.x;
	
				}
	
				if ( plane.normal.y > 0 ) {
	
					min += plane.normal.y * this.min.y;
					max += plane.normal.y * this.max.y;
	
				} else {
	
					min += plane.normal.y * this.max.y;
					max += plane.normal.y * this.min.y;
	
				}
	
				if ( plane.normal.z > 0 ) {
	
					min += plane.normal.z * this.min.z;
					max += plane.normal.z * this.max.z;
	
				} else {
	
					min += plane.normal.z * this.max.z;
					max += plane.normal.z * this.min.z;
	
				}
	
				return ( min <= plane.constant && max >= plane.constant );
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.copy( point ).clamp( this.min, this.max );
	
			},
	
			distanceToPoint: function () {
	
				var v1 = new Vector3();
	
				return function distanceToPoint( point ) {
	
					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();
	
				};
	
			}(),
	
			getBoundingSphere: function () {
	
				var v1 = new Vector3();
	
				return function getBoundingSphere( optionalTarget ) {
	
					var result = optionalTarget || new Sphere();
	
					this.getCenter( result.center );
	
					result.radius = this.getSize( v1 ).length() * 0.5;
	
					return result;
	
				};
	
			}(),
	
			intersect: function ( box ) {
	
				this.min.max( box.min );
				this.max.min( box.max );
	
				// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
				if( this.isEmpty() ) this.makeEmpty();
	
				return this;
	
			},
	
			union: function ( box ) {
	
				this.min.min( box.min );
				this.max.max( box.max );
	
				return this;
	
			},
	
			applyMatrix4: function () {
	
				var points = [
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3()
				];
	
				return function applyMatrix4( matrix ) {
	
					// transform of empty box is an empty box.
					if( this.isEmpty() ) return this;
	
					// NOTE: I am using a binary pattern to specify all 2^3 combinations below
					points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
					points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
					points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
					points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
					points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
					points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
					points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
					points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111
	
					this.setFromPoints( points );
	
					return this;
	
				};
	
			}(),
	
			translate: function ( offset ) {
	
				this.min.add( offset );
				this.max.add( offset );
	
				return this;
	
			},
	
			equals: function ( box ) {
	
				return box.min.equals( this.min ) && box.max.equals( this.max );
	
			}
	
		} );
	
		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Sphere( center, radius ) {
	
			this.center = ( center !== undefined ) ? center : new Vector3();
			this.radius = ( radius !== undefined ) ? radius : 0;
	
		}
	
		Object.assign( Sphere.prototype, {
	
			set: function ( center, radius ) {
	
				this.center.copy( center );
				this.radius = radius;
	
				return this;
	
			},
	
			setFromPoints: function () {
	
				var box = new Box3();
	
				return function setFromPoints( points, optionalCenter ) {
	
					var center = this.center;
	
					if ( optionalCenter !== undefined ) {
	
						center.copy( optionalCenter );
	
					} else {
	
						box.setFromPoints( points ).getCenter( center );
	
					}
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = points.length; i < il; i ++ ) {
	
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
					}
	
					this.radius = Math.sqrt( maxRadiusSq );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( sphere ) {
	
				this.center.copy( sphere.center );
				this.radius = sphere.radius;
	
				return this;
	
			},
	
			empty: function () {
	
				return ( this.radius <= 0 );
	
			},
	
			containsPoint: function ( point ) {
	
				return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
			},
	
			distanceToPoint: function ( point ) {
	
				return ( point.distanceTo( this.center ) - this.radius );
	
			},
	
			intersectsSphere: function ( sphere ) {
	
				var radiusSum = this.radius + sphere.radius;
	
				return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
			},
	
			intersectsBox: function ( box ) {
	
				return box.intersectsSphere( this );
	
			},
	
			intersectsPlane: function ( plane ) {
	
				// We use the following equation to compute the signed distance from
				// the center of the sphere to the plane.
				//
				// distance = q * n - d
				//
				// If this distance is greater than the radius of the sphere,
				// then there is no intersection.
	
				return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var deltaLengthSq = this.center.distanceToSquared( point );
	
				var result = optionalTarget || new Vector3();
	
				result.copy( point );
	
				if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
					result.sub( this.center ).normalize();
					result.multiplyScalar( this.radius ).add( this.center );
	
				}
	
				return result;
	
			},
	
			getBoundingBox: function ( optionalTarget ) {
	
				var box = optionalTarget || new Box3();
	
				box.set( this.center, this.center );
				box.expandByScalar( this.radius );
	
				return box;
	
			},
	
			applyMatrix4: function ( matrix ) {
	
				this.center.applyMatrix4( matrix );
				this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
				return this;
	
			},
	
			translate: function ( offset ) {
	
				this.center.add( offset );
	
				return this;
	
			},
	
			equals: function ( sphere ) {
	
				return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 * @author tschw
		 */
	
		function Matrix3() {
	
			this.elements = [
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			];
	
			if ( arguments.length > 0 ) {
	
				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
			}
	
		}
	
		Object.assign( Matrix3.prototype, {
	
			isMatrix3: true,
	
			set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
				var te = this.elements;
	
				te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
				te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
				te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
	
				return this;
	
			},
	
			identity: function () {
	
				this.set(
	
					1, 0, 0,
					0, 1, 0,
					0, 0, 1
	
				);
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().fromArray( this.elements );
	
			},
	
			copy: function ( m ) {
	
				var te = this.elements;
				var me = m.elements;
	
				te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
				te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
				te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];
	
				return this;
	
			},
	
			setFromMatrix4: function ( m ) {
	
				var me = m.elements;
	
				this.set(
	
					me[ 0 ], me[ 4 ], me[  8 ],
					me[ 1 ], me[ 5 ], me[  9 ],
					me[ 2 ], me[ 6 ], me[ 10 ]
	
				);
	
				return this;
	
			},
	
			applyToBufferAttribute: function () {
	
				var v1 = new Vector3();
	
				return function applyToBufferAttribute( attribute ) {
	
					for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
						v1.x = attribute.getX( i );
						v1.y = attribute.getY( i );
						v1.z = attribute.getZ( i );
	
						v1.applyMatrix3( this );
	
						attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
					}
	
					return attribute;
	
				};
	
			}(),
	
			multiply: function ( m ) {
	
				return this.multiplyMatrices( this, m );
	
			},
	
			premultiply: function ( m ) {
	
				return this.multiplyMatrices( m, this );
	
			},
	
			multiplyMatrices: function ( a, b ) {
	
				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;
	
				var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
				var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
				var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];
	
				var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
				var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
				var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];
	
				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
				te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
				te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;
	
				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
				te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
				te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;
	
				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
				te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
				te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;
	
				return this;
	
			},
	
			multiplyScalar: function ( s ) {
	
				var te = this.elements;
	
				te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
				te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
				te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
				return this;
	
			},
	
			determinant: function () {
	
				var te = this.elements;
	
				var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
					d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
					g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
				return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
			},
	
			getInverse: function ( matrix, throwOnDegenerate ) {
	
				if ( matrix && matrix.isMatrix4 ) {
	
					console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );
	
				}
	
				var me = matrix.elements,
					te = this.elements,
	
					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
					n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
					n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
	
					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,
	
					det = n11 * t11 + n21 * t12 + n31 * t13;
	
				if ( det === 0 ) {
	
					var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
					if ( throwOnDegenerate === true ) {
	
						throw new Error( msg );
	
					} else {
	
						console.warn( msg );
	
					}
	
					return this.identity();
	
				}
	
				var detInv = 1 / det;
	
				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
				te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
	
				te[ 3 ] = t12 * detInv;
				te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
				te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
	
				te[ 6 ] = t13 * detInv;
				te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
				te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
	
				return this;
	
			},
	
			transpose: function () {
	
				var tmp, m = this.elements;
	
				tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
				tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
				tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
				return this;
	
			},
	
			getNormalMatrix: function ( matrix4 ) {
	
				return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
	
			},
	
			transposeIntoArray: function ( r ) {
	
				var m = this.elements;
	
				r[ 0 ] = m[ 0 ];
				r[ 1 ] = m[ 3 ];
				r[ 2 ] = m[ 6 ];
				r[ 3 ] = m[ 1 ];
				r[ 4 ] = m[ 4 ];
				r[ 5 ] = m[ 7 ];
				r[ 6 ] = m[ 2 ];
				r[ 7 ] = m[ 5 ];
				r[ 8 ] = m[ 8 ];
	
				return this;
	
			},
	
			equals: function ( matrix ) {
	
				var te = this.elements;
				var me = matrix.elements;
	
				for ( var i = 0; i < 9; i ++ ) {
	
					if ( te[ i ] !== me[ i ] ) return false;
	
				}
	
				return true;
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				for ( var i = 0; i < 9; i ++ ) {
	
					this.elements[ i ] = array[ i + offset ];
	
				}
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				var te = this.elements;
	
				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
	
				array[ offset + 3 ] = te[ 3 ];
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
	
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
				array[ offset + 8 ] = te[ 8 ];
	
				return array;
	
			}
	
		} );
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Plane( normal, constant ) {
	
			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;
	
		}
	
		Object.assign( Plane.prototype, {
	
			set: function ( normal, constant ) {
	
				this.normal.copy( normal );
				this.constant = constant;
	
				return this;
	
			},
	
			setComponents: function ( x, y, z, w ) {
	
				this.normal.set( x, y, z );
				this.constant = w;
	
				return this;
	
			},
	
			setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
				this.normal.copy( normal );
				this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
				return this;
	
			},
	
			setFromCoplanarPoints: function () {
	
				var v1 = new Vector3();
				var v2 = new Vector3();
	
				return function setFromCoplanarPoints( a, b, c ) {
	
					var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
					// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
					this.setFromNormalAndCoplanarPoint( normal, a );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( plane ) {
	
				this.normal.copy( plane.normal );
				this.constant = plane.constant;
	
				return this;
	
			},
	
			normalize: function () {
	
				// Note: will lead to a divide by zero if the plane is invalid.
	
				var inverseNormalLength = 1.0 / this.normal.length();
				this.normal.multiplyScalar( inverseNormalLength );
				this.constant *= inverseNormalLength;
	
				return this;
	
			},
	
			negate: function () {
	
				this.constant *= - 1;
				this.normal.negate();
	
				return this;
	
			},
	
			distanceToPoint: function ( point ) {
	
				return this.normal.dot( point ) + this.constant;
	
			},
	
			distanceToSphere: function ( sphere ) {
	
				return this.distanceToPoint( sphere.center ) - sphere.radius;
	
			},
	
			projectPoint: function ( point, optionalTarget ) {
	
				return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
			},
	
			orthoPoint: function ( point, optionalTarget ) {
	
				var perpendicularMagnitude = this.distanceToPoint( point );
	
				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
			},
	
			intersectLine: function () {
	
				var v1 = new Vector3();
	
				return function intersectLine( line, optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					var direction = line.delta( v1 );
	
					var denominator = this.normal.dot( direction );
	
					if ( denominator === 0 ) {
	
						// line is coplanar, return origin
						if ( this.distanceToPoint( line.start ) === 0 ) {
	
							return result.copy( line.start );
	
						}
	
						// Unsure if this is the correct method to handle this case.
						return undefined;
	
					}
	
					var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
					if ( t < 0 || t > 1 ) {
	
						return undefined;
	
					}
	
					return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
				};
	
			}(),
	
			intersectsLine: function ( line ) {
	
				// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
				var startSign = this.distanceToPoint( line.start );
				var endSign = this.distanceToPoint( line.end );
	
				return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
			},
	
			intersectsBox: function ( box ) {
	
				return box.intersectsPlane( this );
	
			},
	
			intersectsSphere: function ( sphere ) {
	
				return sphere.intersectsPlane( this );
	
			},
	
			coplanarPoint: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( - this.constant );
	
			},
	
			applyMatrix4: function () {
	
				var v1 = new Vector3();
				var m1 = new Matrix3();
	
				return function applyMatrix4( matrix, optionalNormalMatrix ) {
	
					var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );
	
					// transform normal based on theory here:
					// http://www.songho.ca/opengl/gl_normaltransform.html
					var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
					var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
	
					// recalculate constant (like in setFromNormalAndCoplanarPoint)
					this.constant = - referencePoint.dot( normal );
	
					return this;
	
				};
	
			}(),
	
			translate: function ( offset ) {
	
				this.constant = this.constant - offset.dot( this.normal );
	
				return this;
	
			},
	
			equals: function ( plane ) {
	
				return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / http://clara.io
		 */
	
		function Frustum( p0, p1, p2, p3, p4, p5 ) {
	
			this.planes = [
	
				( p0 !== undefined ) ? p0 : new Plane(),
				( p1 !== undefined ) ? p1 : new Plane(),
				( p2 !== undefined ) ? p2 : new Plane(),
				( p3 !== undefined ) ? p3 : new Plane(),
				( p4 !== undefined ) ? p4 : new Plane(),
				( p5 !== undefined ) ? p5 : new Plane()
	
			];
	
		}
	
		Object.assign( Frustum.prototype, {
	
			set: function ( p0, p1, p2, p3, p4, p5 ) {
	
				var planes = this.planes;
	
				planes[ 0 ].copy( p0 );
				planes[ 1 ].copy( p1 );
				planes[ 2 ].copy( p2 );
				planes[ 3 ].copy( p3 );
				planes[ 4 ].copy( p4 );
				planes[ 5 ].copy( p5 );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( frustum ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					planes[ i ].copy( frustum.planes[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromMatrix: function ( m ) {
	
				var planes = this.planes;
				var me = m.elements;
				var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
				var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
				var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
				var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
				planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
				planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
				planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
				planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
				planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
				return this;
	
			},
	
			intersectsObject: function () {
	
				var sphere = new Sphere();
	
				return function intersectsObject( object ) {
	
					var geometry = object.geometry;
	
					if ( geometry.boundingSphere === null )
						geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere )
						.applyMatrix4( object.matrixWorld );
	
					return this.intersectsSphere( sphere );
	
				};
	
			}(),
	
			intersectsSprite: function () {
	
				var sphere = new Sphere();
	
				return function intersectsSprite( sprite ) {
	
					sphere.center.set( 0, 0, 0 );
					sphere.radius = 0.7071067811865476;
					sphere.applyMatrix4( sprite.matrixWorld );
	
					return this.intersectsSphere( sphere );
	
				};
	
			}(),
	
			intersectsSphere: function ( sphere ) {
	
				var planes = this.planes;
				var center = sphere.center;
				var negRadius = - sphere.radius;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					var distance = planes[ i ].distanceToPoint( center );
	
					if ( distance < negRadius ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			},
	
			intersectsBox: function () {
	
				var p1 = new Vector3(),
					p2 = new Vector3();
	
				return function intersectsBox( box ) {
	
					var planes = this.planes;
	
					for ( var i = 0; i < 6; i ++ ) {
	
						var plane = planes[ i ];
	
						p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
						p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
						p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
						p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
						p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
						p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
						var d1 = plane.distanceToPoint( p1 );
						var d2 = plane.distanceToPoint( p2 );
	
						// if both outside plane, no intersection
	
						if ( d1 < 0 && d2 < 0 ) {
	
							return false;
	
						}
	
					}
	
					return true;
	
				};
	
			}(),
	
			containsPoint: function ( point ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {
	
			var _gl = _renderer.context,
				_state = _renderer.state,
				_frustum = new Frustum(),
				_projScreenMatrix = new Matrix4(),
	
				_lightShadows = _lights.shadows,
	
				_shadowMapSize = new Vector2(),
				_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),
	
				_lookTarget = new Vector3(),
				_lightPositionWorld = new Vector3(),
	
				_MorphingFlag = 1,
				_SkinningFlag = 2,
	
				_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
	
				_depthMaterials = new Array( _NumberOfMaterialVariants ),
				_distanceMaterials = new Array( _NumberOfMaterialVariants ),
	
				_materialCache = {};
	
			var cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];
	
			var cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];
	
			var cube2DViewPorts = [
				new Vector4(), new Vector4(), new Vector4(),
				new Vector4(), new Vector4(), new Vector4()
			];
	
			// init
	
			var depthMaterialTemplate = new MeshDepthMaterial();
			depthMaterialTemplate.depthPacking = RGBADepthPacking;
			depthMaterialTemplate.clipping = true;
	
			var distanceShader = ShaderLib[ "distanceRGBA" ];
			var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );
	
			for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
	
				var useMorphing = ( i & _MorphingFlag ) !== 0;
				var useSkinning = ( i & _SkinningFlag ) !== 0;
	
				var depthMaterial = depthMaterialTemplate.clone();
				depthMaterial.morphTargets = useMorphing;
				depthMaterial.skinning = useSkinning;
	
				_depthMaterials[ i ] = depthMaterial;
	
				var distanceMaterial = new ShaderMaterial( {
					defines: {
						'USE_SHADOWMAP': ''
					},
					uniforms: distanceUniforms,
					vertexShader: distanceShader.vertexShader,
					fragmentShader: distanceShader.fragmentShader,
					morphTargets: useMorphing,
					skinning: useSkinning,
					clipping: true
				} );
	
				_distanceMaterials[ i ] = distanceMaterial;
	
			}
	
			//
	
			var scope = this;
	
			this.enabled = false;
	
			this.autoUpdate = true;
			this.needsUpdate = false;
	
			this.type = PCFShadowMap;
	
			this.renderReverseSided = true;
			this.renderSingleSided = true;
	
			this.render = function ( scene, camera ) {
	
				if ( scope.enabled === false ) return;
				if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
	
				if ( _lightShadows.length === 0 ) return;
	
				// Set GL state for depth map.
				_state.disable( _gl.BLEND );
				_state.buffers.color.setClear( 1, 1, 1, 1 );
				_state.buffers.depth.setTest( true );
				_state.setScissorTest( false );
	
				// render depth map
	
				var faceCount;
	
				for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {
	
					var light = _lightShadows[ i ];
					var shadow = light.shadow;
					var isPointLight = light && light.isPointLight;
	
					if ( shadow === undefined ) {
	
						console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
						continue;
	
					}
	
					var shadowCamera = shadow.camera;
	
					_shadowMapSize.copy( shadow.mapSize );
					_shadowMapSize.min( _maxShadowMapSize );
	
					if ( isPointLight ) {
	
						var vpWidth = _shadowMapSize.x;
						var vpHeight = _shadowMapSize.y;
	
						// These viewports map a cube-map onto a 2D texture with the
						// following orientation:
						//
						//  xzXZ
						//   y Y
						//
						// X - Positive x direction
						// x - Negative x direction
						// Y - Positive y direction
						// y - Negative y direction
						// Z - Positive z direction
						// z - Negative z direction
	
						// positive X
						cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
						// negative X
						cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
						// positive Z
						cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
						// negative Z
						cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
						// positive Y
						cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
						// negative Y
						cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
	
						_shadowMapSize.x *= 4.0;
						_shadowMapSize.y *= 2.0;
	
					}
	
					if ( shadow.map === null ) {
	
						var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
	
						shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
						shadow.map.texture.name = light.name + ".shadowMap";
	
						shadowCamera.updateProjectionMatrix();
	
					}
	
					if ( shadow.isSpotLightShadow ) {
	
						shadow.update( light );
	
					}
	
					var shadowMap = shadow.map;
					var shadowMatrix = shadow.matrix;
	
					_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
					shadowCamera.position.copy( _lightPositionWorld );
	
					if ( isPointLight ) {
	
						faceCount = 6;
	
						// for point lights we set the shadow matrix to be a translation-only matrix
						// equal to inverse of the light's position
	
						shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );
	
					} else {
	
						faceCount = 1;
	
						_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
						shadowCamera.lookAt( _lookTarget );
						shadowCamera.updateMatrixWorld();
	
						// compute shadow matrix
	
						shadowMatrix.set(
							0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0
						);
	
						shadowMatrix.multiply( shadowCamera.projectionMatrix );
						shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
					}
	
					_renderer.setRenderTarget( shadowMap );
					_renderer.clear();
	
					// render shadow map for each cube face (if omni-directional) or
					// run a single pass if not
	
					for ( var face = 0; face < faceCount; face ++ ) {
	
						if ( isPointLight ) {
	
							_lookTarget.copy( shadowCamera.position );
							_lookTarget.add( cubeDirections[ face ] );
							shadowCamera.up.copy( cubeUps[ face ] );
							shadowCamera.lookAt( _lookTarget );
							shadowCamera.updateMatrixWorld();
	
							var vpDimensions = cube2DViewPorts[ face ];
							_state.viewport( vpDimensions );
	
						}
	
						// update camera matrices and frustum
	
						_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
						_frustum.setFromMatrix( _projScreenMatrix );
	
						// set object matrices & frustum culling
	
						renderObject( scene, camera, shadowCamera, isPointLight );
	
					}
	
				}
	
				// Restore GL state.
				var clearColor = _renderer.getClearColor();
				var clearAlpha = _renderer.getClearAlpha();
				_renderer.setClearColor( clearColor, clearAlpha );
	
				scope.needsUpdate = false;
	
			};
	
			function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {
	
				var geometry = object.geometry;
	
				var result = null;
	
				var materialVariants = _depthMaterials;
				var customMaterial = object.customDepthMaterial;
	
				if ( isPointLight ) {
	
					materialVariants = _distanceMaterials;
					customMaterial = object.customDistanceMaterial;
	
				}
	
				if ( ! customMaterial ) {
	
					var useMorphing = false;
	
					if ( material.morphTargets ) {
	
						if ( geometry && geometry.isBufferGeometry ) {
	
							useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
	
						} else if ( geometry && geometry.isGeometry ) {
	
							useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
	
						}
	
					}
	
					if ( object.isSkinnedMesh && material.skinning === false ) {
	
						console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );
	
					}
	
					var useSkinning = object.isSkinnedMesh && material.skinning;
	
					var variantIndex = 0;
	
					if ( useMorphing ) variantIndex |= _MorphingFlag;
					if ( useSkinning ) variantIndex |= _SkinningFlag;
	
					result = materialVariants[ variantIndex ];
	
				} else {
	
					result = customMaterial;
	
				}
	
				if ( _renderer.localClippingEnabled &&
						material.clipShadows === true &&
						material.clippingPlanes.length !== 0 ) {
	
					// in this case we need a unique material instance reflecting the
					// appropriate state
	
					var keyA = result.uuid, keyB = material.uuid;
	
					var materialsForVariant = _materialCache[ keyA ];
	
					if ( materialsForVariant === undefined ) {
	
						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;
	
					}
	
					var cachedMaterial = materialsForVariant[ keyB ];
	
					if ( cachedMaterial === undefined ) {
	
						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;
	
					}
	
					result = cachedMaterial;
	
				}
	
				result.visible = material.visible;
				result.wireframe = material.wireframe;
	
				var side = material.side;
	
				if ( scope.renderSingleSided && side == DoubleSide ) {
	
					side = FrontSide;
	
				}
	
				if ( scope.renderReverseSided ) {
	
					if ( side === FrontSide ) side = BackSide;
					else if ( side === BackSide ) side = FrontSide;
	
				}
	
				result.side = side;
	
				result.clipShadows = material.clipShadows;
				result.clippingPlanes = material.clippingPlanes;
	
				result.wireframeLinewidth = material.wireframeLinewidth;
				result.linewidth = material.linewidth;
	
				if ( isPointLight && result.uniforms.lightPos !== undefined ) {
	
					result.uniforms.lightPos.value.copy( lightPositionWorld );
	
				}
	
				return result;
	
			}
	
			function renderObject( object, camera, shadowCamera, isPointLight ) {
	
				if ( object.visible === false ) return;
	
				var visible = object.layers.test( camera.layers );
	
				if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {
	
					if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {
	
						object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
	
						var geometry = _objects.update( object );
						var material = object.material;
	
						if ( Array.isArray( material ) ) {
	
							var groups = geometry.groups;
	
							for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
	
								var group = groups[ k ];
								var groupMaterial = material[ group.materialIndex ];
	
								if ( groupMaterial && groupMaterial.visible ) {
	
									var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
									_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
	
								}
	
							}
	
						} else if ( material.visible ) {
	
							var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
	
						}
	
					}
	
				}
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					renderObject( children[ i ], camera, shadowCamera, isPointLight );
	
				}
	
			}
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLAttributes( gl ) {
	
			var buffers = {};
	
			function createBuffer( attribute, bufferType ) {
	
				var array = attribute.array;
				var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	
				var buffer = gl.createBuffer();
	
				gl.bindBuffer( bufferType, buffer );
				gl.bufferData( bufferType, array, usage );
	
				attribute.onUploadCallback();
	
				var type = gl.FLOAT;
	
				if ( array instanceof Float32Array ) {
	
					type = gl.FLOAT;
	
				} else if ( array instanceof Float64Array ) {
	
					console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );
	
				} else if ( array instanceof Uint16Array ) {
	
					type = gl.UNSIGNED_SHORT;
	
				} else if ( array instanceof Int16Array ) {
	
					type = gl.SHORT;
	
				} else if ( array instanceof Uint32Array ) {
	
					type = gl.UNSIGNED_INT;
	
				} else if ( array instanceof Int32Array ) {
	
					type = gl.INT;
	
				} else if ( array instanceof Int8Array ) {
	
					type = gl.BYTE;
	
				} else if ( array instanceof Uint8Array ) {
	
					type = gl.UNSIGNED_BYTE;
	
				}
	
				return {
					buffer: buffer,
					type: type,
					bytesPerElement: array.BYTES_PER_ELEMENT,
					version: attribute.version
				};
	
			}
	
			function updateBuffer( buffer, attribute, bufferType ) {
	
				var array = attribute.array;
				var updateRange = attribute.updateRange;
	
				gl.bindBuffer( bufferType, buffer );
	
				if ( attribute.dynamic === false ) {
	
					gl.bufferData( bufferType, array, gl.STATIC_DRAW );
	
				} else if ( updateRange.count === - 1 ) {
	
					// Not using update ranges
	
					gl.bufferSubData( bufferType, 0, array );
	
				} else if ( updateRange.count === 0 ) {
	
					console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
	
				} else {
	
					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );
	
					updateRange.count = -1; // reset range
	
				}
	
			}
	
			//
	
			function get( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
	
				return buffers[ attribute.uuid ];
	
			}
	
			function remove( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
				
				var data = buffers[ attribute.uuid ];
	
				if ( data ) {
	
					gl.deleteBuffer( data.buffer );
	
					delete buffers[ attribute.uuid ];
	
				}
	
			}
	
			function update( attribute, bufferType ) {
	
				if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
	
				var data = buffers[ attribute.uuid ];
	
				if ( data === undefined ) {
	
					buffers[ attribute.uuid ] = createBuffer( attribute, bufferType );
	
				} else if ( data.version < attribute.version ) {
	
					updateBuffer( data.buffer, attribute, bufferType );
	
					data.version = attribute.version;
	
				}
	
			}
	
			return {
	
				get: get,
				remove: remove,
				update: update
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */
	
		function Euler( x, y, z, order ) {
	
			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;
	
		}
	
		Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
		Euler.DefaultOrder = 'XYZ';
	
		Object.defineProperties( Euler.prototype, {
	
			x: {
	
				get: function () {
	
					return this._x;
	
				},
	
				set: function ( value ) {
	
					this._x = value;
					this.onChangeCallback();
	
				}
	
			},
	
			y: {
	
				get: function () {
	
					return this._y;
	
				},
	
				set: function ( value ) {
	
					this._y = value;
					this.onChangeCallback();
	
				}
	
			},
	
			z: {
	
				get: function () {
	
					return this._z;
	
				},
	
				set: function ( value ) {
	
					this._z = value;
					this.onChangeCallback();
	
				}
	
			},
	
			order: {
	
				get: function () {
	
					return this._order;
	
				},
	
				set: function ( value ) {
	
					this._order = value;
					this.onChangeCallback();
	
				}
	
			}
	
		} );
	
		Object.assign( Euler.prototype, {
	
			isEuler: true,
	
			set: function ( x, y, z, order ) {
	
				this._x = x;
				this._y = y;
				this._z = z;
				this._order = order || this._order;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this._x, this._y, this._z, this._order );
	
			},
	
			copy: function ( euler ) {
	
				this._x = euler._x;
				this._y = euler._y;
				this._z = euler._z;
				this._order = euler._order;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromRotationMatrix: function ( m, order, update ) {
	
				var clamp = _Math.clamp;
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var te = m.elements;
				var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
				var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
				var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
				order = order || this._order;
	
				if ( order === 'XYZ' ) {
	
					this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
					if ( Math.abs( m13 ) < 0.99999 ) {
	
						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );
	
					} else {
	
						this._x = Math.atan2( m32, m22 );
						this._z = 0;
	
					}
	
				} else if ( order === 'YXZ' ) {
	
					this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
					if ( Math.abs( m23 ) < 0.99999 ) {
	
						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );
	
					} else {
	
						this._y = Math.atan2( - m31, m11 );
						this._z = 0;
	
					}
	
				} else if ( order === 'ZXY' ) {
	
					this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
					if ( Math.abs( m32 ) < 0.99999 ) {
	
						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );
	
					} else {
	
						this._y = 0;
						this._z = Math.atan2( m21, m11 );
	
					}
	
				} else if ( order === 'ZYX' ) {
	
					this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
					if ( Math.abs( m31 ) < 0.99999 ) {
	
						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );
	
					} else {
	
						this._x = 0;
						this._z = Math.atan2( - m12, m22 );
	
					}
	
				} else if ( order === 'YZX' ) {
	
					this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
					if ( Math.abs( m21 ) < 0.99999 ) {
	
						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );
	
					} else {
	
						this._x = 0;
						this._y = Math.atan2( m13, m33 );
	
					}
	
				} else if ( order === 'XZY' ) {
	
					this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
					if ( Math.abs( m12 ) < 0.99999 ) {
	
						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );
	
					} else {
	
						this._x = Math.atan2( - m23, m33 );
						this._y = 0;
	
					}
	
				} else {
	
					console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
	
				}
	
				this._order = order;
	
				if ( update !== false ) this.onChangeCallback();
	
				return this;
	
			},
	
			setFromQuaternion: function () {
	
				var matrix = new Matrix4();
	
				return function setFromQuaternion( q, order, update ) {
	
					matrix.makeRotationFromQuaternion( q );
	
					return this.setFromRotationMatrix( matrix, order, update );
	
				};
	
			}(),
	
			setFromVector3: function ( v, order ) {
	
				return this.set( v.x, v.y, v.z, order || this._order );
	
			},
	
			reorder: function () {
	
				// WARNING: this discards revolution information -bhouston
	
				var q = new Quaternion();
	
				return function reorder( newOrder ) {
	
					q.setFromEuler( this );
	
					return this.setFromQuaternion( q, newOrder );
	
				};
	
			}(),
	
			equals: function ( euler ) {
	
				return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
			},
	
			fromArray: function ( array ) {
	
				this._x = array[ 0 ];
				this._y = array[ 1 ];
				this._z = array[ 2 ];
				if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._order;
	
				return array;
	
			},
	
			toVector3: function ( optionalResult ) {
	
				if ( optionalResult ) {
	
					return optionalResult.set( this._x, this._y, this._z );
	
				} else {
	
					return new Vector3( this._x, this._y, this._z );
	
				}
	
			},
	
			onChange: function ( callback ) {
	
				this.onChangeCallback = callback;
	
				return this;
	
			},
	
			onChangeCallback: function () {}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Layers() {
	
			this.mask = 1 | 0;
	
		}
	
		Object.assign( Layers.prototype, {
	
			set: function ( channel ) {
	
				this.mask = 1 << channel | 0;
	
			},
	
			enable: function ( channel ) {
	
				this.mask |= 1 << channel | 0;
	
			},
	
			toggle: function ( channel ) {
	
				this.mask ^= 1 << channel | 0;
	
			},
	
			disable: function ( channel ) {
	
				this.mask &= ~ ( 1 << channel | 0 );
	
			},
	
			test: function ( layers ) {
	
				return ( this.mask & layers.mask ) !== 0;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author elephantatwork / www.elephantatwork.ch
		 */
	
		var object3DId = 0;
	
		function Object3D() {
	
			Object.defineProperty( this, 'id', { value: object3DId ++ } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Object3D';
	
			this.parent = null;
			this.children = [];
	
			this.up = Object3D.DefaultUp.clone();
	
			var position = new Vector3();
			var rotation = new Euler();
			var quaternion = new Quaternion();
			var scale = new Vector3( 1, 1, 1 );
	
			function onRotationChange() {
	
				quaternion.setFromEuler( rotation, false );
	
			}
	
			function onQuaternionChange() {
	
				rotation.setFromQuaternion( quaternion, undefined, false );
	
			}
	
			rotation.onChange( onRotationChange );
			quaternion.onChange( onQuaternionChange );
	
			Object.defineProperties( this, {
				position: {
					enumerable: true,
					value: position
				},
				rotation: {
					enumerable: true,
					value: rotation
				},
				quaternion: {
					enumerable: true,
					value: quaternion
				},
				scale: {
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );
	
			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();
	
			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;
	
			this.layers = new Layers();
			this.visible = true;
	
			this.castShadow = false;
			this.receiveShadow = false;
	
			this.frustumCulled = true;
			this.renderOrder = 0;
	
			this.userData = {};
		}
	
		Object3D.DefaultUp = new Vector3( 0, 1, 0 );
		Object3D.DefaultMatrixAutoUpdate = true;
	
		Object.assign( Object3D.prototype, EventDispatcher.prototype, {
	
			isObject3D: true,
	
			onBeforeRender: function () {},
			onAfterRender: function () {},
	
			applyMatrix: function ( matrix ) {
	
				this.matrix.multiplyMatrices( matrix, this.matrix );
	
				this.matrix.decompose( this.position, this.quaternion, this.scale );
	
			},
	
			applyQuaternion: function ( q ) {
	
				this.quaternion.premultiply( q );
	
				return this;
	
			},
	
			setRotationFromAxisAngle: function ( axis, angle ) {
	
				// assumes axis is normalized
	
				this.quaternion.setFromAxisAngle( axis, angle );
	
			},
	
			setRotationFromEuler: function ( euler ) {
	
				this.quaternion.setFromEuler( euler, true );
	
			},
	
			setRotationFromMatrix: function ( m ) {
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				this.quaternion.setFromRotationMatrix( m );
	
			},
	
			setRotationFromQuaternion: function ( q ) {
	
				// assumes q is normalized
	
				this.quaternion.copy( q );
	
			},
	
			rotateOnAxis: function () {
	
				// rotate object on axis in object space
				// axis is assumed to be normalized
	
				var q1 = new Quaternion();
	
				return function rotateOnAxis( axis, angle ) {
	
					q1.setFromAxisAngle( axis, angle );
	
					this.quaternion.multiply( q1 );
	
					return this;
	
				};
	
			}(),
	
			rotateX: function () {
	
				var v1 = new Vector3( 1, 0, 0 );
	
				return function rotateX( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			rotateY: function () {
	
				var v1 = new Vector3( 0, 1, 0 );
	
				return function rotateY( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			rotateZ: function () {
	
				var v1 = new Vector3( 0, 0, 1 );
	
				return function rotateZ( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			translateOnAxis: function () {
	
				// translate object by distance along axis in object space
				// axis is assumed to be normalized
	
				var v1 = new Vector3();
	
				return function translateOnAxis( axis, distance ) {
	
					v1.copy( axis ).applyQuaternion( this.quaternion );
	
					this.position.add( v1.multiplyScalar( distance ) );
	
					return this;
	
				};
	
			}(),
	
			translateX: function () {
	
				var v1 = new Vector3( 1, 0, 0 );
	
				return function translateX( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			translateY: function () {
	
				var v1 = new Vector3( 0, 1, 0 );
	
				return function translateY( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			translateZ: function () {
	
				var v1 = new Vector3( 0, 0, 1 );
	
				return function translateZ( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			localToWorld: function ( vector ) {
	
				return vector.applyMatrix4( this.matrixWorld );
	
			},
	
			worldToLocal: function () {
	
				var m1 = new Matrix4();
	
				return function worldToLocal( vector ) {
	
					return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
				};
	
			}(),
	
			lookAt: function () {
	
				// This method does not support objects with rotated and/or translated parent(s)
	
				var m1 = new Matrix4();
	
				return function lookAt( vector ) {
	
					if ( this.isCamera ) {
	
						m1.lookAt( this.position, vector, this.up );
	
					} else {
	
						m1.lookAt( vector, this.position, this.up );
	
					}
	
					this.quaternion.setFromRotationMatrix( m1 );
	
				};
	
			}(),
	
			add: function ( object ) {
	
				if ( arguments.length > 1 ) {
	
					for ( var i = 0; i < arguments.length; i ++ ) {
	
						this.add( arguments[ i ] );
	
					}
	
					return this;
	
				}
	
				if ( object === this ) {
	
					console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
					return this;
	
				}
	
				if ( ( object && object.isObject3D ) ) {
	
					if ( object.parent !== null ) {
	
						object.parent.remove( object );
	
					}
	
					object.parent = this;
					object.dispatchEvent( { type: 'added' } );
	
					this.children.push( object );
	
				} else {
	
					console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
				}
	
				return this;
	
			},
	
			remove: function ( object ) {
	
				if ( arguments.length > 1 ) {
	
					for ( var i = 0; i < arguments.length; i ++ ) {
	
						this.remove( arguments[ i ] );
	
					}
	
					return this;
	
				}
	
				var index = this.children.indexOf( object );
	
				if ( index !== - 1 ) {
	
					object.parent = null;
	
					object.dispatchEvent( { type: 'removed' } );
	
					this.children.splice( index, 1 );
	
				}
	
				return this;
				
			},
	
			getObjectById: function ( id ) {
	
				return this.getObjectByProperty( 'id', id );
	
			},
	
			getObjectByName: function ( name ) {
	
				return this.getObjectByProperty( 'name', name );
	
			},
	
			getObjectByProperty: function ( name, value ) {
	
				if ( this[ name ] === value ) return this;
	
				for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
					var child = this.children[ i ];
					var object = child.getObjectByProperty( name, value );
	
					if ( object !== undefined ) {
	
						return object;
	
					}
	
				}
	
				return undefined;
	
			},
	
			getWorldPosition: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				this.updateMatrixWorld( true );
	
				return result.setFromMatrixPosition( this.matrixWorld );
	
			},
	
			getWorldQuaternion: function () {
	
				var position = new Vector3();
				var scale = new Vector3();
	
				return function getWorldQuaternion( optionalTarget ) {
	
					var result = optionalTarget || new Quaternion();
	
					this.updateMatrixWorld( true );
	
					this.matrixWorld.decompose( position, result, scale );
	
					return result;
	
				};
	
			}(),
	
			getWorldRotation: function () {
	
				var quaternion = new Quaternion();
	
				return function getWorldRotation( optionalTarget ) {
	
					var result = optionalTarget || new Euler();
	
					this.getWorldQuaternion( quaternion );
	
					return result.setFromQuaternion( quaternion, this.rotation.order, false );
	
				};
	
			}(),
	
			getWorldScale: function () {
	
				var position = new Vector3();
				var quaternion = new Quaternion();
	
				return function getWorldScale( optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					this.updateMatrixWorld( true );
	
					this.matrixWorld.decompose( position, quaternion, result );
	
					return result;
	
				};
	
			}(),
	
			getWorldDirection: function () {
	
				var quaternion = new Quaternion();
	
				return function getWorldDirection( optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					this.getWorldQuaternion( quaternion );
	
					return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
				};
	
			}(),
	
			raycast: function () {},
	
			traverse: function ( callback ) {
	
				callback( this );
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].traverse( callback );
	
				}
	
			},
	
			traverseVisible: function ( callback ) {
	
				if ( this.visible === false ) return;
	
				callback( this );
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].traverseVisible( callback );
	
				}
	
			},
	
			traverseAncestors: function ( callback ) {
	
				var parent = this.parent;
	
				if ( parent !== null ) {
	
					callback( parent );
	
					parent.traverseAncestors( callback );
	
				}
	
			},
	
			updateMatrix: function () {
	
				this.matrix.compose( this.position, this.quaternion, this.scale );
	
				this.matrixWorldNeedsUpdate = true;
	
			},
	
			updateMatrixWorld: function ( force ) {
	
				if ( this.matrixAutoUpdate ) this.updateMatrix();
	
				if ( this.matrixWorldNeedsUpdate || force ) {
	
					if ( this.parent === null ) {
	
						this.matrixWorld.copy( this.matrix );
	
					} else {
	
						this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
					}
	
					this.matrixWorldNeedsUpdate = false;
	
					force = true;
	
				}
	
				// update children
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].updateMatrixWorld( force );
	
				}
	
			},
	
			toJSON: function ( meta ) {
	
				// meta is '' when called from JSON.stringify
				var isRootObject = ( meta === undefined || meta === '' );
	
				var output = {};
	
				// meta is a hash used to collect geometries, materials.
				// not providing it implies that this is the root object
				// being serialized.
				if ( isRootObject ) {
	
					// initialize meta obj
					meta = {
						geometries: {},
						materials: {},
						textures: {},
						images: {}
					};
	
					output.metadata = {
						version: 4.5,
						type: 'Object',
						generator: 'Object3D.toJSON'
					};
	
				}
	
				// standard Object3D serialization
	
				var object = {};
	
				object.uuid = this.uuid;
				object.type = this.type;
	
				if ( this.name !== '' ) object.name = this.name;
				if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
				if ( this.castShadow === true ) object.castShadow = true;
				if ( this.receiveShadow === true ) object.receiveShadow = true;
				if ( this.visible === false ) object.visible = false;
	
				object.matrix = this.matrix.toArray();
	
				//
	
				function serialize( library, element ) {
	
					if ( library[ element.uuid ] === undefined ) {
	
						library[ element.uuid ] = element.toJSON( meta );
	
					}
	
					return element.uuid;
	
				}
	
				if ( this.geometry !== undefined ) {
	
					object.geometry = serialize( meta.geometries, this.geometry );
	
				}
	
				if ( this.material !== undefined ) {
	
					if ( Array.isArray( this.material ) ) {
	
						var uuids = [];
	
						for ( var i = 0, l = this.material.length; i < l; i ++ ) {
	
							uuids.push( serialize( meta.materials, this.material[ i ] ) );
	
						}
	
						object.material = uuids;
	
					} else {
	
						object.material = serialize( meta.materials, this.material );
	
					}
	
				}
	
				//
	
				if ( this.children.length > 0 ) {
	
					object.children = [];
	
					for ( var i = 0; i < this.children.length; i ++ ) {
	
						object.children.push( this.children[ i ].toJSON( meta ).object );
	
					}
	
				}
	
				if ( isRootObject ) {
	
					var geometries = extractFromCache( meta.geometries );
					var materials = extractFromCache( meta.materials );
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );
	
					if ( geometries.length > 0 ) output.geometries = geometries;
					if ( materials.length > 0 ) output.materials = materials;
					if ( textures.length > 0 ) output.textures = textures;
					if ( images.length > 0 ) output.images = images;
	
				}
	
				output.object = object;
	
				return output;
	
				// extract data from the cache hash
				// remove metadata on each item
				// and return as array
				function extractFromCache( cache ) {
	
					var values = [];
					for ( var key in cache ) {
	
						var data = cache[ key ];
						delete data.metadata;
						values.push( data );
	
					}
					return values;
	
				}
	
			},
	
			clone: function ( recursive ) {
	
				return new this.constructor().copy( this, recursive );
	
			},
	
			copy: function ( source, recursive ) {
	
				if ( recursive === undefined ) recursive = true;
	
				this.name = source.name;
	
				this.up.copy( source.up );
	
				this.position.copy( source.position );
				this.quaternion.copy( source.quaternion );
				this.scale.copy( source.scale );
	
				this.matrix.copy( source.matrix );
				this.matrixWorld.copy( source.matrixWorld );
	
				this.matrixAutoUpdate = source.matrixAutoUpdate;
				this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	
				this.layers.mask = source.layers.mask;
				this.visible = source.visible;
	
				this.castShadow = source.castShadow;
				this.receiveShadow = source.receiveShadow;
	
				this.frustumCulled = source.frustumCulled;
				this.renderOrder = source.renderOrder;
	
				this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
				if ( recursive === true ) {
	
					for ( var i = 0; i < source.children.length; i ++ ) {
	
						var child = source.children[ i ];
						this.add( child.clone() );
	
					}
	
				}
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function Camera() {
	
			Object3D.call( this );
	
			this.type = 'Camera';
	
			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();
	
		}
	
		Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Camera,
	
			isCamera: true,
	
			copy: function ( source, recursive ) {
	
				Object3D.prototype.copy.call( this, source, recursive );
	
				this.matrixWorldInverse.copy( source.matrixWorldInverse );
				this.projectionMatrix.copy( source.projectionMatrix );
	
				return this;
	
			},
	
			getWorldDirection: function () {
	
				var quaternion = new Quaternion();
	
				return function getWorldDirection( optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					this.getWorldQuaternion( quaternion );
	
					return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
				};
	
			}(),
	
			updateMatrixWorld: function ( force ) {
	
				Object3D.prototype.updateMatrixWorld.call( this, force );
	
				this.matrixWorldInverse.getInverse( this.matrixWorld );
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author arose / http://github.com/arose
		 */
	
		function OrthographicCamera( left, right, top, bottom, near, far ) {
	
			Camera.call( this );
	
			this.type = 'OrthographicCamera';
	
			this.zoom = 1;
			this.view = null;
	
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
	
			this.near = ( near !== undefined ) ? near : 0.1;
			this.far = ( far !== undefined ) ? far : 2000;
	
			this.updateProjectionMatrix();
	
		}
	
		OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
			constructor: OrthographicCamera,
	
			isOrthographicCamera: true,
	
			copy: function ( source, recursive ) {
	
				Camera.prototype.copy.call( this, source, recursive );
	
				this.left = source.left;
				this.right = source.right;
				this.top = source.top;
				this.bottom = source.bottom;
				this.near = source.near;
				this.far = source.far;
	
				this.zoom = source.zoom;
				this.view = source.view === null ? null : Object.assign( {}, source.view );
	
				return this;
	
			},
	
			setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {
	
				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};
	
				this.updateProjectionMatrix();
	
			},
	
			clearViewOffset: function() {
	
				this.view = null;
				this.updateProjectionMatrix();
	
			},
	
			updateProjectionMatrix: function () {
	
				var dx = ( this.right - this.left ) / ( 2 * this.zoom );
				var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
				var cx = ( this.right + this.left ) / 2;
				var cy = ( this.top + this.bottom ) / 2;
	
				var left = cx - dx;
				var right = cx + dx;
				var top = cy + dy;
				var bottom = cy - dy;
	
				if ( this.view !== null ) {
	
					var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
					var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
					var scaleW = ( this.right - this.left ) / this.view.width;
					var scaleH = ( this.top - this.bottom ) / this.view.height;
	
					left += scaleW * ( this.view.offsetX / zoomW );
					right = left + scaleW * ( this.view.width / zoomW );
					top -= scaleH * ( this.view.offsetY / zoomH );
					bottom = top - scaleH * ( this.view.height / zoomH );
	
				}
	
				this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.zoom = this.zoom;
				data.object.left = this.left;
				data.object.right = this.right;
				data.object.top = this.top;
				data.object.bottom = this.bottom;
				data.object.near = this.near;
				data.object.far = this.far;
	
				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author greggman / http://games.greggman.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author tschw
		 */
	
		function PerspectiveCamera( fov, aspect, near, far ) {
	
			Camera.call( this );
	
			this.type = 'PerspectiveCamera';
	
			this.fov = fov !== undefined ? fov : 50;
			this.zoom = 1;
	
			this.near = near !== undefined ? near : 0.1;
			this.far = far !== undefined ? far : 2000;
			this.focus = 10;
	
			this.aspect = aspect !== undefined ? aspect : 1;
			this.view = null;
	
			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)
	
			this.updateProjectionMatrix();
	
		}
	
		PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
			constructor: PerspectiveCamera,
	
			isPerspectiveCamera: true,
	
			copy: function ( source, recursive ) {
	
				Camera.prototype.copy.call( this, source, recursive );
	
				this.fov = source.fov;
				this.zoom = source.zoom;
	
				this.near = source.near;
				this.far = source.far;
				this.focus = source.focus;
	
				this.aspect = source.aspect;
				this.view = source.view === null ? null : Object.assign( {}, source.view );
	
				this.filmGauge = source.filmGauge;
				this.filmOffset = source.filmOffset;
	
				return this;
	
			},
	
			/**
			 * Sets the FOV by focal length in respect to the current .filmGauge.
			 *
			 * The default film gauge is 35, so that the focal length can be specified for
			 * a 35mm (full frame) camera.
			 *
			 * Values for focal length and film gauge must have the same unit.
			 */
			setFocalLength: function ( focalLength ) {
	
				// see http://www.bobatkins.com/photography/technical/field_of_view.html
				var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
	
				this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
				this.updateProjectionMatrix();
	
			},
	
			/**
			 * Calculates the focal length from the current .fov and .filmGauge.
			 */
			getFocalLength: function () {
	
				var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );
	
				return 0.5 * this.getFilmHeight() / vExtentSlope;
	
			},
	
			getEffectiveFOV: function () {
	
				return _Math.RAD2DEG * 2 * Math.atan(
						Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );
	
			},
	
			getFilmWidth: function () {
	
				// film not completely covered in portrait format (aspect < 1)
				return this.filmGauge * Math.min( this.aspect, 1 );
	
			},
	
			getFilmHeight: function () {
	
				// film not completely covered in landscape format (aspect > 1)
				return this.filmGauge / Math.max( this.aspect, 1 );
	
			},
	
			/**
			 * Sets an offset in a larger frustum. This is useful for multi-window or
			 * multi-monitor/multi-machine setups.
			 *
			 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
			 * the monitors are in grid like this
			 *
			 *   +---+---+---+
			 *   | A | B | C |
			 *   +---+---+---+
			 *   | D | E | F |
			 *   +---+---+---+
			 *
			 * then for each monitor you would call it like this
			 *
			 *   var w = 1920;
			 *   var h = 1080;
			 *   var fullWidth = w * 3;
			 *   var fullHeight = h * 2;
			 *
			 *   --A--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
			 *   --B--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
			 *   --C--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
			 *   --D--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
			 *   --E--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
			 *   --F--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
			 *
			 *   Note there is no reason monitors have to be the same size or in a grid.
			 */
			setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
	
				this.aspect = fullWidth / fullHeight;
	
				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};
	
				this.updateProjectionMatrix();
	
			},
	
			clearViewOffset: function () {
	
				this.view = null;
				this.updateProjectionMatrix();
	
			},
	
			updateProjectionMatrix: function () {
	
				var near = this.near,
					top = near * Math.tan(
							_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
					height = 2 * top,
					width = this.aspect * height,
					left = - 0.5 * width,
					view = this.view;
	
				if ( view !== null ) {
	
					var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;
	
					left += view.offsetX * width / fullWidth;
					top -= view.offsetY * height / fullHeight;
					width *= view.width / fullWidth;
					height *= view.height / fullHeight;
	
				}
	
				var skew = this.filmOffset;
				if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
	
				this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.fov = this.fov;
				data.object.zoom = this.zoom;
	
				data.object.near = this.near;
				data.object.far = this.far;
				data.object.focus = this.focus;
	
				data.object.aspect = this.aspect;
	
				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
				data.object.filmGauge = this.filmGauge;
				data.object.filmOffset = this.filmOffset;
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Face3( a, b, c, normal, color, materialIndex ) {
	
			this.a = a;
			this.b = b;
			this.c = c;
	
			this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
			this.vertexNormals = Array.isArray( normal ) ? normal : [];
	
			this.color = ( color && color.isColor ) ? color : new Color();
			this.vertexColors = Array.isArray( color ) ? color : [];
	
			this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
		}
	
		Object.assign( Face3.prototype, {
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.a = source.a;
				this.b = source.b;
				this.c = source.c;
	
				this.normal.copy( source.normal );
				this.color.copy( source.color );
	
				this.materialIndex = source.materialIndex;
	
				for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
	
					this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
	
				}
	
				for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
	
					this.vertexColors[ i ] = source.vertexColors[ i ].clone();
	
				}
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author bhouston / http://clara.io
		 */
	
		var count = 0;
		function GeometryIdCount() { return count++; }
	
		function Geometry() {
	
			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Geometry';
	
			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
	
			this.morphTargets = [];
			this.morphNormals = [];
	
			this.skinWeights = [];
			this.skinIndices = [];
	
			this.lineDistances = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// update flags
	
			this.elementsNeedUpdate = false;
			this.verticesNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.lineDistancesNeedUpdate = false;
			this.groupsNeedUpdate = false;
	
		}
	
		Object.assign( Geometry.prototype, EventDispatcher.prototype, {
	
			isGeometry: true,
	
			applyMatrix: function ( matrix ) {
	
				var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
				for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
					var vertex = this.vertices[ i ];
					vertex.applyMatrix4( matrix );
	
				}
	
				for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
					var face = this.faces[ i ];
					face.normal.applyMatrix3( normalMatrix ).normalize();
	
					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
						face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
					}
	
				}
	
				if ( this.boundingBox !== null ) {
	
					this.computeBoundingBox();
	
				}
	
				if ( this.boundingSphere !== null ) {
	
					this.computeBoundingSphere();
	
				}
	
				this.verticesNeedUpdate = true;
				this.normalsNeedUpdate = true;
	
				return this;
	
			},
	
			rotateX: function () {
	
				// rotate geometry around world x-axis
	
				var m1 = new Matrix4();
	
				return function rotateX( angle ) {
	
					m1.makeRotationX( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateY: function () {
	
				// rotate geometry around world y-axis
	
				var m1 = new Matrix4();
	
				return function rotateY( angle ) {
	
					m1.makeRotationY( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateZ: function () {
	
				// rotate geometry around world z-axis
	
				var m1 = new Matrix4();
	
				return function rotateZ( angle ) {
	
					m1.makeRotationZ( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			translate: function () {
	
				// translate geometry
	
				var m1 = new Matrix4();
	
				return function translate( x, y, z ) {
	
					m1.makeTranslation( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			scale: function () {
	
				// scale geometry
	
				var m1 = new Matrix4();
	
				return function scale( x, y, z ) {
	
					m1.makeScale( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			lookAt: function () {
	
				var obj = new Object3D();
	
				return function lookAt( vector ) {
	
					obj.lookAt( vector );
	
					obj.updateMatrix();
	
					this.applyMatrix( obj.matrix );
	
				};
	
			}(),
	
			fromBufferGeometry: function ( geometry ) {
	
				var scope = this;
	
				var indices = geometry.index !== null ? geometry.index.array : undefined;
				var attributes = geometry.attributes;
	
				var positions = attributes.position.array;
				var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
				var colors = attributes.color !== undefined ? attributes.color.array : undefined;
				var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
				var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	
				if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
	
				var tempNormals = [];
				var tempUVs = [];
				var tempUVs2 = [];
	
				for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {
	
					scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );
	
					if ( normals !== undefined ) {
	
						tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
	
					}
	
					if ( colors !== undefined ) {
	
						scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
	
					}
	
					if ( uvs !== undefined ) {
	
						tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );
	
					}
	
					if ( uvs2 !== undefined ) {
	
						tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
	
					}
	
				}
	
				function addFace( a, b, c, materialIndex ) {
	
					var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
					var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
	
					var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );
	
					scope.faces.push( face );
	
					if ( uvs !== undefined ) {
	
						scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
	
					}
	
					if ( uvs2 !== undefined ) {
	
						scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
	
					}
	
				}
	
				var groups = geometry.groups;
	
				if ( groups.length > 0 ) {
	
					for ( var i = 0; i < groups.length; i ++ ) {
	
						var group = groups[ i ];
	
						var start = group.start;
						var count = group.count;
	
						for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
							if ( indices !== undefined ) {
	
								addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );
	
							} else {
	
								addFace( j, j + 1, j + 2, group.materialIndex );
	
							}
	
						}
	
					}
	
				} else {
	
					if ( indices !== undefined ) {
	
						for ( var i = 0; i < indices.length; i += 3 ) {
	
							addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
						}
	
					} else {
	
						for ( var i = 0; i < positions.length / 3; i += 3 ) {
	
							addFace( i, i + 1, i + 2 );
	
						}
	
					}
	
				}
	
				this.computeFaceNormals();
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				return this;
	
			},
	
			center: function () {
	
				this.computeBoundingBox();
	
				var offset = this.boundingBox.getCenter().negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return offset;
	
			},
	
			normalize: function () {
	
				this.computeBoundingSphere();
	
				var center = this.boundingSphere.center;
				var radius = this.boundingSphere.radius;
	
				var s = radius === 0 ? 1 : 1.0 / radius;
	
				var matrix = new Matrix4();
				matrix.set(
					s, 0, 0, - s * center.x,
					0, s, 0, - s * center.y,
					0, 0, s, - s * center.z,
					0, 0, 0, 1
				);
	
				this.applyMatrix( matrix );
	
				return this;
	
			},
	
			computeFaceNormals: function () {
	
				var cb = new Vector3(), ab = new Vector3();
	
				for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					var face = this.faces[ f ];
	
					var vA = this.vertices[ face.a ];
					var vB = this.vertices[ face.b ];
					var vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					cb.normalize();
	
					face.normal.copy( cb );
	
				}
	
			},
	
			computeVertexNormals: function ( areaWeighted ) {
	
				if ( areaWeighted === undefined ) areaWeighted = true;
	
				var v, vl, f, fl, face, vertices;
	
				vertices = new Array( this.vertices.length );
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ] = new Vector3();
	
				}
	
				if ( areaWeighted ) {
	
					// vertex normals weighted by triangle areas
					// http://www.iquilezles.org/www/articles/normals/normals.htm
	
					var vA, vB, vC;
					var cb = new Vector3(), ab = new Vector3();
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];
	
						cb.subVectors( vC, vB );
						ab.subVectors( vA, vB );
						cb.cross( ab );
	
						vertices[ face.a ].add( cb );
						vertices[ face.b ].add( cb );
						vertices[ face.c ].add( cb );
	
					}
	
				} else {
	
					this.computeFaceNormals();
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );
	
					}
	
				}
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ].normalize();
	
				}
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						vertexNormals[ 0 ].copy( vertices[ face.a ] );
						vertexNormals[ 1 ].copy( vertices[ face.b ] );
						vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
					} else {
	
						vertexNormals[ 0 ] = vertices[ face.a ].clone();
						vertexNormals[ 1 ] = vertices[ face.b ].clone();
						vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
					}
	
				}
	
				if ( this.faces.length > 0 ) {
	
					this.normalsNeedUpdate = true;
	
				}
	
			},
	
			computeFlatVertexNormals: function () {
	
				var f, fl, face;
	
				this.computeFaceNormals();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						vertexNormals[ 0 ].copy( face.normal );
						vertexNormals[ 1 ].copy( face.normal );
						vertexNormals[ 2 ].copy( face.normal );
	
					} else {
	
						vertexNormals[ 0 ] = face.normal.clone();
						vertexNormals[ 1 ] = face.normal.clone();
						vertexNormals[ 2 ] = face.normal.clone();
	
					}
	
				}
	
				if ( this.faces.length > 0 ) {
	
					this.normalsNeedUpdate = true;
	
				}
	
			},
	
			computeMorphNormals: function () {
	
				var i, il, f, fl, face;
	
				// save original normals
				// - create temp variables on first access
				//   otherwise just copy (for faster repeated calls)
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					if ( ! face.__originalFaceNormal ) {
	
						face.__originalFaceNormal = face.normal.clone();
	
					} else {
	
						face.__originalFaceNormal.copy( face.normal );
	
					}
	
					if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
					for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
						if ( ! face.__originalVertexNormals[ i ] ) {
	
							face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
						} else {
	
							face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
						}
	
					}
	
				}
	
				// use temp geometry to compute face and vertex normals for each morph
	
				var tmpGeo = new Geometry();
				tmpGeo.faces = this.faces;
	
				for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
					// create on first access
	
					if ( ! this.morphNormals[ i ] ) {
	
						this.morphNormals[ i ] = {};
						this.morphNormals[ i ].faceNormals = [];
						this.morphNormals[ i ].vertexNormals = [];
	
						var dstNormalsFace = this.morphNormals[ i ].faceNormals;
						var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
						var faceNormal, vertexNormals;
	
						for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
							faceNormal = new Vector3();
							vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
	
							dstNormalsFace.push( faceNormal );
							dstNormalsVertex.push( vertexNormals );
	
						}
	
					}
	
					var morphNormals = this.morphNormals[ i ];
	
					// set vertices to morph target
	
					tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
					// compute morph normals
	
					tmpGeo.computeFaceNormals();
					tmpGeo.computeVertexNormals();
	
					// store morph normals
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						faceNormal = morphNormals.faceNormals[ f ];
						vertexNormals = morphNormals.vertexNormals[ f ];
	
						faceNormal.copy( face.normal );
	
						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
					}
	
				}
	
				// restore original normals
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					face.normal = face.__originalFaceNormal;
					face.vertexNormals = face.__originalVertexNormals;
	
				}
	
			},
	
			computeLineDistances: function () {
	
				var d = 0;
				var vertices = this.vertices;
	
				for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
					if ( i > 0 ) {
	
						d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
					}
	
					this.lineDistances[ i ] = d;
	
				}
	
			},
	
			computeBoundingBox: function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new Box3();
	
				}
	
				this.boundingBox.setFromPoints( this.vertices );
	
			},
	
			computeBoundingSphere: function () {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new Sphere();
	
				}
	
				this.boundingSphere.setFromPoints( this.vertices );
	
			},
	
			merge: function ( geometry, matrix, materialIndexOffset ) {
	
				if ( ! ( geometry && geometry.isGeometry ) ) {
	
					console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
					return;
	
				}
	
				var normalMatrix,
					vertexOffset = this.vertices.length,
					vertices1 = this.vertices,
					vertices2 = geometry.vertices,
					faces1 = this.faces,
					faces2 = geometry.faces,
					uvs1 = this.faceVertexUvs[ 0 ],
					uvs2 = geometry.faceVertexUvs[ 0 ],
					colors1 = this.colors,
					colors2 = geometry.colors;
	
				if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
				if ( matrix !== undefined ) {
	
					normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
				}
	
				// vertices
	
				for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
					var vertex = vertices2[ i ];
	
					var vertexCopy = vertex.clone();
	
					if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
					vertices1.push( vertexCopy );
	
				}
	
				// colors
	
				for ( var i = 0, il = colors2.length; i < il; i ++ ) {
	
					colors1.push( colors2[ i ].clone() );
	
				}
	
				// faces
	
				for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
					var face = faces2[ i ], faceCopy, normal, color,
						faceVertexNormals = face.vertexNormals,
						faceVertexColors = face.vertexColors;
	
					faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
					faceCopy.normal.copy( face.normal );
	
					if ( normalMatrix !== undefined ) {
	
						faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
						normal = faceVertexNormals[ j ].clone();
	
						if ( normalMatrix !== undefined ) {
	
							normal.applyMatrix3( normalMatrix ).normalize();
	
						}
	
						faceCopy.vertexNormals.push( normal );
	
					}
	
					faceCopy.color.copy( face.color );
	
					for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
						color = faceVertexColors[ j ];
						faceCopy.vertexColors.push( color.clone() );
	
					}
	
					faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
					faces1.push( faceCopy );
	
				}
	
				// uvs
	
				for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
					var uv = uvs2[ i ], uvCopy = [];
	
					if ( uv === undefined ) {
	
						continue;
	
					}
	
					for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
						uvCopy.push( uv[ j ].clone() );
	
					}
	
					uvs1.push( uvCopy );
	
				}
	
			},
	
			mergeMesh: function ( mesh ) {
	
				if ( ! ( mesh && mesh.isMesh ) ) {
	
					console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
					return;
	
				}
	
				mesh.matrixAutoUpdate && mesh.updateMatrix();
	
				this.merge( mesh.geometry, mesh.matrix );
	
			},
	
			/*
			 * Checks for duplicate vertices with hashmap.
			 * Duplicated vertices are removed
			 * and faces' vertices are updated.
			 */
	
			mergeVertices: function () {
	
				var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
				var unique = [], changes = [];
	
				var v, key;
				var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
				var precision = Math.pow( 10, precisionPoints );
				var i, il, face;
				var indices, j, jl;
	
				for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
					v = this.vertices[ i ];
					key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
					if ( verticesMap[ key ] === undefined ) {
	
						verticesMap[ key ] = i;
						unique.push( this.vertices[ i ] );
						changes[ i ] = unique.length - 1;
	
					} else {
	
						//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
						changes[ i ] = changes[ verticesMap[ key ] ];
	
					}
	
				}
	
	
				// if faces are completely degenerate after merging vertices, we
				// have to remove them from the geometry.
				var faceIndicesToRemove = [];
	
				for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
					face = this.faces[ i ];
	
					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];
	
					indices = [ face.a, face.b, face.c ];
	
					// if any duplicate vertices are found in a Face3
					// we have to remove the face as nothing can be saved
					for ( var n = 0; n < 3; n ++ ) {
	
						if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
	
							faceIndicesToRemove.push( i );
							break;
	
						}
	
					}
	
				}
	
				for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
					var idx = faceIndicesToRemove[ i ];
	
					this.faces.splice( idx, 1 );
	
					for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
						this.faceVertexUvs[ j ].splice( idx, 1 );
	
					}
	
				}
	
				// Use unique set of vertices
	
				var diff = this.vertices.length - unique.length;
				this.vertices = unique;
				return diff;
	
			},
	
			sortFacesByMaterialIndex: function () {
	
				var faces = this.faces;
				var length = faces.length;
	
				// tag faces
	
				for ( var i = 0; i < length; i ++ ) {
	
					faces[ i ]._id = i;
	
				}
	
				// sort faces
	
				function materialIndexSort( a, b ) {
	
					return a.materialIndex - b.materialIndex;
	
				}
	
				faces.sort( materialIndexSort );
	
				// sort uvs
	
				var uvs1 = this.faceVertexUvs[ 0 ];
				var uvs2 = this.faceVertexUvs[ 1 ];
	
				var newUvs1, newUvs2;
	
				if ( uvs1 && uvs1.length === length ) newUvs1 = [];
				if ( uvs2 && uvs2.length === length ) newUvs2 = [];
	
				for ( var i = 0; i < length; i ++ ) {
	
					var id = faces[ i ]._id;
	
					if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
					if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
	
				}
	
				if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
				if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	
			},
	
			toJSON: function () {
	
				var data = {
					metadata: {
						version: 4.5,
						type: 'Geometry',
						generator: 'Geometry.toJSON'
					}
				};
	
				// standard Geometry serialization
	
				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.parameters !== undefined ) {
	
					var parameters = this.parameters;
	
					for ( var key in parameters ) {
	
						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
					}
	
					return data;
	
				}
	
				var vertices = [];
	
				for ( var i = 0; i < this.vertices.length; i ++ ) {
	
					var vertex = this.vertices[ i ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
				var faces = [];
				var normals = [];
				var normalsHash = {};
				var colors = [];
				var colorsHash = {};
				var uvs = [];
				var uvsHash = {};
	
				for ( var i = 0; i < this.faces.length; i ++ ) {
	
					var face = this.faces[ i ];
	
					var hasMaterial = true;
					var hasFaceUv = false; // deprecated
					var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
					var hasFaceNormal = face.normal.length() > 0;
					var hasFaceVertexNormal = face.vertexNormals.length > 0;
					var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
					var hasFaceVertexColor = face.vertexColors.length > 0;
	
					var faceType = 0;
	
					faceType = setBit( faceType, 0, 0 ); // isQuad
					faceType = setBit( faceType, 1, hasMaterial );
					faceType = setBit( faceType, 2, hasFaceUv );
					faceType = setBit( faceType, 3, hasFaceVertexUv );
					faceType = setBit( faceType, 4, hasFaceNormal );
					faceType = setBit( faceType, 5, hasFaceVertexNormal );
					faceType = setBit( faceType, 6, hasFaceColor );
					faceType = setBit( faceType, 7, hasFaceVertexColor );
	
					faces.push( faceType );
					faces.push( face.a, face.b, face.c );
					faces.push( face.materialIndex );
	
					if ( hasFaceVertexUv ) {
	
						var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
						faces.push(
							getUvIndex( faceVertexUvs[ 0 ] ),
							getUvIndex( faceVertexUvs[ 1 ] ),
							getUvIndex( faceVertexUvs[ 2 ] )
						);
	
					}
	
					if ( hasFaceNormal ) {
	
						faces.push( getNormalIndex( face.normal ) );
	
					}
	
					if ( hasFaceVertexNormal ) {
	
						var vertexNormals = face.vertexNormals;
	
						faces.push(
							getNormalIndex( vertexNormals[ 0 ] ),
							getNormalIndex( vertexNormals[ 1 ] ),
							getNormalIndex( vertexNormals[ 2 ] )
						);
	
					}
	
					if ( hasFaceColor ) {
	
						faces.push( getColorIndex( face.color ) );
	
					}
	
					if ( hasFaceVertexColor ) {
	
						var vertexColors = face.vertexColors;
	
						faces.push(
							getColorIndex( vertexColors[ 0 ] ),
							getColorIndex( vertexColors[ 1 ] ),
							getColorIndex( vertexColors[ 2 ] )
						);
	
					}
	
				}
	
				function setBit( value, position, enabled ) {
	
					return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
	
				}
	
				function getNormalIndex( normal ) {
	
					var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
					if ( normalsHash[ hash ] !== undefined ) {
	
						return normalsHash[ hash ];
	
					}
	
					normalsHash[ hash ] = normals.length / 3;
					normals.push( normal.x, normal.y, normal.z );
	
					return normalsHash[ hash ];
	
				}
	
				function getColorIndex( color ) {
	
					var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
					if ( colorsHash[ hash ] !== undefined ) {
	
						return colorsHash[ hash ];
	
					}
	
					colorsHash[ hash ] = colors.length;
					colors.push( color.getHex() );
	
					return colorsHash[ hash ];
	
				}
	
				function getUvIndex( uv ) {
	
					var hash = uv.x.toString() + uv.y.toString();
	
					if ( uvsHash[ hash ] !== undefined ) {
	
						return uvsHash[ hash ];
	
					}
	
					uvsHash[ hash ] = uvs.length / 2;
					uvs.push( uv.x, uv.y );
	
					return uvsHash[ hash ];
	
				}
	
				data.data = {};
	
				data.data.vertices = vertices;
				data.data.normals = normals;
				if ( colors.length > 0 ) data.data.colors = colors;
				if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
				data.data.faces = faces;
	
				return data;
	
			},
	
			clone: function () {
	
				/*
				 // Handle primitives
	
				 var parameters = this.parameters;
	
				 if ( parameters !== undefined ) {
	
				 var values = [];
	
				 for ( var key in parameters ) {
	
				 values.push( parameters[ key ] );
	
				 }
	
				 var geometry = Object.create( this.constructor.prototype );
				 this.constructor.apply( geometry, values );
				 return geometry;
	
				 }
	
				 return new this.constructor().copy( this );
				 */
	
				return new Geometry().copy( this );
	
			},
	
			copy: function ( source ) {
	
				var i, il, j, jl, k, kl;
	
				// reset
	
				this.vertices = [];
				this.colors = [];
				this.faces = [];
				this.faceVertexUvs = [[]];
				this.morphTargets = [];
				this.morphNormals = [];
				this.skinWeights = [];
				this.skinIndices = [];
				this.lineDistances = [];
				this.boundingBox = null;
				this.boundingSphere = null;
	
				// name
	
				this.name = source.name;
	
				// vertices
	
				var vertices = source.vertices;
	
				for ( i = 0, il = vertices.length; i < il; i ++ ) {
	
					this.vertices.push( vertices[ i ].clone() );
	
				}
	
				// colors
	
				var colors = source.colors;
	
				for ( i = 0, il = colors.length; i < il; i ++ ) {
	
					this.colors.push( colors[ i ].clone() );
	
				}
	
				// faces
	
				var faces = source.faces;
	
				for ( i = 0, il = faces.length; i < il; i ++ ) {
	
					this.faces.push( faces[ i ].clone() );
	
				}
	
				// face vertex uvs
	
				for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
	
					var faceVertexUvs = source.faceVertexUvs[ i ];
	
					if ( this.faceVertexUvs[ i ] === undefined ) {
	
						this.faceVertexUvs[ i ] = [];
	
					}
	
					for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
						var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
						for ( k = 0, kl = uvs.length; k < kl; k ++ ) {
	
							var uv = uvs[ k ];
	
							uvsCopy.push( uv.clone() );
	
						}
	
						this.faceVertexUvs[ i ].push( uvsCopy );
	
					}
	
				}
	
				// morph targets
	
				var morphTargets = source.morphTargets;
	
				for ( i = 0, il = morphTargets.length; i < il; i ++ ) {
	
					var morphTarget = {};
					morphTarget.name = morphTargets[ i ].name;
	
					// vertices
	
					if ( morphTargets[ i ].vertices !== undefined ) {
	
						morphTarget.vertices = [];
	
						for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {
	
							morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );
	
						}
	
					}
	
					// normals
	
					if ( morphTargets[ i ].normals !== undefined ) {
	
						morphTarget.normals = [];
	
						for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {
	
							morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );
	
						}
	
					}
	
					this.morphTargets.push( morphTarget );
	
				}
	
				// morph normals
	
				var morphNormals = source.morphNormals;
	
				for ( i = 0, il = morphNormals.length; i < il; i ++ ) {
	
					var morphNormal = {};
	
					// vertex normals
	
					if ( morphNormals[ i ].vertexNormals !== undefined ) {
	
						morphNormal.vertexNormals = [];
	
						for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {
	
							var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
							var destVertexNormal = {};
	
							destVertexNormal.a = srcVertexNormal.a.clone();
							destVertexNormal.b = srcVertexNormal.b.clone();
							destVertexNormal.c = srcVertexNormal.c.clone();
	
							morphNormal.vertexNormals.push( destVertexNormal );
	
						}
	
					}
	
					// face normals
	
					if ( morphNormals[ i ].faceNormals !== undefined ) {
	
						morphNormal.faceNormals = [];
	
						for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {
	
							morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );
	
						}
	
					}
	
					this.morphNormals.push( morphNormal );
	
				}
	
				// skin weights
	
				var skinWeights = source.skinWeights;
	
				for ( i = 0, il = skinWeights.length; i < il; i ++ ) {
	
					this.skinWeights.push( skinWeights[ i ].clone() );
	
				}
	
				// skin indices
	
				var skinIndices = source.skinIndices;
	
				for ( i = 0, il = skinIndices.length; i < il; i ++ ) {
	
					this.skinIndices.push( skinIndices[ i ].clone() );
	
				}
	
				// line distances
	
				var lineDistances = source.lineDistances;
	
				for ( i = 0, il = lineDistances.length; i < il; i ++ ) {
	
					this.lineDistances.push( lineDistances[ i ] );
	
				}
	
				// bounding box
	
				var boundingBox = source.boundingBox;
	
				if ( boundingBox !== null ) {
	
					this.boundingBox = boundingBox.clone();
	
				}
	
				// bounding sphere
	
				var boundingSphere = source.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					this.boundingSphere = boundingSphere.clone();
	
				}
	
				// update flags
	
				this.elementsNeedUpdate = source.elementsNeedUpdate;
				this.verticesNeedUpdate = source.verticesNeedUpdate;
				this.uvsNeedUpdate = source.uvsNeedUpdate;
				this.normalsNeedUpdate = source.normalsNeedUpdate;
				this.colorsNeedUpdate = source.colorsNeedUpdate;
				this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
				this.groupsNeedUpdate = source.groupsNeedUpdate;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferAttribute( array, itemSize, normalized ) {
	
			if ( Array.isArray( array ) ) {
	
				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
			}
	
			this.uuid = _Math.generateUUID();
			this.name = '';
	
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;
	
			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };
	
			this.onUploadCallback = function () {};
	
			this.version = 0;
	
		}
	
		Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {
	
			set: function ( value ) {
	
				if ( value === true ) this.version ++;
	
			}
	
		} );
	
		Object.assign( BufferAttribute.prototype, {
	
			isBufferAttribute: true,
	
			setArray: function ( array ) {
	
				if ( Array.isArray( array ) ) {
	
					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
				}
	
				this.count = array !== undefined ? array.length / this.itemSize : 0;
				this.array = array;
	
			},
	
			setDynamic: function ( value ) {
	
				this.dynamic = value;
	
				return this;
	
			},
	
			copy: function ( source ) {
	
				this.array = new source.array.constructor( source.array );
				this.itemSize = source.itemSize;
				this.count = source.count;
				this.normalized = source.normalized;
	
				this.dynamic = source.dynamic;
	
				return this;
	
			},
	
			copyAt: function ( index1, attribute, index2 ) {
	
				index1 *= this.itemSize;
				index2 *= attribute.itemSize;
	
				for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
					this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
				}
	
				return this;
	
			},
	
			copyArray: function ( array ) {
	
				this.array.set( array );
	
				return this;
	
			},
	
			copyColorsArray: function ( colors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = colors.length; i < l; i ++ ) {
	
					var color = colors[ i ];
	
					if ( color === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
						color = new Color();
	
					}
	
					array[ offset ++ ] = color.r;
					array[ offset ++ ] = color.g;
					array[ offset ++ ] = color.b;
	
				}
	
				return this;
	
			},
	
			copyIndicesArray: function ( indices ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
					var index = indices[ i ];
	
					array[ offset ++ ] = index.a;
					array[ offset ++ ] = index.b;
					array[ offset ++ ] = index.c;
	
				}
	
				return this;
	
			},
	
			copyVector2sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
						vector = new Vector2();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
	
				}
	
				return this;
	
			},
	
			copyVector3sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
						vector = new Vector3();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
	
				}
	
				return this;
	
			},
	
			copyVector4sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
						vector = new Vector4();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
					array[ offset ++ ] = vector.w;
	
				}
	
				return this;
	
			},
	
			set: function ( value, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.array.set( value, offset );
	
				return this;
	
			},
	
			getX: function ( index ) {
	
				return this.array[ index * this.itemSize ];
	
			},
	
			setX: function ( index, x ) {
	
				this.array[ index * this.itemSize ] = x;
	
				return this;
	
			},
	
			getY: function ( index ) {
	
				return this.array[ index * this.itemSize + 1 ];
	
			},
	
			setY: function ( index, y ) {
	
				this.array[ index * this.itemSize + 1 ] = y;
	
				return this;
	
			},
	
			getZ: function ( index ) {
	
				return this.array[ index * this.itemSize + 2 ];
	
			},
	
			setZ: function ( index, z ) {
	
				this.array[ index * this.itemSize + 2 ] = z;
	
				return this;
	
			},
	
			getW: function ( index ) {
	
				return this.array[ index * this.itemSize + 3 ];
	
			},
	
			setW: function ( index, w ) {
	
				this.array[ index * this.itemSize + 3 ] = w;
	
				return this;
	
			},
	
			setXY: function ( index, x, y ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
	
				return this;
	
			},
	
			setXYZ: function ( index, x, y, z ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
	
				return this;
	
			},
	
			setXYZW: function ( index, x, y, z, w ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
				this.array[ index + 3 ] = w;
	
				return this;
	
			},
	
			onUpload: function ( callback ) {
	
				this.onUploadCallback = callback;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this.array, this.itemSize ).copy( this );
	
			}
	
		} );
	
		//
	
		function Int8BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Int8Array( array ), itemSize );
	
		}
	
		Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
	
	
		function Uint8BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint8Array( array ), itemSize );
	
		}
	
		Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
	
	
		function Uint8ClampedBufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize );
	
		}
	
		Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
	
	
		function Int16BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Int16Array( array ), itemSize );
	
		}
	
		Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
	
	
		function Uint16BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint16Array( array ), itemSize );
	
		}
	
		Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
	
	
		function Int32BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Int32Array( array ), itemSize );
	
		}
	
		Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
	
	
		function Uint32BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint32Array( array ), itemSize );
	
		}
	
		Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
	
	
		function Float32BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Float32Array( array ), itemSize );
	
		}
	
		Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
	
	
		function Float64BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Float64Array( array ), itemSize );
	
		}
	
		Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function DirectGeometry() {
	
			this.indices = [];
			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];
	
			this.groups = [];
	
			this.morphTargets = {};
	
			this.skinWeights = [];
			this.skinIndices = [];
	
			// this.lineDistances = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// update flags
	
			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;
	
		}
	
		Object.assign( DirectGeometry.prototype, {
	
			computeGroups: function ( geometry ) {
	
				var group;
				var groups = [];
				var materialIndex = undefined;
	
				var faces = geometry.faces;
	
				for ( var i = 0; i < faces.length; i ++ ) {
	
					var face = faces[ i ];
	
					// materials
	
					if ( face.materialIndex !== materialIndex ) {
	
						materialIndex = face.materialIndex;
	
						if ( group !== undefined ) {
	
							group.count = ( i * 3 ) - group.start;
							groups.push( group );
	
						}
	
						group = {
							start: i * 3,
							materialIndex: materialIndex
						};
	
					}
	
				}
	
				if ( group !== undefined ) {
	
					group.count = ( i * 3 ) - group.start;
					groups.push( group );
	
				}
	
				this.groups = groups;
	
			},
	
			fromGeometry: function ( geometry ) {
	
				var faces = geometry.faces;
				var vertices = geometry.vertices;
				var faceVertexUvs = geometry.faceVertexUvs;
	
				var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
				var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
	
				// morphs
	
				var morphTargets = geometry.morphTargets;
				var morphTargetsLength = morphTargets.length;
	
				var morphTargetsPosition;
	
				if ( morphTargetsLength > 0 ) {
	
					morphTargetsPosition = [];
	
					for ( var i = 0; i < morphTargetsLength; i ++ ) {
	
						morphTargetsPosition[ i ] = [];
	
					}
	
					this.morphTargets.position = morphTargetsPosition;
	
				}
	
				var morphNormals = geometry.morphNormals;
				var morphNormalsLength = morphNormals.length;
	
				var morphTargetsNormal;
	
				if ( morphNormalsLength > 0 ) {
	
					morphTargetsNormal = [];
	
					for ( var i = 0; i < morphNormalsLength; i ++ ) {
	
						morphTargetsNormal[ i ] = [];
	
					}
	
					this.morphTargets.normal = morphTargetsNormal;
	
				}
	
				// skins
	
				var skinIndices = geometry.skinIndices;
				var skinWeights = geometry.skinWeights;
	
				var hasSkinIndices = skinIndices.length === vertices.length;
				var hasSkinWeights = skinWeights.length === vertices.length;
	
				//
	
				for ( var i = 0; i < faces.length; i ++ ) {
	
					var face = faces[ i ];
	
					this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
	
					} else {
	
						var normal = face.normal;
	
						this.normals.push( normal, normal, normal );
	
					}
	
					var vertexColors = face.vertexColors;
	
					if ( vertexColors.length === 3 ) {
	
						this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
	
					} else {
	
						var color = face.color;
	
						this.colors.push( color, color, color );
	
					}
	
					if ( hasFaceVertexUv === true ) {
	
						var vertexUvs = faceVertexUvs[ 0 ][ i ];
	
						if ( vertexUvs !== undefined ) {
	
							this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
						} else {
	
							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
	
							this.uvs.push( new Vector2(), new Vector2(), new Vector2() );
	
						}
	
					}
	
					if ( hasFaceVertexUv2 === true ) {
	
						var vertexUvs = faceVertexUvs[ 1 ][ i ];
	
						if ( vertexUvs !== undefined ) {
	
							this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
						} else {
	
							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
	
							this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );
	
						}
	
					}
	
					// morphs
	
					for ( var j = 0; j < morphTargetsLength; j ++ ) {
	
						var morphTarget = morphTargets[ j ].vertices;
	
						morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
	
					}
	
					for ( var j = 0; j < morphNormalsLength; j ++ ) {
	
						var morphNormal = morphNormals[ j ].vertexNormals[ i ];
	
						morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );
	
					}
	
					// skins
	
					if ( hasSkinIndices ) {
	
						this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
	
					}
	
					if ( hasSkinWeights ) {
	
						this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
	
					}
	
				}
	
				this.computeGroups( geometry );
	
				this.verticesNeedUpdate = geometry.verticesNeedUpdate;
				this.normalsNeedUpdate = geometry.normalsNeedUpdate;
				this.colorsNeedUpdate = geometry.colorsNeedUpdate;
				this.uvsNeedUpdate = geometry.uvsNeedUpdate;
				this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
				return this;
	
			}
	
		} );
	
		function arrayMax( array ) {
	
			if ( array.length === 0 ) return - Infinity;
	
			var max = array[ 0 ];
	
			for ( var i = 1, l = array.length; i < l; ++ i ) {
	
				if ( array[ i ] > max ) max = array[ i ];
	
			}
	
			return max;
	
		}
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferGeometry() {
	
			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'BufferGeometry';
	
			this.index = null;
			this.attributes = {};
	
			this.morphAttributes = {};
	
			this.groups = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			this.drawRange = { start: 0, count: Infinity };
	
		}
	
		BufferGeometry.MaxIndex = 65535;
	
		Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {
	
			isBufferGeometry: true,
	
			getIndex: function () {
	
				return this.index;
	
			},
	
			setIndex: function ( index ) {
	
				if ( Array.isArray( index ) ) {
	
					this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );
	
				} else {
	
					this.index = index;
	
				}
	
			},
	
			addAttribute: function ( name, attribute ) {
	
				if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {
	
					console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
					this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
	
					return;
	
				}
	
				if ( name === 'index' ) {
	
					console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
					this.setIndex( attribute );
	
					return;
	
				}
	
				this.attributes[ name ] = attribute;
	
				return this;
	
			},
	
			getAttribute: function ( name ) {
	
				return this.attributes[ name ];
	
			},
	
			removeAttribute: function ( name ) {
	
				delete this.attributes[ name ];
	
				return this;
	
			},
	
			addGroup: function ( start, count, materialIndex ) {
	
				this.groups.push( {
	
					start: start,
					count: count,
					materialIndex: materialIndex !== undefined ? materialIndex : 0
	
				} );
	
			},
	
			clearGroups: function () {
	
				this.groups = [];
	
			},
	
			setDrawRange: function ( start, count ) {
	
				this.drawRange.start = start;
				this.drawRange.count = count;
	
			},
	
			applyMatrix: function ( matrix ) {
	
				var position = this.attributes.position;
	
				if ( position !== undefined ) {
	
					matrix.applyToBufferAttribute( position );
					position.needsUpdate = true;
	
				}
	
				var normal = this.attributes.normal;
	
				if ( normal !== undefined ) {
	
					var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
					normalMatrix.applyToBufferAttribute( normal );
					normal.needsUpdate = true;
	
				}
	
				if ( this.boundingBox !== null ) {
	
					this.computeBoundingBox();
	
				}
	
				if ( this.boundingSphere !== null ) {
	
					this.computeBoundingSphere();
	
				}
	
				return this;
	
			},
	
			rotateX: function () {
	
				// rotate geometry around world x-axis
	
				var m1 = new Matrix4();
	
				return function rotateX( angle ) {
	
					m1.makeRotationX( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateY: function () {
	
				// rotate geometry around world y-axis
	
				var m1 = new Matrix4();
	
				return function rotateY( angle ) {
	
					m1.makeRotationY( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateZ: function () {
	
				// rotate geometry around world z-axis
	
				var m1 = new Matrix4();
	
				return function rotateZ( angle ) {
	
					m1.makeRotationZ( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			translate: function () {
	
				// translate geometry
	
				var m1 = new Matrix4();
	
				return function translate( x, y, z ) {
	
					m1.makeTranslation( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			scale: function () {
	
				// scale geometry
	
				var m1 = new Matrix4();
	
				return function scale( x, y, z ) {
	
					m1.makeScale( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			lookAt: function () {
	
				var obj = new Object3D();
	
				return function lookAt( vector ) {
	
					obj.lookAt( vector );
	
					obj.updateMatrix();
	
					this.applyMatrix( obj.matrix );
	
				};
	
			}(),
	
			center: function () {
	
				this.computeBoundingBox();
	
				var offset = this.boundingBox.getCenter().negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return offset;
	
			},
	
			setFromObject: function ( object ) {
	
				// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	
				var geometry = object.geometry;
	
				if ( object.isPoints || object.isLine ) {
	
					var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
					var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );
	
					this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
					this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
	
					if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
	
						var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );
	
						this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
	
					}
	
					if ( geometry.boundingSphere !== null ) {
	
						this.boundingSphere = geometry.boundingSphere.clone();
	
					}
	
					if ( geometry.boundingBox !== null ) {
	
						this.boundingBox = geometry.boundingBox.clone();
	
					}
	
				} else if ( object.isMesh ) {
	
					if ( geometry && geometry.isGeometry ) {
	
						this.fromGeometry( geometry );
	
					}
	
				}
	
				return this;
	
			},
	
			updateFromObject: function ( object ) {
	
				var geometry = object.geometry;
	
				if ( object.isMesh ) {
	
					var direct = geometry.__directGeometry;
	
					if ( geometry.elementsNeedUpdate === true ) {
	
						direct = undefined;
						geometry.elementsNeedUpdate = false;
	
					}
	
					if ( direct === undefined ) {
	
						return this.fromGeometry( geometry );
	
					}
	
					direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
					direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
					direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
					direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
					direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
					geometry.verticesNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.groupsNeedUpdate = false;
	
					geometry = direct;
	
				}
	
				var attribute;
	
				if ( geometry.verticesNeedUpdate === true ) {
	
					attribute = this.attributes.position;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector3sArray( geometry.vertices );
						attribute.needsUpdate = true;
	
					}
	
					geometry.verticesNeedUpdate = false;
	
				}
	
				if ( geometry.normalsNeedUpdate === true ) {
	
					attribute = this.attributes.normal;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector3sArray( geometry.normals );
						attribute.needsUpdate = true;
	
					}
	
					geometry.normalsNeedUpdate = false;
	
				}
	
				if ( geometry.colorsNeedUpdate === true ) {
	
					attribute = this.attributes.color;
	
					if ( attribute !== undefined ) {
	
						attribute.copyColorsArray( geometry.colors );
						attribute.needsUpdate = true;
	
					}
	
					geometry.colorsNeedUpdate = false;
	
				}
	
				if ( geometry.uvsNeedUpdate ) {
	
					attribute = this.attributes.uv;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;
	
					}
	
					geometry.uvsNeedUpdate = false;
	
				}
	
				if ( geometry.lineDistancesNeedUpdate ) {
	
					attribute = this.attributes.lineDistance;
	
					if ( attribute !== undefined ) {
	
						attribute.copyArray( geometry.lineDistances );
						attribute.needsUpdate = true;
	
					}
	
					geometry.lineDistancesNeedUpdate = false;
	
				}
	
				if ( geometry.groupsNeedUpdate ) {
	
					geometry.computeGroups( object.geometry );
					this.groups = geometry.groups;
	
					geometry.groupsNeedUpdate = false;
	
				}
	
				return this;
	
			},
	
			fromGeometry: function ( geometry ) {
	
				geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );
	
				return this.fromDirectGeometry( geometry.__directGeometry );
	
			},
	
			fromDirectGeometry: function ( geometry ) {
	
				var positions = new Float32Array( geometry.vertices.length * 3 );
				this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
	
				if ( geometry.normals.length > 0 ) {
	
					var normals = new Float32Array( geometry.normals.length * 3 );
					this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
	
				}
	
				if ( geometry.colors.length > 0 ) {
	
					var colors = new Float32Array( geometry.colors.length * 3 );
					this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
	
				}
	
				if ( geometry.uvs.length > 0 ) {
	
					var uvs = new Float32Array( geometry.uvs.length * 2 );
					this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
	
				}
	
				if ( geometry.uvs2.length > 0 ) {
	
					var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
					this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
	
				}
	
				if ( geometry.indices.length > 0 ) {
	
					var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
					var indices = new TypeArray( geometry.indices.length * 3 );
					this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );
	
				}
	
				// groups
	
				this.groups = geometry.groups;
	
				// morphs
	
				for ( var name in geometry.morphTargets ) {
	
					var array = [];
					var morphTargets = geometry.morphTargets[ name ];
	
					for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
	
						var morphTarget = morphTargets[ i ];
	
						var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );
	
						array.push( attribute.copyVector3sArray( morphTarget ) );
	
					}
	
					this.morphAttributes[ name ] = array;
	
				}
	
				// skinning
	
				if ( geometry.skinIndices.length > 0 ) {
	
					var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
					this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
	
				}
	
				if ( geometry.skinWeights.length > 0 ) {
	
					var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
					this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
	
				}
	
				//
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
				return this;
	
			},
	
			computeBoundingBox: function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new Box3();
	
				}
	
				var position = this.attributes.position;
	
				if ( position !== undefined ) {
	
					this.boundingBox.setFromBufferAttribute( position );
	
				} else {
	
					this.boundingBox.makeEmpty();
	
				}
	
				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
	
				}
	
			},
	
			computeBoundingSphere: function () {
	
				var box = new Box3();
				var vector = new Vector3();
	
				return function computeBoundingSphere() {
	
					if ( this.boundingSphere === null ) {
	
						this.boundingSphere = new Sphere();
	
					}
	
					var position = this.attributes.position;
	
					if ( position ) {
	
						var center = this.boundingSphere.center;
	
						box.setFromBufferAttribute( position );
						box.getCenter( center );
	
						// hoping to find a boundingSphere with a radius smaller than the
						// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	
						var maxRadiusSq = 0;
	
						for ( var i = 0, il = position.count; i < il; i ++ ) {
	
							vector.x = position.getX( i );
							vector.y = position.getY( i );
							vector.z = position.getZ( i );
							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
						}
	
						this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
						if ( isNaN( this.boundingSphere.radius ) ) {
	
							console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
	
						}
	
					}
	
				};
	
			}(),
	
			computeFaceNormals: function () {
	
				// backwards compatibility
	
			},
	
			computeVertexNormals: function () {
	
				var index = this.index;
				var attributes = this.attributes;
				var groups = this.groups;
	
				if ( attributes.position ) {
	
					var positions = attributes.position.array;
	
					if ( attributes.normal === undefined ) {
	
						this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
					} else {
	
						// reset existing normals to zero
	
						var array = attributes.normal.array;
	
						for ( var i = 0, il = array.length; i < il; i ++ ) {
	
							array[ i ] = 0;
	
						}
	
					}
	
					var normals = attributes.normal.array;
	
					var vA, vB, vC;
					var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
					var cb = new Vector3(), ab = new Vector3();
	
					// indexed elements
	
					if ( index ) {
	
						var indices = index.array;
	
						if ( groups.length === 0 ) {
	
							this.addGroup( 0, indices.length );
	
						}
	
						for ( var j = 0, jl = groups.length; j < jl; ++ j ) {
	
							var group = groups[ j ];
	
							var start = group.start;
							var count = group.count;
	
							for ( var i = start, il = start + count; i < il; i += 3 ) {
	
								vA = indices[ i + 0 ] * 3;
								vB = indices[ i + 1 ] * 3;
								vC = indices[ i + 2 ] * 3;
	
								pA.fromArray( positions, vA );
								pB.fromArray( positions, vB );
								pC.fromArray( positions, vC );
	
								cb.subVectors( pC, pB );
								ab.subVectors( pA, pB );
								cb.cross( ab );
	
								normals[ vA ] += cb.x;
								normals[ vA + 1 ] += cb.y;
								normals[ vA + 2 ] += cb.z;
	
								normals[ vB ] += cb.x;
								normals[ vB + 1 ] += cb.y;
								normals[ vB + 2 ] += cb.z;
	
								normals[ vC ] += cb.x;
								normals[ vC + 1 ] += cb.y;
								normals[ vC + 2 ] += cb.z;
	
							}
	
						}
	
					} else {
	
						// non-indexed elements (unconnected triangle soup)
	
						for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
							pA.fromArray( positions, i );
							pB.fromArray( positions, i + 3 );
							pC.fromArray( positions, i + 6 );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ i ] = cb.x;
							normals[ i + 1 ] = cb.y;
							normals[ i + 2 ] = cb.z;
	
							normals[ i + 3 ] = cb.x;
							normals[ i + 4 ] = cb.y;
							normals[ i + 5 ] = cb.z;
	
							normals[ i + 6 ] = cb.x;
							normals[ i + 7 ] = cb.y;
							normals[ i + 8 ] = cb.z;
	
						}
	
					}
	
					this.normalizeNormals();
	
					attributes.normal.needsUpdate = true;
	
				}
	
			},
	
			merge: function ( geometry, offset ) {
	
				if ( ! ( geometry && geometry.isBufferGeometry ) ) {
	
					console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
					return;
	
				}
	
				if ( offset === undefined ) offset = 0;
	
				var attributes = this.attributes;
	
				for ( var key in attributes ) {
	
					if ( geometry.attributes[ key ] === undefined ) continue;
	
					var attribute1 = attributes[ key ];
					var attributeArray1 = attribute1.array;
	
					var attribute2 = geometry.attributes[ key ];
					var attributeArray2 = attribute2.array;
	
					var attributeSize = attribute2.itemSize;
	
					for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
						attributeArray1[ j ] = attributeArray2[ i ];
	
					}
	
				}
	
				return this;
	
			},
	
			normalizeNormals: function () {
	
				var normals = this.attributes.normal;
	
				var x, y, z, n;
	
				for ( var i = 0, il = normals.count; i < il; i ++ ) {
	
					x = normals.getX( i );
					y = normals.getY( i );
					z = normals.getZ( i );
	
					n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
					normals.setXYZ( i, x * n, y * n, z * n );
	
				}
	
			},
	
			toNonIndexed: function () {
	
				if ( this.index === null ) {
	
					console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
					return this;
	
				}
	
				var geometry2 = new BufferGeometry();
	
				var indices = this.index.array;
				var attributes = this.attributes;
	
				for ( var name in attributes ) {
	
					var attribute = attributes[ name ];
	
					var array = attribute.array;
					var itemSize = attribute.itemSize;
	
					var array2 = new array.constructor( indices.length * itemSize );
	
					var index = 0, index2 = 0;
	
					for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
						index = indices[ i ] * itemSize;
	
						for ( var j = 0; j < itemSize; j ++ ) {
	
							array2[ index2 ++ ] = array[ index ++ ];
	
						}
	
					}
	
					geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );
	
				}
	
				return geometry2;
	
			},
	
			toJSON: function () {
	
				var data = {
					metadata: {
						version: 4.5,
						type: 'BufferGeometry',
						generator: 'BufferGeometry.toJSON'
					}
				};
	
				// standard BufferGeometry serialization
	
				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.parameters !== undefined ) {
	
					var parameters = this.parameters;
	
					for ( var key in parameters ) {
	
						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
					}
	
					return data;
	
				}
	
				data.data = { attributes: {} };
	
				var index = this.index;
	
				if ( index !== null ) {
	
					var array = Array.prototype.slice.call( index.array );
	
					data.data.index = {
						type: index.array.constructor.name,
						array: array
					};
	
				}
	
				var attributes = this.attributes;
	
				for ( var key in attributes ) {
	
					var attribute = attributes[ key ];
	
					var array = Array.prototype.slice.call( attribute.array );
	
					data.data.attributes[ key ] = {
						itemSize: attribute.itemSize,
						type: attribute.array.constructor.name,
						array: array,
						normalized: attribute.normalized
					};
	
				}
	
				var groups = this.groups;
	
				if ( groups.length > 0 ) {
	
					data.data.groups = JSON.parse( JSON.stringify( groups ) );
	
				}
	
				var boundingSphere = this.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					data.data.boundingSphere = {
						center: boundingSphere.center.toArray(),
						radius: boundingSphere.radius
					};
	
				}
	
				return data;
	
			},
	
			clone: function () {
	
				/*
				 // Handle primitives
	
				 var parameters = this.parameters;
	
				 if ( parameters !== undefined ) {
	
				 var values = [];
	
				 for ( var key in parameters ) {
	
				 values.push( parameters[ key ] );
	
				 }
	
				 var geometry = Object.create( this.constructor.prototype );
				 this.constructor.apply( geometry, values );
				 return geometry;
	
				 }
	
				 return new this.constructor().copy( this );
				 */
	
				return new BufferGeometry().copy( this );
	
			},
	
			copy: function ( source ) {
	
				var name, i, l;
	
				// reset
	
				this.index = null;
				this.attributes = {};
				this.morphAttributes = {};
				this.groups = [];
				this.boundingBox = null;
				this.boundingSphere = null;
	
				// name
	
				this.name = source.name;
	
				// index
	
				var index = source.index;
	
				if ( index !== null ) {
	
					this.setIndex( index.clone() );
	
				}
	
				// attributes
	
				var attributes = source.attributes;
	
				for ( name in attributes ) {
	
					var attribute = attributes[ name ];
					this.addAttribute( name, attribute.clone() );
	
				}
	
				// morph attributes
	
				var morphAttributes = source.morphAttributes;
	
				for ( name in morphAttributes ) {
	
					var array = [];
					var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
	
					for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {
	
						array.push( morphAttribute[ i ].clone() );
	
					}
	
					this.morphAttributes[ name ] = array;
	
				}
	
				// groups
	
				var groups = source.groups;
	
				for ( i = 0, l = groups.length; i < l; i ++ ) {
	
					var group = groups[ i ];
					this.addGroup( group.start, group.count, group.materialIndex );
	
				}
	
				// bounding box
	
				var boundingBox = source.boundingBox;
	
				if ( boundingBox !== null ) {
	
					this.boundingBox = boundingBox.clone();
	
				}
	
				// bounding sphere
	
				var boundingSphere = source.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					this.boundingSphere = boundingSphere.clone();
	
				}
	
				// draw range
	
				this.drawRange.start = source.drawRange.start;
				this.drawRange.count = source.drawRange.count;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// BoxGeometry
	
		function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
			Geometry.call( this );
	
			this.type = 'BoxGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
	
			this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
			this.mergeVertices();
	
		}
	
		BoxGeometry.prototype = Object.create( Geometry.prototype );
		BoxGeometry.prototype.constructor = BoxGeometry;
	
		// BoxBufferGeometry
	
		function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'BoxBufferGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
	
			var scope = this;
	
			// segments
	
			widthSegments = Math.floor( widthSegments ) || 1;
			heightSegments = Math.floor( heightSegments ) || 1;
			depthSegments = Math.floor( depthSegments ) || 1;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var numberOfVertices = 0;
			var groupStart = 0;
	
			// build each side of the box geometry
	
			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
			buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
			buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
	
				var segmentWidth = width / gridX;
				var segmentHeight = height / gridY;
	
				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;
	
				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;
	
				var vertexCounter = 0;
				var groupCount = 0;
	
				var ix, iy;
	
				var vector = new Vector3();
	
				// generate vertices, normals and uvs
	
				for ( iy = 0; iy < gridY1; iy ++ ) {
	
					var y = iy * segmentHeight - heightHalf;
	
					for ( ix = 0; ix < gridX1; ix ++ ) {
	
						var x = ix * segmentWidth - widthHalf;
	
						// set values to correct vector component
	
						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;
	
						// now apply vector to vertex buffer
	
						vertices.push( vector.x, vector.y, vector.z );
	
						// set values to correct vector component
	
						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;
	
						// now apply vector to normal buffer
	
						normals.push( vector.x, vector.y, vector.z );
	
						// uvs
	
						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );
	
						// counters
	
						vertexCounter += 1;
	
					}
	
				}
	
				// indices
	
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment
	
				for ( iy = 0; iy < gridY; iy ++ ) {
	
					for ( ix = 0; ix < gridX; ix ++ ) {
	
						var a = numberOfVertices + ix + gridX1 * iy;
						var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
						// increase counter
	
						groupCount += 6;
	
					}
	
				}
	
				// add a group to the geometry. this will ensure multi material support
	
				scope.addGroup( groupStart, groupCount, materialIndex );
	
				// calculate new start value for groups
	
				groupStart += groupCount;
	
				// update total number of vertices
	
				numberOfVertices += vertexCounter;
	
			}
	
		}
	
		BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// PlaneGeometry
	
		function PlaneGeometry( width, height, widthSegments, heightSegments ) {
	
			Geometry.call( this );
	
			this.type = 'PlaneGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
	
			this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
			this.mergeVertices();
	
		}
	
		PlaneGeometry.prototype = Object.create( Geometry.prototype );
		PlaneGeometry.prototype.constructor = PlaneGeometry;
	
		// PlaneBufferGeometry
	
		function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'PlaneBufferGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
	
			var width_half = width / 2;
			var height_half = height / 2;
	
			var gridX = Math.floor( widthSegments ) || 1;
			var gridY = Math.floor( heightSegments ) || 1;
	
			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;
	
			var segment_width = width / gridX;
			var segment_height = height / gridY;
	
			var ix, iy;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// generate vertices, normals and uvs
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				var y = iy * segment_height - height_half;
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var x = ix * segment_width - width_half;
	
					vertices.push( x, - y, 0 );
	
					normals.push( 0, 0, 1 );
	
					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );
	
				}
	
			}
	
			// indices
	
			for ( iy = 0; iy < gridY; iy ++ ) {
	
				for ( ix = 0; ix < gridX; ix ++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  shading: THREE.SmoothShading,
		 *  depthTest: <bool>,
		 *  depthWrite: <bool>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>
		 * }
		 */
	
		function MeshBasicMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshBasicMaterial';
	
			this.color = new Color( 0xffffff ); // emissive
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		MeshBasicMaterial.prototype = Object.create( Material.prototype );
		MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
	
		MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
	
		MeshBasicMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
	
			return this;
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Ray( origin, direction ) {
	
			this.origin = ( origin !== undefined ) ? origin : new Vector3();
			this.direction = ( direction !== undefined ) ? direction : new Vector3();
	
		}
	
		Object.assign( Ray.prototype, {
	
			set: function ( origin, direction ) {
	
				this.origin.copy( origin );
				this.direction.copy( direction );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( ray ) {
	
				this.origin.copy( ray.origin );
				this.direction.copy( ray.direction );
	
				return this;
	
			},
	
			at: function ( t, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
			},
	
			lookAt: function ( v ) {
	
				this.direction.copy( v ).sub( this.origin ).normalize();
	
				return this;
	
			},
	
			recast: function () {
	
				var v1 = new Vector3();
	
				return function recast( t ) {
	
					this.origin.copy( this.at( t, v1 ) );
	
					return this;
	
				};
	
			}(),
	
			closestPointToPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				result.subVectors( point, this.origin );
				var directionDistance = result.dot( this.direction );
	
				if ( directionDistance < 0 ) {
	
					return result.copy( this.origin );
	
				}
	
				return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
			},
	
			distanceToPoint: function ( point ) {
	
				return Math.sqrt( this.distanceSqToPoint( point ) );
	
			},
	
			distanceSqToPoint: function () {
	
				var v1 = new Vector3();
	
				return function distanceSqToPoint( point ) {
	
					var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
					// point behind the ray
	
					if ( directionDistance < 0 ) {
	
						return this.origin.distanceToSquared( point );
	
					}
	
					v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
					return v1.distanceToSquared( point );
	
				};
	
			}(),
	
			distanceSqToSegment: function () {
	
				var segCenter = new Vector3();
				var segDir = new Vector3();
				var diff = new Vector3();
	
				return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
					// It returns the min distance between the ray and the segment
					// defined by v0 and v1
					// It can also set two optional targets :
					// - The closest point on the ray
					// - The closest point on the segment
	
					segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
					segDir.copy( v1 ).sub( v0 ).normalize();
					diff.copy( this.origin ).sub( segCenter );
	
					var segExtent = v0.distanceTo( v1 ) * 0.5;
					var a01 = - this.direction.dot( segDir );
					var b0 = diff.dot( this.direction );
					var b1 = - diff.dot( segDir );
					var c = diff.lengthSq();
					var det = Math.abs( 1 - a01 * a01 );
					var s0, s1, sqrDist, extDet;
	
					if ( det > 0 ) {
	
						// The ray and segment are not parallel.
	
						s0 = a01 * b1 - b0;
						s1 = a01 * b0 - b1;
						extDet = segExtent * det;
	
						if ( s0 >= 0 ) {
	
							if ( s1 >= - extDet ) {
	
								if ( s1 <= extDet ) {
	
									// region 0
									// Minimum at interior points of ray and segment.
	
									var invDet = 1 / det;
									s0 *= invDet;
									s1 *= invDet;
									sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
								} else {
	
									// region 1
	
									s1 = segExtent;
									s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
									sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
								}
	
							} else {
	
								// region 5
	
								s1 = - segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							if ( s1 <= - extDet ) {
	
								// region 4
	
								s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							} else if ( s1 <= extDet ) {
	
								// region 3
	
								s0 = 0;
								s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 2
	
								s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						}
	
					} else {
	
						// Ray and segment are parallel.
	
						s1 = ( a01 > 0 ) ? - segExtent : segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
					}
	
					if ( optionalPointOnRay ) {
	
						optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
					}
	
					if ( optionalPointOnSegment ) {
	
						optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
					}
	
					return sqrDist;
	
				};
	
			}(),
	
			intersectSphere: function () {
	
				var v1 = new Vector3();
	
				return function intersectSphere( sphere, optionalTarget ) {
	
					v1.subVectors( sphere.center, this.origin );
					var tca = v1.dot( this.direction );
					var d2 = v1.dot( v1 ) - tca * tca;
					var radius2 = sphere.radius * sphere.radius;
	
					if ( d2 > radius2 ) return null;
	
					var thc = Math.sqrt( radius2 - d2 );
	
					// t0 = first intersect point - entrance on front of sphere
					var t0 = tca - thc;
	
					// t1 = second intersect point - exit point on back of sphere
					var t1 = tca + thc;
	
					// test to see if both t0 and t1 are behind the ray - if so, return null
					if ( t0 < 0 && t1 < 0 ) return null;
	
					// test to see if t0 is behind the ray:
					// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
					// in order to always return an intersect point that is in front of the ray.
					if ( t0 < 0 ) return this.at( t1, optionalTarget );
	
					// else t0 is in front of the ray, so return the first collision point scaled by t0
					return this.at( t0, optionalTarget );
	
				};
	
			}(),
	
			intersectsSphere: function ( sphere ) {
	
				return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
			},
	
			distanceToPlane: function ( plane ) {
	
				var denominator = plane.normal.dot( this.direction );
	
				if ( denominator === 0 ) {
	
					// line is coplanar, return origin
					if ( plane.distanceToPoint( this.origin ) === 0 ) {
	
						return 0;
	
					}
	
					// Null is preferable to undefined since undefined means.... it is undefined
	
					return null;
	
				}
	
				var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
				// Return if the ray never intersects the plane
	
				return t >= 0 ? t :  null;
	
			},
	
			intersectPlane: function ( plane, optionalTarget ) {
	
				var t = this.distanceToPlane( plane );
	
				if ( t === null ) {
	
					return null;
	
				}
	
				return this.at( t, optionalTarget );
	
			},
	
			intersectsPlane: function ( plane ) {
	
				// check if the ray lies on the plane first
	
				var distToPoint = plane.distanceToPoint( this.origin );
	
				if ( distToPoint === 0 ) {
	
					return true;
	
				}
	
				var denominator = plane.normal.dot( this.direction );
	
				if ( denominator * distToPoint < 0 ) {
	
					return true;
	
				}
	
				// ray origin is behind the plane (and is pointing behind it)
	
				return false;
	
			},
	
			intersectBox: function ( box, optionalTarget ) {
	
				var tmin, tmax, tymin, tymax, tzmin, tzmax;
	
				var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;
	
				var origin = this.origin;
	
				if ( invdirx >= 0 ) {
	
					tmin = ( box.min.x - origin.x ) * invdirx;
					tmax = ( box.max.x - origin.x ) * invdirx;
	
				} else {
	
					tmin = ( box.max.x - origin.x ) * invdirx;
					tmax = ( box.min.x - origin.x ) * invdirx;
	
				}
	
				if ( invdiry >= 0 ) {
	
					tymin = ( box.min.y - origin.y ) * invdiry;
					tymax = ( box.max.y - origin.y ) * invdiry;
	
				} else {
	
					tymin = ( box.max.y - origin.y ) * invdiry;
					tymax = ( box.min.y - origin.y ) * invdiry;
	
				}
	
				if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
				// These lines also handle the case where tmin or tmax is NaN
				// (result of 0 * Infinity). x !== x returns true if x is NaN
	
				if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
				if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
				if ( invdirz >= 0 ) {
	
					tzmin = ( box.min.z - origin.z ) * invdirz;
					tzmax = ( box.max.z - origin.z ) * invdirz;
	
				} else {
	
					tzmin = ( box.max.z - origin.z ) * invdirz;
					tzmax = ( box.min.z - origin.z ) * invdirz;
	
				}
	
				if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
				if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
				if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
				//return point closest to the ray (positive side)
	
				if ( tmax < 0 ) return null;
	
				return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
			},
	
			intersectsBox: ( function () {
	
				var v = new Vector3();
	
				return function intersectsBox( box ) {
	
					return this.intersectBox( box, v ) !== null;
	
				};
	
			} )(),
	
			intersectTriangle: function () {
	
				// Compute the offset origin, edges, and normal.
				var diff = new Vector3();
				var edge1 = new Vector3();
				var edge2 = new Vector3();
				var normal = new Vector3();
	
				return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {
	
					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	
					edge1.subVectors( b, a );
					edge2.subVectors( c, a );
					normal.crossVectors( edge1, edge2 );
	
					// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
					// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
					//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
					//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
					//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
					var DdN = this.direction.dot( normal );
					var sign;
	
					if ( DdN > 0 ) {
	
						if ( backfaceCulling ) return null;
						sign = 1;
	
					} else if ( DdN < 0 ) {
	
						sign = - 1;
						DdN = - DdN;
	
					} else {
	
						return null;
	
					}
	
					diff.subVectors( this.origin, a );
					var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
					// b1 < 0, no intersection
					if ( DdQxE2 < 0 ) {
	
						return null;
	
					}
	
					var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
					// b2 < 0, no intersection
					if ( DdE1xQ < 0 ) {
	
						return null;
	
					}
	
					// b1+b2 > 1, no intersection
					if ( DdQxE2 + DdE1xQ > DdN ) {
	
						return null;
	
					}
	
					// Line intersects triangle, check if ray does.
					var QdN = - sign * diff.dot( normal );
	
					// t < 0, no intersection
					if ( QdN < 0 ) {
	
						return null;
	
					}
	
					// Ray intersects triangle.
					return this.at( QdN / DdN, optionalTarget );
	
				};
	
			}(),
	
			applyMatrix4: function ( matrix4 ) {
	
				this.origin.applyMatrix4( matrix4 );
				this.direction.transformDirection( matrix4 );
	
				return this;
	
			},
	
			equals: function ( ray ) {
	
				return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
			}
	
		} );
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Line3( start, end ) {
	
			this.start = ( start !== undefined ) ? start : new Vector3();
			this.end = ( end !== undefined ) ? end : new Vector3();
	
		}
	
		Object.assign( Line3.prototype, {
	
			set: function ( start, end ) {
	
				this.start.copy( start );
				this.end.copy( end );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( line ) {
	
				this.start.copy( line.start );
				this.end.copy( line.end );
	
				return this;
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
			},
	
			delta: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.subVectors( this.end, this.start );
	
			},
	
			distanceSq: function () {
	
				return this.start.distanceToSquared( this.end );
	
			},
	
			distance: function () {
	
				return this.start.distanceTo( this.end );
	
			},
	
			at: function ( t, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				return this.delta( result ).multiplyScalar( t ).add( this.start );
	
			},
	
			closestPointToPointParameter: function () {
	
				var startP = new Vector3();
				var startEnd = new Vector3();
	
				return function closestPointToPointParameter( point, clampToLine ) {
	
					startP.subVectors( point, this.start );
					startEnd.subVectors( this.end, this.start );
	
					var startEnd2 = startEnd.dot( startEnd );
					var startEnd_startP = startEnd.dot( startP );
	
					var t = startEnd_startP / startEnd2;
	
					if ( clampToLine ) {
	
						t = _Math.clamp( t, 0, 1 );
	
					}
	
					return t;
	
				};
	
			}(),
	
			closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
				var t = this.closestPointToPointParameter( point, clampToLine );
	
				var result = optionalTarget || new Vector3();
	
				return this.delta( result ).multiplyScalar( t ).add( this.start );
	
			},
	
			applyMatrix4: function ( matrix ) {
	
				this.start.applyMatrix4( matrix );
				this.end.applyMatrix4( matrix );
	
				return this;
	
			},
	
			equals: function ( line ) {
	
				return line.start.equals( this.start ) && line.end.equals( this.end );
	
			}
	
		} );
	
		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Triangle( a, b, c ) {
	
			this.a = ( a !== undefined ) ? a : new Vector3();
			this.b = ( b !== undefined ) ? b : new Vector3();
			this.c = ( c !== undefined ) ? c : new Vector3();
	
		}
	
		Object.assign( Triangle, {
	
			normal: function () {
	
				var v0 = new Vector3();
	
				return function normal( a, b, c, optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					result.subVectors( c, b );
					v0.subVectors( a, b );
					result.cross( v0 );
	
					var resultLengthSq = result.lengthSq();
					if ( resultLengthSq > 0 ) {
	
						return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
					}
	
					return result.set( 0, 0, 0 );
	
				};
	
			}(),
	
			// static/instance method to calculate barycentric coordinates
			// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
			barycoordFromPoint: function () {
	
				var v0 = new Vector3();
				var v1 = new Vector3();
				var v2 = new Vector3();
	
				return function barycoordFromPoint( point, a, b, c, optionalTarget ) {
	
					v0.subVectors( c, a );
					v1.subVectors( b, a );
					v2.subVectors( point, a );
	
					var dot00 = v0.dot( v0 );
					var dot01 = v0.dot( v1 );
					var dot02 = v0.dot( v2 );
					var dot11 = v1.dot( v1 );
					var dot12 = v1.dot( v2 );
	
					var denom = ( dot00 * dot11 - dot01 * dot01 );
	
					var result = optionalTarget || new Vector3();
	
					// collinear or singular triangle
					if ( denom === 0 ) {
	
						// arbitrary location outside of triangle?
						// not sure if this is the best idea, maybe should be returning undefined
						return result.set( - 2, - 1, - 1 );
	
					}
	
					var invDenom = 1 / denom;
					var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
					var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
					// barycentric coordinates must always sum to 1
					return result.set( 1 - u - v, v, u );
	
				};
	
			}(),
	
			containsPoint: function () {
	
				var v1 = new Vector3();
	
				return function containsPoint( point, a, b, c ) {
	
					var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
					return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
				};
	
			}()
	
		} );
	
		Object.assign( Triangle.prototype, {
	
			set: function ( a, b, c ) {
	
				this.a.copy( a );
				this.b.copy( b );
				this.c.copy( c );
	
				return this;
	
			},
	
			setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
				this.a.copy( points[ i0 ] );
				this.b.copy( points[ i1 ] );
				this.c.copy( points[ i2 ] );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( triangle ) {
	
				this.a.copy( triangle.a );
				this.b.copy( triangle.b );
				this.c.copy( triangle.c );
	
				return this;
	
			},
	
			area: function () {
	
				var v0 = new Vector3();
				var v1 = new Vector3();
	
				return function area() {
	
					v0.subVectors( this.c, this.b );
					v1.subVectors( this.a, this.b );
	
					return v0.cross( v1 ).length() * 0.5;
	
				};
	
			}(),
	
			midpoint: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
			},
	
			normal: function ( optionalTarget ) {
	
				return Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
			},
	
			plane: function ( optionalTarget ) {
	
				var result = optionalTarget || new Plane();
	
				return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
			},
	
			barycoordFromPoint: function ( point, optionalTarget ) {
	
				return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
			},
	
			containsPoint: function ( point ) {
	
				return Triangle.containsPoint( point, this.a, this.b, this.c );
	
			},
	
			closestPointToPoint: function () {
	
				var plane = new Plane();
				var edgeList = [ new Line3(), new Line3(), new Line3() ];
				var projectedPoint = new Vector3();
				var closestPoint = new Vector3();
	
				return function closestPointToPoint( point, optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
					var minDistance = Infinity;
	
					// project the point onto the plane of the triangle
	
					plane.setFromCoplanarPoints( this.a, this.b, this.c );
					plane.projectPoint( point, projectedPoint );
	
					// check if the projection lies within the triangle
	
					if( this.containsPoint( projectedPoint ) === true ) {
	
						// if so, this is the closest point
	
						result.copy( projectedPoint );
	
					} else {
	
						// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
	
						edgeList[ 0 ].set( this.a, this.b );
						edgeList[ 1 ].set( this.b, this.c );
						edgeList[ 2 ].set( this.c, this.a );
	
						for( var i = 0; i < edgeList.length; i ++ ) {
	
							edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );
	
							var distance = projectedPoint.distanceToSquared( closestPoint );
	
							if( distance < minDistance ) {
	
								minDistance = distance;
	
								result.copy( closestPoint );
	
							}
	
						}
	
					}
	
					return result;
	
				};
	
			}(),
	
			equals: function ( triangle ) {
	
				return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author jonobr1 / http://jonobr1.com/
		 */
	
		function Mesh( geometry, material ) {
	
			Object3D.call( this );
	
			this.type = 'Mesh';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
			this.drawMode = TrianglesDrawMode;
	
			this.updateMorphTargets();
	
		}
	
		Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Mesh,
	
			isMesh: true,
	
			setDrawMode: function ( value ) {
	
				this.drawMode = value;
	
			},
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.drawMode = source.drawMode;
	
				return this;
	
			},
	
			updateMorphTargets: function () {
	
				var geometry = this.geometry;
				var m, ml, name;
	
				if ( geometry.isBufferGeometry ) {
	
					var morphAttributes = geometry.morphAttributes;
					var keys = Object.keys( morphAttributes );
	
					if ( keys.length > 0 ) {
	
						var morphAttribute = morphAttributes[ keys[ 0 ] ];
	
						if ( morphAttribute !== undefined ) {
	
							this.morphTargetInfluences = [];
							this.morphTargetDictionary = {};
	
							for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {
	
								name = morphAttribute[ m ].name || String( m );
	
								this.morphTargetInfluences.push( 0 );
								this.morphTargetDictionary[ name ] = m;
	
							}
	
						}
	
					}
	
				} else {
	
					var morphTargets = geometry.morphTargets;
	
					if ( morphTargets !== undefined && morphTargets.length > 0 ) {
	
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};
	
						for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {
	
							name = morphTargets[ m ].name || String( m );
	
							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;
	
						}
	
					}
	
				}
	
			},
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				var vA = new Vector3();
				var vB = new Vector3();
				var vC = new Vector3();
	
				var tempA = new Vector3();
				var tempB = new Vector3();
				var tempC = new Vector3();
	
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();
	
				var barycoord = new Vector3();
	
				var intersectionPoint = new Vector3();
				var intersectionPointWorld = new Vector3();
	
				function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
	
					Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
	
					uv1.multiplyScalar( barycoord.x );
					uv2.multiplyScalar( barycoord.y );
					uv3.multiplyScalar( barycoord.z );
	
					uv1.add( uv2 ).add( uv3 );
	
					return uv1.clone();
	
				}
	
				function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {
	
					var intersect;
					var material = object.material;
	
					if ( material.side === BackSide ) {
	
						intersect = ray.intersectTriangle( pC, pB, pA, true, point );
	
					} else {
	
						intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );
	
					}
	
					if ( intersect === null ) return null;
	
					intersectionPointWorld.copy( point );
					intersectionPointWorld.applyMatrix4( object.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
	
					if ( distance < raycaster.near || distance > raycaster.far ) return null;
	
					return {
						distance: distance,
						point: intersectionPointWorld.clone(),
						object: object
					};
	
				}
	
				function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {
	
					vA.fromBufferAttribute( position, a );
					vB.fromBufferAttribute( position, b );
					vC.fromBufferAttribute( position, c );
	
					var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
	
					if ( intersection ) {
	
						if ( uv ) {
	
							uvA.fromBufferAttribute( uv, a );
							uvB.fromBufferAttribute( uv, b );
							uvC.fromBufferAttribute( uv, c );
	
							intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );
	
						}
	
						intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
						intersection.faceIndex = a;
	
					}
	
					return intersection;
	
				}
	
				return function raycast( raycaster, intersects ) {
	
					var geometry = this.geometry;
					var material = this.material;
					var matrixWorld = this.matrixWorld;
	
					if ( material === undefined ) return;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					// Check boundingBox before continuing
	
					if ( geometry.boundingBox !== null ) {
	
						if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
	
					}
	
					var intersection;
	
					if ( geometry.isBufferGeometry ) {
	
						var a, b, c;
						var index = geometry.index;
						var position = geometry.attributes.position;
						var uv = geometry.attributes.uv;
						var i, l;
	
						if ( index !== null ) {
	
							// indexed buffer geometry
	
							for ( i = 0, l = index.count; i < l; i += 3 ) {
	
								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );
	
								intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );
	
								if ( intersection ) {
	
									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						} else {
	
							// non-indexed buffer geometry
	
							for ( i = 0, l = position.count; i < l; i += 3 ) {
	
								a = i;
								b = i + 1;
								c = i + 2;
	
								intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );
	
								if ( intersection ) {
	
									intersection.index = a; // triangle number in positions buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						}
	
					} else if ( geometry.isGeometry ) {
	
						var fvA, fvB, fvC;
						var isMultiMaterial = Array.isArray( material );
	
						var vertices = geometry.vertices;
						var faces = geometry.faces;
						var uvs;
	
						var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
						if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
	
						for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
							var face = faces[ f ];
							var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;
	
							if ( faceMaterial === undefined ) continue;
	
							fvA = vertices[ face.a ];
							fvB = vertices[ face.b ];
							fvC = vertices[ face.c ];
	
							if ( faceMaterial.morphTargets === true ) {
	
								var morphTargets = geometry.morphTargets;
								var morphInfluences = this.morphTargetInfluences;
	
								vA.set( 0, 0, 0 );
								vB.set( 0, 0, 0 );
								vC.set( 0, 0, 0 );
	
								for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
									var influence = morphInfluences[ t ];
	
									if ( influence === 0 ) continue;
	
									var targets = morphTargets[ t ].vertices;
	
									vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
									vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
									vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
	
								}
	
								vA.add( fvA );
								vB.add( fvB );
								vC.add( fvC );
	
								fvA = vA;
								fvB = vB;
								fvC = vC;
	
							}
	
							intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
	
							if ( intersection ) {
	
								if ( uvs && uvs[ f ] ) {
	
									var uvs_f = uvs[ f ];
									uvA.copy( uvs_f[ 0 ] );
									uvB.copy( uvs_f[ 1 ] );
									uvC.copy( uvs_f[ 2 ] );
	
									intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
	
								}
	
								intersection.face = face;
								intersection.faceIndex = f;
								intersects.push( intersection );
	
							}
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {
	
			var clearColor = new Color( 0x000000 );
			var clearAlpha = 0;
	
			var planeCamera, planeMesh;
			var boxCamera, boxMesh;
	
			function render( scene, camera, forceClear ) {
	
				var background = scene.background;
	
				if ( background === null ) {
	
					setClear( clearColor, clearAlpha );
	
				} else if ( background && background.isColor ) {
	
					setClear( background, 1 );
					forceClear = true;
	
				}
	
				if ( renderer.autoClear || forceClear ) {
	
					renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
	
				}
	
				if ( background && background.isCubeTexture ) {
	
					if ( boxCamera === undefined ) {
	
						boxCamera = new PerspectiveCamera();
	
						boxMesh = new Mesh(
							new BoxBufferGeometry( 5, 5, 5 ),
							new ShaderMaterial( {
								uniforms: ShaderLib.cube.uniforms,
								vertexShader: ShaderLib.cube.vertexShader,
								fragmentShader: ShaderLib.cube.fragmentShader,
								side: BackSide,
								depthTest: false,
								depthWrite: false,
								fog: false
							} )
						);
	
					}
	
					boxCamera.projectionMatrix.copy( camera.projectionMatrix );
	
					boxCamera.matrixWorld.extractRotation( camera.matrixWorld );
					boxCamera.matrixWorldInverse.getInverse( boxCamera.matrixWorld );
	
					boxMesh.material.uniforms[ "tCube" ].value = background;
					boxMesh.modelViewMatrix.multiplyMatrices( boxCamera.matrixWorldInverse, boxMesh.matrixWorld );
	
					objects.update( boxMesh );
	
					renderer.renderBufferDirect( boxCamera, null, boxMesh.geometry, boxMesh.material, boxMesh, null );
	
				} else if ( background && background.isTexture ) {
	
					if ( planeCamera === undefined ) {
	
						planeCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	
						planeMesh = new Mesh(
							new PlaneBufferGeometry( 2, 2 ),
							new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
						);
	
					}
	
					planeMesh.material.map = background;
	
					objects.update( planeMesh );
	
					renderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );
	
				}
	
			}
	
			function setClear( color, alpha ) {
	
				state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );
	
			}
	
			return {
	
				getClearColor: function () {
	
					return clearColor;
	
				},
				setClearColor: function ( color, alpha ) {
	
					clearColor.set( color );
					clearAlpha = alpha !== undefined ? alpha : 1;
					setClear( clearColor, clearAlpha );
	
				},
				getClearAlpha: function () {
	
					return clearAlpha;
	
				},
				setClearAlpha: function ( alpha ) {
	
					clearAlpha = alpha;
					setClear( clearColor, clearAlpha );
	
				},
				render: render
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function painterSortStable( a, b ) {
	
			if ( a.renderOrder !== b.renderOrder ) {
	
				return a.renderOrder - b.renderOrder;
	
			} else if ( a.program && b.program && a.program !== b.program ) {
	
				return a.program.id - b.program.id;
	
			} else if ( a.material.id !== b.material.id ) {
	
				return a.material.id - b.material.id;
	
			} else if ( a.z !== b.z ) {
	
				return a.z - b.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		function reversePainterSortStable( a, b ) {
	
			if ( a.renderOrder !== b.renderOrder ) {
	
				return a.renderOrder - b.renderOrder;
	
			} if ( a.z !== b.z ) {
	
				return b.z - a.z;
	
			} else {
	
				return a.id - b.id;
	
			}
	
		}
	
		function WebGLRenderList() {
	
			var opaque = [];
			var opaqueLastIndex = - 1;
	
			var transparent = [];
			var transparentLastIndex = - 1;
	
			function init() {
	
				opaqueLastIndex = - 1;
				transparentLastIndex = - 1;
	
			}
	
			function push( object, geometry, material, z, group ) {
	
				var array, index;
	
				// allocate the next position in the appropriate array
	
				if ( material.transparent ) {
	
					array = transparent;
					index = ++ transparentLastIndex;
	
				} else {
	
					array = opaque;
					index = ++ opaqueLastIndex;
	
				}
	
				// recycle existing render item or grow the array
	
				var renderItem = array[ index ];
	
				if ( renderItem ) {
	
					renderItem.id = object.id;
					renderItem.object = object;
					renderItem.geometry = geometry;
					renderItem.material = material;
					renderItem.program = material.program;
					renderItem.renderOrder = object.renderOrder;
					renderItem.z = z;
					renderItem.group = group;
	
				} else {
	
					renderItem = {
						id: object.id,
						object: object,
						geometry: geometry,
						material: material,
						program: material.program,
						renderOrder: object.renderOrder,
						z: z,
						group: group
					};
	
					// assert( index === array.length );
					array.push( renderItem );
	
				}
	
			}
	
			function finish() {
	
				opaque.length = opaqueLastIndex + 1;
				transparent.length = transparentLastIndex + 1;
	
			}
	
			function sort() {
	
				opaque.sort( painterSortStable );
				transparent.sort( reversePainterSortStable );
	
			}
	
			return {
				opaque: opaque,
				transparent: transparent,
	
				init: init,
				push: push,
				finish: finish,
	
				sort: sort
			};
	
		}
	
		function WebGLRenderLists() {
	
			var lists = {};
	
			function get( scene, camera ) {
	
				var hash = scene.id + ',' + camera.id;
				var list = lists[ hash ];
	
				if ( list === undefined ) {
	
					// console.log( 'THREE.WebGLRenderLists:', hash );
	
					list = new WebGLRenderList();
					lists[ hash ] = list;
	
				}
	
				return list;
	
			}
	
			function dispose() {
	
				lists = {};
	
			}
	
			return {
				get: get,
				dispose: dispose
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {
	
			var mode;
	
			function setMode( value ) {
	
				mode = value;
	
			}
	
			var type, bytesPerElement;
	
			function setIndex( value ) {
	
				type = value.type;
				bytesPerElement = value.bytesPerElement;
	
			}
	
			function render( start, count ) {
	
				gl.drawElements( mode, count, type, start * bytesPerElement );
	
				infoRender.calls ++;
				infoRender.vertices += count;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
	
			}
	
			function renderInstances( geometry, start, count ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
				extension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );
	
				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
	
			}
	
			//
	
			this.setMode = setMode;
			this.setIndex = setIndex;
			this.render = render;
			this.renderInstances = renderInstances;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLBufferRenderer( gl, extensions, infoRender ) {
	
			var mode;
	
			function setMode( value ) {
	
				mode = value;
	
			}
	
			function render( start, count ) {
	
				gl.drawArrays( mode, start, count );
	
				infoRender.calls ++;
				infoRender.vertices += count;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
	
			}
	
			function renderInstances( geometry, start, count ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
				var position = geometry.attributes.position;
	
				if ( position.isInterleavedBufferAttribute ) {
	
					count = position.data.count;
	
					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
				} else {
	
					extension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );
	
				}
	
				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
	
			}
	
			//
	
			this.setMode = setMode;
			this.render = render;
			this.renderInstances = renderInstances;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLGeometries( gl, attributes, infoMemory ) {
	
			var geometries = {};
			var wireframeAttributes = {};
	
			function onGeometryDispose( event ) {
	
				var geometry = event.target;
				var buffergeometry = geometries[ geometry.id ];
	
				if ( buffergeometry.index !== null ) {
	
					attributes.remove( buffergeometry.index );
	
				}
	
				for ( var name in buffergeometry.attributes ) {
	
					attributes.remove( buffergeometry.attributes[ name ] );
	
				}
	
				geometry.removeEventListener( 'dispose', onGeometryDispose );
	
				delete geometries[ geometry.id ];
	
				// TODO Remove duplicate code
	
				var attribute = wireframeAttributes[ geometry.id ];
	
				if ( attribute ) {
	
					attributes.remove( attribute );
					delete wireframeAttributes[ geometry.id ];
	
				}
	
				attribute = wireframeAttributes[ buffergeometry.id ];
	
				if ( attribute ) {
	
					attributes.remove( attribute );
					delete wireframeAttributes[ buffergeometry.id ];
	
				}
	
				//
	
				infoMemory.geometries --;
	
			}
	
			function get( object, geometry ) {
	
				var buffergeometry = geometries[ geometry.id ];
	
				if ( buffergeometry ) return buffergeometry;
	
				geometry.addEventListener( 'dispose', onGeometryDispose );
	
				if ( geometry.isBufferGeometry ) {
	
					buffergeometry = geometry;
	
				} else if ( geometry.isGeometry ) {
	
					if ( geometry._bufferGeometry === undefined ) {
	
						geometry._bufferGeometry = new BufferGeometry().setFromObject( object );
	
					}
	
					buffergeometry = geometry._bufferGeometry;
	
				}
	
				geometries[ geometry.id ] = buffergeometry;
	
				infoMemory.geometries ++;
	
				return buffergeometry;
	
			}
	
			function update( geometry ) {
	
				var index = geometry.index;
				var geometryAttributes = geometry.attributes;
	
				if ( index !== null ) {
	
					attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );
	
				}
	
				for ( var name in geometryAttributes ) {
	
					attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );
	
				}
	
				// morph targets
	
				var morphAttributes = geometry.morphAttributes;
	
				for ( var name in morphAttributes ) {
	
					var array = morphAttributes[ name ];
	
					for ( var i = 0, l = array.length; i < l; i ++ ) {
	
						attributes.update( array[ i ], gl.ARRAY_BUFFER );
	
					}
	
				}
	
			}
	
			function getWireframeAttribute( geometry ) {
	
				var attribute = wireframeAttributes[ geometry.id ];
	
				if ( attribute ) return attribute;
	
				var indices = [];
	
				var geometryIndex = geometry.index;
				var geometryAttributes = geometry.attributes;
	
				// console.time( 'wireframe' );
	
				if ( geometryIndex !== null ) {
	
					var array = geometryIndex.array;
	
					for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
						var a = array[ i + 0 ];
						var b = array[ i + 1 ];
						var c = array[ i + 2 ];
	
						indices.push( a, b, b, c, c, a );
	
					}
	
				} else {
	
					var array = geometryAttributes.position.array;
	
					for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
	
						var a = i + 0;
						var b = i + 1;
						var c = i + 2;
	
						indices.push( a, b, b, c, c, a );
	
					}
	
				}
	
				// console.timeEnd( 'wireframe' );
	
				attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
	
				attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );
	
				wireframeAttributes[ geometry.id ] = attribute;
	
				return attribute;
	
			}
	
			return {
	
				get: get,
				update: update,
	
				getWireframeAttribute: getWireframeAttribute
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLLights() {
	
			var lights = {};
	
			return {
	
				get: function ( light ) {
	
					if ( lights[ light.id ] !== undefined ) {
	
						return lights[ light.id ];
	
					}
	
					var uniforms;
	
					switch ( light.type ) {
	
						case 'DirectionalLight':
							uniforms = {
								direction: new Vector3(),
								color: new Color(),
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'SpotLight':
							uniforms = {
								position: new Vector3(),
								direction: new Vector3(),
								color: new Color(),
								distance: 0,
								coneCos: 0,
								penumbraCos: 0,
								decay: 0,
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'PointLight':
							uniforms = {
								position: new Vector3(),
								color: new Color(),
								distance: 0,
								decay: 0,
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'HemisphereLight':
							uniforms = {
								direction: new Vector3(),
								skyColor: new Color(),
								groundColor: new Color()
							};
							break;
	
						case 'RectAreaLight':
							uniforms = {
								color: new Color(),
								position: new Vector3(),
								halfWidth: new Vector3(),
								halfHeight: new Vector3()
								// TODO (abelnation): set RectAreaLight shadow uniforms
							};
							break;
	
					}
	
					lights[ light.id ] = uniforms;
	
					return uniforms;
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLObjects( gl, geometries, infoRender ) {
	
			var updateList = {};
	
			function update( object ) {
	
				var frame = infoRender.frame;
	
				var geometry = object.geometry;
				var buffergeometry = geometries.get( object, geometry );
	
				// Update once per frame
	
				if ( updateList[ buffergeometry.id ] !== frame ) {
	
					if ( geometry.isGeometry ) {
	
						buffergeometry.updateFromObject( object );
	
					}
	
					geometries.update( buffergeometry );
	
					updateList[ buffergeometry.id ] = frame;
	
				}
	
				return buffergeometry;
	
			}
	
			function clear() {
	
				updateList = {};
	
			}
	
			return {
	
				update: update,
				clear: clear
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function addLineNumbers( string ) {
	
			var lines = string.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
			}
	
			return lines.join( '\n' );
	
		}
	
		function WebGLShader( gl, type, string ) {
	
			var shader = gl.createShader( type );
	
			gl.shaderSource( shader, string );
			gl.compileShader( shader );
	
			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
	
				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	
			}
	
			if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
			return shader;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var programIdCount = 0;
	
		function getEncodingComponents( encoding ) {
	
			switch ( encoding ) {
	
				case LinearEncoding:
					return [ 'Linear','( value )' ];
				case sRGBEncoding:
					return [ 'sRGB','( value )' ];
				case RGBEEncoding:
					return [ 'RGBE','( value )' ];
				case RGBM7Encoding:
					return [ 'RGBM','( value, 7.0 )' ];
				case RGBM16Encoding:
					return [ 'RGBM','( value, 16.0 )' ];
				case RGBDEncoding:
					return [ 'RGBD','( value, 256.0 )' ];
				case GammaEncoding:
					return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
				default:
					throw new Error( 'unsupported encoding: ' + encoding );
	
			}
	
		}
	
		function getTexelDecodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";
	
		}
	
		function getTexelEncodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";
	
		}
	
		function getToneMappingFunction( functionName, toneMapping ) {
	
			var toneMappingName;
	
			switch ( toneMapping ) {
	
				case LinearToneMapping:
					toneMappingName = "Linear";
					break;
	
				case ReinhardToneMapping:
					toneMappingName = "Reinhard";
					break;
	
				case Uncharted2ToneMapping:
					toneMappingName = "Uncharted2";
					break;
	
				case CineonToneMapping:
					toneMappingName = "OptimizedCineon";
					break;
	
				default:
					throw new Error( 'unsupported toneMapping: ' + toneMapping );
	
			}
	
			return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
	
		}
	
		function generateExtensions( extensions, parameters, rendererExtensions ) {
	
			extensions = extensions || {};
	
			var chunks = [
				( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
			];
	
			return chunks.filter( filterEmptyLine ).join( '\n' );
	
		}
	
		function generateDefines( defines ) {
	
			var chunks = [];
	
			for ( var name in defines ) {
	
				var value = defines[ name ];
	
				if ( value === false ) continue;
	
				chunks.push( '#define ' + name + ' ' + value );
	
			}
	
			return chunks.join( '\n' );
	
		}
	
		function fetchAttributeLocations( gl, program, identifiers ) {
	
			var attributes = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveAttrib( program, i );
				var name = info.name;
	
				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
	
				attributes[ name ] = gl.getAttribLocation( program, name );
	
			}
	
			return attributes;
	
		}
	
		function filterEmptyLine( string ) {
	
			return string !== '';
	
		}
	
		function replaceLightNums( string, parameters ) {
	
			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
	
		}
	
		function parseIncludes( string ) {
	
			var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;
	
			function replace( match, include ) {
	
				var replace = ShaderChunk[ include ];
	
				if ( replace === undefined ) {
	
					throw new Error( 'Can not resolve #include <' + include + '>' );
	
				}
	
				return parseIncludes( replace );
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		function unrollLoops( string ) {
	
			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	
			function replace( match, start, end, snippet ) {
	
				var unroll = '';
	
				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
	
					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
	
				}
	
				return unroll;
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		function WebGLProgram( renderer, code, material, shader, parameters ) {
	
			var gl = renderer.context;
	
			var extensions = material.extensions;
			var defines = material.defines;
	
			var vertexShader = shader.vertexShader;
			var fragmentShader = shader.fragmentShader;
	
			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
			if ( parameters.shadowMapType === PCFShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
			} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
			}
	
			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
			if ( parameters.envMap ) {
	
				switch ( material.envMap.mapping ) {
	
					case CubeReflectionMapping:
					case CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;
	
					case CubeUVReflectionMapping:
					case CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;
	
					case EquirectangularReflectionMapping:
					case EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;
	
					case SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;
	
				}
	
				switch ( material.envMap.mapping ) {
	
					case CubeRefractionMapping:
					case EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;
	
				}
	
				switch ( material.combine ) {
	
					case MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;
	
					case MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;
	
					case AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;
	
				}
	
			}
	
			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
			// console.log( 'building new program ' );
	
			//
	
			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );
	
			var customDefines = generateDefines( defines );
	
			//
	
			var program = gl.createProgram();
	
			var prefixVertex, prefixFragment;
	
			if ( material.isRawShaderMaterial ) {
	
				prefixVertex = [
	
					customDefines,
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customExtensions,
					customDefines,
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			} else {
	
				prefixVertex = [
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + shader.name,
	
					customDefines,
	
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					'#define MAX_BONES ' + parameters.maxBones,
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
	
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
	
					'#ifdef USE_COLOR',
	
					'	attribute vec3 color;',
	
					'#endif',
	
					'#ifdef USE_MORPHTARGETS',
	
					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',
	
					'	#ifdef USE_MORPHNORMALS',
	
					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',
	
					'	#else',
	
					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',
	
					'	#endif',
	
					'#endif',
	
					'#ifdef USE_SKINNING',
	
					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',
	
					'#endif',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customExtensions,
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + shader.name,
	
					customDefines,
	
					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
					'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',
	
					parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',
	
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
	
					( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
					( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
					( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',
	
					parameters.dithering ? '#define DITHERING' : '',
	
					( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
					parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',
	
					parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			}
	
			vertexShader = parseIncludes( vertexShader );
			vertexShader = replaceLightNums( vertexShader, parameters );
	
			fragmentShader = parseIncludes( fragmentShader );
			fragmentShader = replaceLightNums( fragmentShader, parameters );
	
			if ( ! material.isShaderMaterial ) {
	
				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );
	
			}
	
			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;
	
			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );
	
			var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
	
			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );
	
			// Force a particular attribute to index 0.
	
			if ( material.index0AttributeName !== undefined ) {
	
				gl.bindAttribLocation( program, 0, material.index0AttributeName );
	
			} else if ( parameters.morphTargets === true ) {
	
				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );
	
			}
	
			gl.linkProgram( program );
	
			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );
	
			var runnable = true;
			var haveDiagnostics = true;
	
			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	
			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
	
				runnable = false;
	
				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	
			} else if ( programLog !== '' ) {
	
				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	
			} else if ( vertexLog === '' || fragmentLog === '' ) {
	
				haveDiagnostics = false;
	
			}
	
			if ( haveDiagnostics ) {
	
				this.diagnostics = {
	
					runnable: runnable,
					material: material,
	
					programLog: programLog,
	
					vertexShader: {
	
						log: vertexLog,
						prefix: prefixVertex
	
					},
	
					fragmentShader: {
	
						log: fragmentLog,
						prefix: prefixFragment
	
					}
	
				};
	
			}
	
			// clean up
	
			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );
	
			// set up caching for uniform locations
	
			var cachedUniforms;
	
			this.getUniforms = function() {
	
				if ( cachedUniforms === undefined ) {
	
					cachedUniforms =
						new WebGLUniforms( gl, program, renderer );
	
				}
	
				return cachedUniforms;
	
			};
	
			// set up caching for attribute locations
	
			var cachedAttributes;
	
			this.getAttributes = function() {
	
				if ( cachedAttributes === undefined ) {
	
					cachedAttributes = fetchAttributeLocations( gl, program );
	
				}
	
				return cachedAttributes;
	
			};
	
			// free resource
	
			this.destroy = function() {
	
				gl.deleteProgram( program );
				this.program = undefined;
	
			};
	
			// DEPRECATED
	
			Object.defineProperties( this, {
	
				uniforms: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();
	
					}
				},
	
				attributes: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();
	
					}
				}
	
			} );
	
	
			//
	
			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;
	
			return this;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLPrograms( renderer, capabilities ) {
	
			var programs = [];
	
			var shaderIDs = {
				MeshDepthMaterial: 'depth',
				MeshNormalMaterial: 'normal',
				MeshBasicMaterial: 'basic',
				MeshLambertMaterial: 'lambert',
				MeshPhongMaterial: 'phong',
				MeshToonMaterial: 'phong',
				MeshStandardMaterial: 'physical',
				MeshPhysicalMaterial: 'physical',
				LineBasicMaterial: 'basic',
				LineDashedMaterial: 'dashed',
				PointsMaterial: 'points'
			};
	
			var parameterNames = [
				"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
				"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
				"roughnessMap", "metalnessMap", "gradientMap",
				"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
				"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
				"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
				"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
				"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
				"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
				"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
			];
	
	
			function allocateBones( object ) {
	
				var skeleton = object.skeleton;
				var bones = skeleton.bones;
	
				if ( capabilities.floatVertexTextures ) {
	
					return 1024;
	
				} else {
	
					// default for when object is not specified
					// ( for example when prebuilding shader to be used with multiple objects )
					//
					//  - leave some extra space for other uniforms
					//  - limit here is ANGLE's 254 max uniform vectors
					//    (up to 54 should be safe)
	
					var nVertexUniforms = capabilities.maxVertexUniforms;
					var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
					var maxBones = Math.min( nVertexMatrices, bones.length );
	
					if ( maxBones < bones.length ) {
	
						console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
						return 0;
	
					}
	
					return maxBones;
	
				}
	
			}
	
			function getTextureEncodingFromMap( map, gammaOverrideLinear ) {
	
				var encoding;
	
				if ( ! map ) {
	
					encoding = LinearEncoding;
	
				} else if ( map.isTexture ) {
	
					encoding = map.encoding;
	
				} else if ( map.isWebGLRenderTarget ) {
	
					console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
					encoding = map.texture.encoding;
	
				}
	
				// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
				if ( encoding === LinearEncoding && gammaOverrideLinear ) {
	
					encoding = GammaEncoding;
	
				}
	
				return encoding;
	
			}
	
			this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {
	
				var shaderID = shaderIDs[ material.type ];
	
				// heuristics to create shader parameters according to lights in the scene
				// (not to blow over maxLights budget)
	
				var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
				var precision = renderer.getPrecision();
	
				if ( material.precision !== null ) {
	
					precision = capabilities.getMaxPrecision( material.precision );
	
					if ( precision !== material.precision ) {
	
						console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
	
					}
	
				}
	
				var currentRenderTarget = renderer.getRenderTarget();
	
				var parameters = {
	
					shaderID: shaderID,
	
					precision: precision,
					supportsVertexTextures: capabilities.vertexTextures,
					outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
					map: !! material.map,
					mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
					envMap: !! material.envMap,
					envMapMode: material.envMap && material.envMap.mapping,
					envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
					envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
					lightMap: !! material.lightMap,
					aoMap: !! material.aoMap,
					emissiveMap: !! material.emissiveMap,
					emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
					bumpMap: !! material.bumpMap,
					normalMap: !! material.normalMap,
					displacementMap: !! material.displacementMap,
					roughnessMap: !! material.roughnessMap,
					metalnessMap: !! material.metalnessMap,
					specularMap: !! material.specularMap,
					alphaMap: !! material.alphaMap,
	
					gradientMap: !! material.gradientMap,
	
					combine: material.combine,
	
					vertexColors: material.vertexColors,
	
					fog: !! fog,
					useFog: material.fog,
					fogExp: ( fog && fog.isFogExp2 ),
	
					flatShading: material.shading === FlatShading,
	
					sizeAttenuation: material.sizeAttenuation,
					logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	
					skinning: material.skinning && maxBones > 0,
					maxBones: maxBones,
					useVertexTexture: capabilities.floatVertexTextures,
	
					morphTargets: material.morphTargets,
					morphNormals: material.morphNormals,
					maxMorphTargets: renderer.maxMorphTargets,
					maxMorphNormals: renderer.maxMorphNormals,
	
					numDirLights: lights.directional.length,
					numPointLights: lights.point.length,
					numSpotLights: lights.spot.length,
					numRectAreaLights: lights.rectArea.length,
					numHemiLights: lights.hemi.length,
	
					numClippingPlanes: nClipPlanes,
					numClipIntersection: nClipIntersection,
	
					dithering: material.dithering,
	
					shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
					shadowMapType: renderer.shadowMap.type,
	
					toneMapping: renderer.toneMapping,
					physicallyCorrectLights: renderer.physicallyCorrectLights,
	
					premultipliedAlpha: material.premultipliedAlpha,
	
					alphaTest: material.alphaTest,
					doubleSided: material.side === DoubleSide,
					flipSided: material.side === BackSide,
	
					depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false
	
				};
	
				return parameters;
	
			};
	
			this.getProgramCode = function ( material, parameters ) {
	
				var array = [];
	
				if ( parameters.shaderID ) {
	
					array.push( parameters.shaderID );
	
				} else {
	
					array.push( material.fragmentShader );
					array.push( material.vertexShader );
	
				}
	
				if ( material.defines !== undefined ) {
	
					for ( var name in material.defines ) {
	
						array.push( name );
						array.push( material.defines[ name ] );
	
					}
	
				}
	
				for ( var i = 0; i < parameterNames.length; i ++ ) {
	
					array.push( parameters[ parameterNames[ i ] ] );
	
				}
	
				array.push( material.onBeforeCompile.toString() );
	
				array.push( renderer.gammaOutput );
	
				return array.join();
	
			};
	
			this.acquireProgram = function ( material, shader, parameters, code ) {
	
				var program;
	
				// Check if code has been already compiled
				for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
	
					var programInfo = programs[ p ];
	
					if ( programInfo.code === code ) {
	
						program = programInfo;
						++ program.usedTimes;
	
						break;
	
					}
	
				}
	
				if ( program === undefined ) {
	
					program = new WebGLProgram( renderer, code, material, shader, parameters );
					programs.push( program );
	
				}
	
				return program;
	
			};
	
			this.releaseProgram = function ( program ) {
	
				if ( -- program.usedTimes === 0 ) {
	
					// Remove from unordered set
					var i = programs.indexOf( program );
					programs[ i ] = programs[ programs.length - 1 ];
					programs.pop();
	
					// Free WebGL resources
					program.destroy();
	
				}
	
			};
	
			// Exposed for resource monitoring & error feedback via renderer.info:
			this.programs = programs;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, infoMemory ) {
	
			var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );
	
			//
	
			function clampToMaxSize( image, maxSize ) {
	
				if ( image.width > maxSize || image.height > maxSize ) {
	
					// Warning: Scaling through the canvas will only work with images that use
					// premultiplied alpha.
	
					var scale = maxSize / Math.max( image.width, image.height );
	
					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = Math.floor( image.width * scale );
					canvas.height = Math.floor( image.height * scale );
	
					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
	
					console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
					return canvas;
	
				}
	
				return image;
	
			}
	
			function isPowerOfTwo( image ) {
	
				return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );
	
			}
	
			function makePowerOfTwo( image ) {
	
				if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {
	
					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = _Math.nearestPowerOfTwo( image.width );
					canvas.height = _Math.nearestPowerOfTwo( image.height );
	
					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, canvas.width, canvas.height );
	
					console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
					return canvas;
	
				}
	
				return image;
	
			}
	
			function textureNeedsPowerOfTwo( texture ) {
	
				return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
					( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );
	
			}
	
			function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {
	
				return texture.generateMipmaps && isPowerOfTwo &&
					texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
	
			}
	
			// Fallback filters for non-power-of-2 textures
	
			function filterFallback( f ) {
	
				if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {
	
					return _gl.NEAREST;
	
				}
	
				return _gl.LINEAR;
	
			}
	
			//
	
			function onTextureDispose( event ) {
	
				var texture = event.target;
	
				texture.removeEventListener( 'dispose', onTextureDispose );
	
				deallocateTexture( texture );
	
				infoMemory.textures --;
	
	
			}
	
			function onRenderTargetDispose( event ) {
	
				var renderTarget = event.target;
	
				renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
				deallocateRenderTarget( renderTarget );
	
				infoMemory.textures --;
	
			}
	
			//
	
			function deallocateTexture( texture ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.image && textureProperties.__image__webglTextureCube ) {
	
					// cube texture
	
					_gl.deleteTexture( textureProperties.__image__webglTextureCube );
	
				} else {
	
					// 2D texture
	
					if ( textureProperties.__webglInit === undefined ) return;
	
					_gl.deleteTexture( textureProperties.__webglTexture );
	
				}
	
				// remove all webgl properties
				properties.remove( texture );
	
			}
	
			function deallocateRenderTarget( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );
	
				if ( ! renderTarget ) return;
	
				if ( textureProperties.__webglTexture !== undefined ) {
	
					_gl.deleteTexture( textureProperties.__webglTexture );
	
				}
	
				if ( renderTarget.depthTexture ) {
	
					renderTarget.depthTexture.dispose();
	
				}
	
				if ( renderTarget.isWebGLRenderTargetCube ) {
	
					for ( var i = 0; i < 6; i ++ ) {
	
						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
						if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
	
					}
	
				} else {
	
					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
	
				}
	
				properties.remove( renderTarget.texture );
				properties.remove( renderTarget );
	
			}
	
			//
	
	
	
			function setTexture2D( texture, slot ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
					var image = texture.image;
	
					if ( image === undefined ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
	
					} else if ( image.complete === false ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
	
					} else {
	
						uploadTexture( textureProperties, texture, slot );
						return;
	
					}
	
				}
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
			}
	
			function setTextureCube( texture, slot ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.image.length === 6 ) {
	
					if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
						if ( ! textureProperties.__image__webglTextureCube ) {
	
							texture.addEventListener( 'dispose', onTextureDispose );
	
							textureProperties.__image__webglTextureCube = _gl.createTexture();
	
							infoMemory.textures ++;
	
						}
	
						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
						_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
						var isCompressed = ( texture && texture.isCompressedTexture );
						var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );
	
						var cubeImage = [];
	
						for ( var i = 0; i < 6; i ++ ) {
	
							if ( ! isCompressed && ! isDataTexture ) {
	
								cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
	
							} else {
	
								cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
							}
	
						}
	
						var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = paramThreeToGL( texture.format ),
						glType = paramThreeToGL( texture.type );
	
						setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );
	
						for ( var i = 0; i < 6; i ++ ) {
	
							if ( ! isCompressed ) {
	
								if ( isDataTexture ) {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
								} else {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
								}
	
							} else {
	
								var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
								for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
									mipmap = mipmaps[ j ];
	
									if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
										if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
											state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
										} else {
	
											console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );
	
										}
	
									} else {
	
										state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
									}
	
								}
	
							}
	
						}
	
						if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {
	
							_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
						}
	
						textureProperties.__version = texture.version;
	
						if ( texture.onUpdate ) texture.onUpdate( texture );
	
					} else {
	
						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
					}
	
				}
	
			}
	
			function setTextureCubeDynamic( texture, slot ) {
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
	
			}
	
			function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {
	
				var extension;
	
				if ( isPowerOfTwoImage ) {
	
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
				} else {
	
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
					if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );
	
					}
	
					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
					if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );
	
					}
	
				}
	
				extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension ) {
	
					if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
					if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;
	
					if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
	
						_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
						properties.get( texture ).__currentAnisotropy = texture.anisotropy;
	
					}
	
				}
	
			}
	
			function uploadTexture( textureProperties, texture, slot ) {
	
				if ( textureProperties.__webglInit === undefined ) {
	
					textureProperties.__webglInit = true;
	
					texture.addEventListener( 'dispose', onTextureDispose );
	
					textureProperties.__webglTexture = _gl.createTexture();
	
					infoMemory.textures ++;
	
				}
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
				var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
	
				if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {
	
					image = makePowerOfTwo( image );
	
				}
	
				var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );
	
				setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );
	
				var mipmap, mipmaps = texture.mipmaps;
	
				if ( texture.isDepthTexture ) {
	
					// populate depth texture with dummy data
	
					var internalFormat = _gl.DEPTH_COMPONENT;
	
					if ( texture.type === FloatType ) {
	
						if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
						internalFormat = _gl.DEPTH_COMPONENT32F;
	
					} else if ( _isWebGL2 ) {
	
						// WebGL 2.0 requires signed internalformat for glTexImage2D
						internalFormat = _gl.DEPTH_COMPONENT16;
	
					}
	
					if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {
	
						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {
	
						        console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );
	
							texture.type = UnsignedShortType;
							glType = paramThreeToGL( texture.type );
	
						}
	
					}
	
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.format === DepthStencilFormat ) {
	
						internalFormat = _gl.DEPTH_STENCIL;
	
						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedInt248Type ) {
	
							console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );
	
							texture.type = UnsignedInt248Type;
							glType = paramThreeToGL( texture.type );
	
						}
	
					}
	
					state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );
	
				} else if ( texture.isDataTexture ) {
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
					}
	
				} else if ( texture.isCompressedTexture ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
	
						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
							if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
								state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
							} else {
	
								console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );
	
							}
	
						} else {
	
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
					}
	
				} else {
	
					// regular Texture (image, video, canvas)
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );
	
					}
	
				}
	
				if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				textureProperties.__version = texture.version;
	
				if ( texture.onUpdate ) texture.onUpdate( texture );
	
			}
	
			// Render targets
	
			// Setup storage for target texture and bind it to correct framebuffer
			function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {
	
				var glFormat = paramThreeToGL( renderTarget.texture.format );
				var glType = paramThreeToGL( renderTarget.texture.type );
				state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
			function setupRenderBufferStorage( renderbuffer, renderTarget ) {
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
				if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
				} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
				} else {
	
					// FIXME: We don't support !depth !stencil
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
				}
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
	
			}
	
			// Setup resources for a Depth Texture for a FBO (needs an extension)
			function setupDepthTexture( framebuffer, renderTarget ) {
	
				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
				if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {
	
					throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
	
				}
	
				// upload an empty depth texture with framebuffer size
				if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
						renderTarget.depthTexture.image.width !== renderTarget.width ||
						renderTarget.depthTexture.image.height !== renderTarget.height ) {
					renderTarget.depthTexture.image.width = renderTarget.width;
					renderTarget.depthTexture.image.height = renderTarget.height;
					renderTarget.depthTexture.needsUpdate = true;
				}
	
				setTexture2D( renderTarget.depthTexture, 0 );
	
				var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
	
				if ( renderTarget.depthTexture.format === DepthFormat ) {
	
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
	
				} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {
	
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
	
				} else {
	
					throw new Error('Unknown depthTexture format')
	
				}
	
			}
	
			// Setup GL resources for a non-texture depth buffer
			function setupDepthRenderbuffer( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
	
				var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
	
				if ( renderTarget.depthTexture ) {
	
					if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');
	
					setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
	
				} else {
	
					if ( isCube ) {
	
						renderTargetProperties.__webglDepthbuffer = [];
	
						for ( var i = 0; i < 6; i ++ ) {
	
							_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
							renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
	
						}
	
					} else {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
	
					}
	
				}
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			// Set up GL resources for the render target
			function setupRenderTarget( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );
	
				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				infoMemory.textures ++;
	
				var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
	
				// Setup framebuffer
	
				if ( isCube ) {
	
					renderTargetProperties.__webglFramebuffer = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
	
					}
	
				} else {
	
					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	
				}
	
				// Setup color buffer
	
				if ( isCube ) {
	
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
	
					}
	
					if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
				} else {
	
					state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );
	
					if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );
					state.bindTexture( _gl.TEXTURE_2D, null );
	
				}
	
				// Setup depth and stencil buffers
	
				if ( renderTarget.depthBuffer ) {
	
					setupDepthRenderbuffer( renderTarget );
	
				}
	
			}
	
			function updateRenderTargetMipmap( renderTarget ) {
	
				var texture = renderTarget.texture;
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
	
				if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {
	
					var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					var webglTexture = properties.get( texture ).__webglTexture;
	
					state.bindTexture( target, webglTexture );
					_gl.generateMipmap( target );
					state.bindTexture( target, null );
	
				}
	
			}
	
			this.setTexture2D = setTexture2D;
			this.setTextureCube = setTextureCube;
			this.setTextureCubeDynamic = setTextureCubeDynamic;
			this.setupRenderTarget = setupRenderTarget;
			this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	
		}
	
		/**
		 * @author fordacious / fordacious.github.io
		 */
	
		function WebGLProperties() {
	
			var properties = {};
	
			function get( object ) {
	
				var uuid = object.uuid;
				var map = properties[ uuid ];
	
				if ( map === undefined ) {
	
					map = {};
					properties[ uuid ] = map;
	
				}
	
				return map;
	
			}
	
			function remove( object ) {
	
				delete properties[ object.uuid ];
	
			}
	
			function clear() {
	
				properties = {};
	
			}
	
			return {
				get: get,
				remove: remove,
				clear: clear
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLState( gl, extensions, paramThreeToGL ) {
	
			function ColorBuffer() {
	
				var locked = false;
	
				var color = new Vector4();
				var currentColorMask = null;
				var currentColorClear = new Vector4();
	
				return {
	
					setMask: function ( colorMask ) {
	
						if ( currentColorMask !== colorMask && ! locked ) {
	
							gl.colorMask( colorMask, colorMask, colorMask, colorMask );
							currentColorMask = colorMask;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( r, g, b, a, premultipliedAlpha ) {
	
						if ( premultipliedAlpha === true ) {
	
							r *= a; g *= a; b *= a;
	
						}
	
						color.set( r, g, b, a );
	
						if ( currentColorClear.equals( color ) === false ) {
	
							gl.clearColor( r, g, b, a );
							currentColorClear.copy( color );
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentColorMask = null;
						currentColorClear.set( 0, 0, 0, 1 );
	
					}
	
				};
	
			}
	
			function DepthBuffer() {
	
				var locked = false;
	
				var currentDepthMask = null;
				var currentDepthFunc = null;
				var currentDepthClear = null;
	
				return {
	
					setTest: function ( depthTest ) {
	
						if ( depthTest ) {
	
							enable( gl.DEPTH_TEST );
	
						} else {
	
							disable( gl.DEPTH_TEST );
	
						}
	
					},
	
					setMask: function ( depthMask ) {
	
						if ( currentDepthMask !== depthMask && ! locked ) {
	
							gl.depthMask( depthMask );
							currentDepthMask = depthMask;
	
						}
	
					},
	
					setFunc: function ( depthFunc ) {
	
						if ( currentDepthFunc !== depthFunc ) {
	
							if ( depthFunc ) {
	
								switch ( depthFunc ) {
	
									case NeverDepth:
	
										gl.depthFunc( gl.NEVER );
										break;
	
									case AlwaysDepth:
	
										gl.depthFunc( gl.ALWAYS );
										break;
	
									case LessDepth:
	
										gl.depthFunc( gl.LESS );
										break;
	
									case LessEqualDepth:
	
										gl.depthFunc( gl.LEQUAL );
										break;
	
									case EqualDepth:
	
										gl.depthFunc( gl.EQUAL );
										break;
	
									case GreaterEqualDepth:
	
										gl.depthFunc( gl.GEQUAL );
										break;
	
									case GreaterDepth:
	
										gl.depthFunc( gl.GREATER );
										break;
	
									case NotEqualDepth:
	
										gl.depthFunc( gl.NOTEQUAL );
										break;
	
									default:
	
										gl.depthFunc( gl.LEQUAL );
	
								}
	
							} else {
	
								gl.depthFunc( gl.LEQUAL );
	
							}
	
							currentDepthFunc = depthFunc;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( depth ) {
	
						if ( currentDepthClear !== depth ) {
	
							gl.clearDepth( depth );
							currentDepthClear = depth;
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentDepthMask = null;
						currentDepthFunc = null;
						currentDepthClear = null;
	
					}
	
				};
	
			}
	
			function StencilBuffer() {
	
				var locked = false;
	
				var currentStencilMask = null;
				var currentStencilFunc = null;
				var currentStencilRef = null;
				var currentStencilFuncMask = null;
				var currentStencilFail = null;
				var currentStencilZFail = null;
				var currentStencilZPass = null;
				var currentStencilClear = null;
	
				return {
	
					setTest: function ( stencilTest ) {
	
						if ( stencilTest ) {
	
							enable( gl.STENCIL_TEST );
	
						} else {
	
							disable( gl.STENCIL_TEST );
	
						}
	
					},
	
					setMask: function ( stencilMask ) {
	
						if ( currentStencilMask !== stencilMask && ! locked ) {
	
							gl.stencilMask( stencilMask );
							currentStencilMask = stencilMask;
	
						}
	
					},
	
					setFunc: function ( stencilFunc, stencilRef, stencilMask ) {
	
						if ( currentStencilFunc !== stencilFunc ||
						     currentStencilRef 	!== stencilRef 	||
						     currentStencilFuncMask !== stencilMask ) {
	
							gl.stencilFunc( stencilFunc, stencilRef, stencilMask );
	
							currentStencilFunc = stencilFunc;
							currentStencilRef = stencilRef;
							currentStencilFuncMask = stencilMask;
	
						}
	
					},
	
					setOp: function ( stencilFail, stencilZFail, stencilZPass ) {
	
						if ( currentStencilFail	 !== stencilFail 	||
						     currentStencilZFail !== stencilZFail ||
						     currentStencilZPass !== stencilZPass ) {
	
							gl.stencilOp( stencilFail, stencilZFail, stencilZPass );
	
							currentStencilFail = stencilFail;
							currentStencilZFail = stencilZFail;
							currentStencilZPass = stencilZPass;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( stencil ) {
	
						if ( currentStencilClear !== stencil ) {
	
							gl.clearStencil( stencil );
							currentStencilClear = stencil;
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentStencilMask = null;
						currentStencilFunc = null;
						currentStencilRef = null;
						currentStencilFuncMask = null;
						currentStencilFail = null;
						currentStencilZFail = null;
						currentStencilZPass = null;
						currentStencilClear = null;
	
					}
	
				};
	
			}
	
			//
	
			var colorBuffer = new ColorBuffer();
			var depthBuffer = new DepthBuffer();
			var stencilBuffer = new StencilBuffer();
	
			var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var newAttributes = new Uint8Array( maxVertexAttributes );
			var enabledAttributes = new Uint8Array( maxVertexAttributes );
			var attributeDivisors = new Uint8Array( maxVertexAttributes );
	
			var capabilities = {};
	
			var compressedTextureFormats = null;
	
			var currentBlending = null;
			var currentBlendEquation = null;
			var currentBlendSrc = null;
			var currentBlendDst = null;
			var currentBlendEquationAlpha = null;
			var currentBlendSrcAlpha = null;
			var currentBlendDstAlpha = null;
			var currentPremultipledAlpha = false;
	
			var currentFlipSided = null;
			var currentCullFace = null;
	
			var currentLineWidth = null;
	
			var currentPolygonOffsetFactor = null;
			var currentPolygonOffsetUnits = null;
	
			var currentScissorTest = null;
	
			var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );
	
			var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
			var lineWidthAvailable = parseFloat( version ) >= 1.0;
	
			var currentTextureSlot = null;
			var currentBoundTextures = {};
	
			var currentScissor = new Vector4();
			var currentViewport = new Vector4();
	
			function createTexture( type, target, count ) {
	
				var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
				var texture = gl.createTexture();
	
				gl.bindTexture( type, texture );
				gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
				gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
	
				for ( var i = 0; i < count; i ++ ) {
	
					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );
	
				}
	
				return texture;
	
			}
	
			var emptyTextures = {};
			emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
			emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
	
			//
	
			function init() {
	
				colorBuffer.setClear( 0, 0, 0, 1 );
				depthBuffer.setClear( 1 );
				stencilBuffer.setClear( 0 );
	
				enable( gl.DEPTH_TEST );
				depthBuffer.setFunc( LessEqualDepth );
	
				setFlipSided( false );
				setCullFace( CullFaceBack );
				enable( gl.CULL_FACE );
	
				enable( gl.BLEND );
				setBlending( NormalBlending );
	
			}
	
			function initAttributes() {
	
				for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
					newAttributes[ i ] = 0;
	
				}
	
			}
	
			function enableAttribute( attribute ) {
	
				newAttributes[ attribute ] = 1;
	
				if ( enabledAttributes[ attribute ] === 0 ) {
	
					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;
	
				}
	
				if ( attributeDivisors[ attribute ] !== 0 ) {
	
					var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
					extension.vertexAttribDivisorANGLE( attribute, 0 );
					attributeDivisors[ attribute ] = 0;
	
				}
	
			}
	
			function enableAttributeAndDivisor( attribute, meshPerAttribute ) {
	
				newAttributes[ attribute ] = 1;
	
				if ( enabledAttributes[ attribute ] === 0 ) {
	
					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;
	
				}
	
				if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
	
					var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
					extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
					attributeDivisors[ attribute ] = meshPerAttribute;
	
				}
	
			}
	
			function disableUnusedAttributes() {
	
				for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {
	
					if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;
	
					}
	
				}
	
			}
	
			function enable( id ) {
	
				if ( capabilities[ id ] !== true ) {
	
					gl.enable( id );
					capabilities[ id ] = true;
	
				}
	
			}
	
			function disable( id ) {
	
				if ( capabilities[ id ] !== false ) {
	
					gl.disable( id );
					capabilities[ id ] = false;
	
				}
	
			}
	
			function getCompressedTextureFormats() {
	
				if ( compressedTextureFormats === null ) {
	
					compressedTextureFormats = [];
	
					if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {
	
						var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
	
						for ( var i = 0; i < formats.length; i ++ ) {
	
							compressedTextureFormats.push( formats[ i ] );
	
						}
	
					}
	
				}
	
				return compressedTextureFormats;
	
			}
	
			function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
	
				if ( blending !== NoBlending ) {
	
					enable( gl.BLEND );
	
				} else {
	
					disable( gl.BLEND );
	
				}
	
				if ( ( blending !== CustomBlending ) && ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) ) {
	
					if ( blending === AdditiveBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
	
						}
	
					} else if ( blending === SubtractiveBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
	
						}
	
					} else if ( blending === MultiplyBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
	
						}
	
					} else {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
						} else {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
						}
	
					}
	
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
	
				}
	
				if ( blending === CustomBlending ) {
	
					blendEquationAlpha = blendEquationAlpha || blendEquation;
					blendSrcAlpha = blendSrcAlpha || blendSrc;
					blendDstAlpha = blendDstAlpha || blendDst;
	
					if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
						gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );
	
						currentBlendEquation = blendEquation;
						currentBlendEquationAlpha = blendEquationAlpha;
	
					}
	
					if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
						gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
	
						currentBlendSrc = blendSrc;
						currentBlendDst = blendDst;
						currentBlendSrcAlpha = blendSrcAlpha;
						currentBlendDstAlpha = blendDstAlpha;
	
					}
	
				} else {
	
					currentBlendEquation = null;
					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendEquationAlpha = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
	
				}
	
			}
	
			function setMaterial( material ) {
	
				material.side === DoubleSide
					? disable( gl.CULL_FACE )
					: enable( gl.CULL_FACE );
	
				setFlipSided( material.side === BackSide );
	
				material.transparent === true
					? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
					: setBlending( NoBlending );
	
				depthBuffer.setFunc( material.depthFunc );
				depthBuffer.setTest( material.depthTest );
				depthBuffer.setMask( material.depthWrite );
				colorBuffer.setMask( material.colorWrite );
	
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
			}
	
			//
	
			function setFlipSided( flipSided ) {
	
				if ( currentFlipSided !== flipSided ) {
	
					if ( flipSided ) {
	
						gl.frontFace( gl.CW );
	
					} else {
	
						gl.frontFace( gl.CCW );
	
					}
	
					currentFlipSided = flipSided;
	
				}
	
			}
	
			function setCullFace( cullFace ) {
	
				if ( cullFace !== CullFaceNone ) {
	
					enable( gl.CULL_FACE );
	
					if ( cullFace !== currentCullFace ) {
	
						if ( cullFace === CullFaceBack ) {
	
							gl.cullFace( gl.BACK );
	
						} else if ( cullFace === CullFaceFront ) {
	
							gl.cullFace( gl.FRONT );
	
						} else {
	
							gl.cullFace( gl.FRONT_AND_BACK );
	
						}
	
					}
	
				} else {
	
					disable( gl.CULL_FACE );
	
				}
	
				currentCullFace = cullFace;
	
			}
	
			function setLineWidth( width ) {
	
				if ( width !== currentLineWidth ) {
	
					if ( lineWidthAvailable ) gl.lineWidth( width );
	
					currentLineWidth = width;
	
				}
	
			}
	
			function setPolygonOffset( polygonOffset, factor, units ) {
	
				if ( polygonOffset ) {
	
					enable( gl.POLYGON_OFFSET_FILL );
	
					if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
	
						gl.polygonOffset( factor, units );
	
						currentPolygonOffsetFactor = factor;
						currentPolygonOffsetUnits = units;
	
					}
	
				} else {
	
					disable( gl.POLYGON_OFFSET_FILL );
	
				}
	
			}
	
			function getScissorTest() {
	
				return currentScissorTest;
	
			}
	
			function setScissorTest( scissorTest ) {
	
				currentScissorTest = scissorTest;
	
				if ( scissorTest ) {
	
					enable( gl.SCISSOR_TEST );
	
				} else {
	
					disable( gl.SCISSOR_TEST );
	
				}
	
			}
	
			// texture
	
			function activeTexture( webglSlot ) {
	
				if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
	
				if ( currentTextureSlot !== webglSlot ) {
	
					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;
	
				}
	
			}
	
			function bindTexture( webglType, webglTexture ) {
	
				if ( currentTextureSlot === null ) {
	
					activeTexture();
	
				}
	
				var boundTexture = currentBoundTextures[ currentTextureSlot ];
	
				if ( boundTexture === undefined ) {
	
					boundTexture = { type: undefined, texture: undefined };
					currentBoundTextures[ currentTextureSlot ] = boundTexture;
	
				}
	
				if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
	
					gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
	
					boundTexture.type = webglType;
					boundTexture.texture = webglTexture;
	
				}
	
			}
	
			function compressedTexImage2D() {
	
				try {
	
					gl.compressedTexImage2D.apply( gl, arguments );
	
				} catch ( error ) {
	
					console.error( 'THREE.WebGLState:', error );
	
				}
	
			}
	
			function texImage2D() {
	
				try {
	
					gl.texImage2D.apply( gl, arguments );
	
				} catch ( error ) {
	
					console.error( 'THREE.WebGLState:', error );
	
				}
	
			}
	
			//
	
			function scissor( scissor ) {
	
				if ( currentScissor.equals( scissor ) === false ) {
	
					gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
					currentScissor.copy( scissor );
	
				}
	
			}
	
			function viewport( viewport ) {
	
				if ( currentViewport.equals( viewport ) === false ) {
	
					gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
					currentViewport.copy( viewport );
	
				}
	
			}
	
			//
	
			function reset() {
	
				for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
					if ( enabledAttributes[ i ] === 1 ) {
	
						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;
	
					}
	
				}
	
				capabilities = {};
	
				compressedTextureFormats = null;
	
				currentTextureSlot = null;
				currentBoundTextures = {};
	
				currentBlending = null;
	
				currentFlipSided = null;
				currentCullFace = null;
	
				colorBuffer.reset();
				depthBuffer.reset();
				stencilBuffer.reset();
	
			}
	
			return {
	
				buffers: {
					color: colorBuffer,
					depth: depthBuffer,
					stencil: stencilBuffer
				},
	
				init: init,
				initAttributes: initAttributes,
				enableAttribute: enableAttribute,
				enableAttributeAndDivisor: enableAttributeAndDivisor,
				disableUnusedAttributes: disableUnusedAttributes,
				enable: enable,
				disable: disable,
				getCompressedTextureFormats: getCompressedTextureFormats,
	
				setBlending: setBlending,
				setMaterial: setMaterial,
	
				setFlipSided: setFlipSided,
				setCullFace: setCullFace,
	
				setLineWidth: setLineWidth,
				setPolygonOffset: setPolygonOffset,
	
				getScissorTest: getScissorTest,
				setScissorTest: setScissorTest,
	
				activeTexture: activeTexture,
				bindTexture: bindTexture,
				compressedTexImage2D: compressedTexImage2D,
				texImage2D: texImage2D,
	
				scissor: scissor,
				viewport: viewport,
	
				reset: reset
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLCapabilities( gl, extensions, parameters ) {
	
			var maxAnisotropy;
	
			function getMaxAnisotropy() {
	
				if ( maxAnisotropy !== undefined ) return maxAnisotropy;
	
				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension !== null ) {
	
					maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	
				} else {
	
					maxAnisotropy = 0;
	
				}
	
				return maxAnisotropy;
	
			}
	
			function getMaxPrecision( precision ) {
	
				if ( precision === 'highp' ) {
	
					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {
	
						return 'highp';
	
					}
	
					precision = 'mediump';
	
				}
	
				if ( precision === 'mediump' ) {
	
					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {
	
						return 'mediump';
	
					}
	
				}
	
				return 'lowp';
	
			}
	
			var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
			var maxPrecision = getMaxPrecision( precision );
	
			if ( maxPrecision !== precision ) {
	
				console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
				precision = maxPrecision;
	
			}
	
			var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );
	
			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
			var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
			var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
			var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
			var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
			var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
			var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
	
			var vertexTextures = maxVertexTextures > 0;
			var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
			var floatVertexTextures = vertexTextures && floatFragmentTextures;
	
			return {
	
				getMaxAnisotropy: getMaxAnisotropy,
				getMaxPrecision: getMaxPrecision,
	
				precision: precision,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
	
				maxTextures: maxTextures,
				maxVertexTextures: maxVertexTextures,
				maxTextureSize: maxTextureSize,
				maxCubemapSize: maxCubemapSize,
	
				maxAttributes: maxAttributes,
				maxVertexUniforms: maxVertexUniforms,
				maxVaryings: maxVaryings,
				maxFragmentUniforms: maxFragmentUniforms,
	
				vertexTextures: vertexTextures,
				floatFragmentTextures: floatFragmentTextures,
				floatVertexTextures: floatVertexTextures
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ArrayCamera( array ) {
	
			PerspectiveCamera.call( this );
	
			this.cameras = array || [];
	
		}
	
		ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {
	
			constructor: ArrayCamera,
	
			isArrayCamera: true
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebVRManager( renderer ) {
	
			var scope = this;
	
			var device = null;
			var frameData = null;
	
			if ( 'VRFrameData' in window ) {
	
				frameData = new window.VRFrameData();
	
			}
	
			var matrixWorldInverse = new Matrix4();
	
			var standingMatrix = new Matrix4();
			var standingMatrixInverse = new Matrix4();
	
			var cameraL = new PerspectiveCamera();
			cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
			cameraL.layers.enable( 1 );
	
			var cameraR = new PerspectiveCamera();
			cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
			cameraR.layers.enable( 2 );
	
			var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
			cameraVR.layers.enable( 1 );
			cameraVR.layers.enable( 2 );
	
			//
	
			var currentSize, currentPixelRatio;
	
			function onVRDisplayPresentChange() {
	
				if ( device.isPresenting ) {
	
					var eyeParameters = device.getEyeParameters( 'left' );
					var renderWidth = eyeParameters.renderWidth;
					var renderHeight = eyeParameters.renderHeight;
	
					currentPixelRatio = renderer.getPixelRatio();
					currentSize = renderer.getSize();
	
					renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );
	
				} else if ( scope.enabled ) {
	
					renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );
	
				}
	
			}
	
			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );
	
			//
	
			this.enabled = false;
			this.standing = false;
	
			this.getDevice = function () {
	
				return device;
	
			};
	
			this.setDevice = function ( value ) {
	
				if ( value !== undefined ) device = value;
	
			};
	
			this.getCamera = function ( camera ) {
	
				if ( device === null ) return camera;
	
				device.depthNear = camera.near;
				device.depthFar = camera.far;
	
				device.getFrameData( frameData );
	
				//
	
				var pose = frameData.pose;
	
				if ( pose.position !== null ) {
	
					camera.position.fromArray( pose.position );
	
				} else {
	
					camera.position.set( 0, 0, 0 );
	
				}
	
				if ( pose.orientation !== null ) {
	
					camera.quaternion.fromArray( pose.orientation );
	
				}
	
				camera.updateMatrixWorld();
	
				var stageParameters = device.stageParameters;
	
				if ( this.standing && stageParameters ) {
	
					standingMatrix.fromArray( stageParameters.sittingToStandingTransform );
					standingMatrixInverse.getInverse( standingMatrix );
	
					camera.matrixWorld.multiply( standingMatrix );
					camera.matrixWorldInverse.multiply( standingMatrixInverse );
	
				}
	
				if ( device.isPresenting === false ) return camera;
	
				//
	
				cameraVR.matrixWorld.copy( camera.matrixWorld );
				cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );
	
				cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
				cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );
	
				if ( this.standing && stageParameters ) {
	
					cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
					cameraR.matrixWorldInverse.multiply( standingMatrixInverse );
	
				}
	
				var parent = camera.parent;
	
				if ( parent !== null ) {
	
					matrixWorldInverse.getInverse( parent.matrixWorld );
	
					cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
					cameraR.matrixWorldInverse.multiply( matrixWorldInverse );
	
				}
	
				// envMap and Mirror needs camera.matrixWorld
	
				cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
				cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );
	
				cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
				cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );
	
				// HACK @mrdoob
				// https://github.com/w3c/webvr/issues/203
	
				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );
	
				//
	
				var layers = device.getLayers();
	
				if ( layers.length ) {
	
					var layer = layers[ 0 ];
	
					if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {
	
						cameraL.bounds.fromArray( layer.leftBounds );
	
					}
	
					if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {
	
						cameraR.bounds.fromArray( layer.rightBounds );
	
					}
	
				}
	
				return cameraVR;
	
			};
	
			this.getStandingMatrix = function () {
	
				return standingMatrix;
	
			};
	
			this.submitFrame = function () {
	
				if ( device && device.isPresenting ) device.submitFrame();
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLExtensions( gl ) {
	
			var extensions = {};
	
			return {
	
				get: function ( name ) {
	
					if ( extensions[ name ] !== undefined ) {
	
						return extensions[ name ];
	
					}
	
					var extension;
	
					switch ( name ) {
	
						case 'WEBGL_depth_texture':
							extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
							break;
	
						case 'EXT_texture_filter_anisotropic':
							extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
							break;
	
						case 'WEBGL_compressed_texture_s3tc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
							break;
	
						case 'WEBGL_compressed_texture_pvrtc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
							break;
	
						case 'WEBGL_compressed_texture_etc1':
							extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
							break;
	
						default:
							extension = gl.getExtension( name );
	
					}
	
					if ( extension === null ) {
	
						console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
					}
	
					extensions[ name ] = extension;
	
					return extension;
	
				}
	
			};
	
		}
	
		/**
		 * @author tschw
		 */
	
		function WebGLClipping() {
	
			var scope = this,
	
				globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false,
	
				plane = new Plane(),
				viewNormalMatrix = new Matrix3(),
	
				uniform = { value: null, needsUpdate: false };
	
			this.uniform = uniform;
			this.numPlanes = 0;
			this.numIntersection = 0;
	
			this.init = function( planes, enableLocalClipping, camera ) {
	
				var enabled =
					planes.length !== 0 ||
					enableLocalClipping ||
					// enable state of previous frame - the clipping code has to
					// run another frame in order to reset the state:
					numGlobalPlanes !== 0 ||
					localClippingEnabled;
	
				localClippingEnabled = enableLocalClipping;
	
				globalState = projectPlanes( planes, camera, 0 );
				numGlobalPlanes = planes.length;
	
				return enabled;
	
			};
	
			this.beginShadows = function() {
	
				renderingShadows = true;
				projectPlanes( null );
	
			};
	
			this.endShadows = function() {
	
				renderingShadows = false;
				resetGlobalState();
	
			};
	
			this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {
	
				if ( ! localClippingEnabled ||
						planes === null || planes.length === 0 ||
						renderingShadows && ! clipShadows ) {
					// there's no local clipping
	
					if ( renderingShadows ) {
						// there's no global clipping
	
						projectPlanes( null );
	
					} else {
	
						resetGlobalState();
					}
	
				} else {
	
					var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4,
	
						dstArray = cache.clippingState || null;
	
					uniform.value = dstArray; // ensure unique state
	
					dstArray = projectPlanes( planes, camera, lGlobal, fromCache );
	
					for ( var i = 0; i !== lGlobal; ++ i ) {
	
						dstArray[ i ] = globalState[ i ];
	
					}
	
					cache.clippingState = dstArray;
					this.numIntersection = clipIntersection ? this.numPlanes : 0;
					this.numPlanes += nGlobal;
	
				}
	
	
			};
	
			function resetGlobalState() {
	
				if ( uniform.value !== globalState ) {
	
					uniform.value = globalState;
					uniform.needsUpdate = numGlobalPlanes > 0;
	
				}
	
				scope.numPlanes = numGlobalPlanes;
				scope.numIntersection = 0;
	
			}
	
			function projectPlanes( planes, camera, dstOffset, skipTransform ) {
	
				var nPlanes = planes !== null ? planes.length : 0,
					dstArray = null;
	
				if ( nPlanes !== 0 ) {
	
					dstArray = uniform.value;
	
					if ( skipTransform !== true || dstArray === null ) {
	
						var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;
	
						viewNormalMatrix.getNormalMatrix( viewMatrix );
	
						if ( dstArray === null || dstArray.length < flatSize ) {
	
							dstArray = new Float32Array( flatSize );
	
						}
	
						for ( var i = 0, i4 = dstOffset;
											i !== nPlanes; ++ i, i4 += 4 ) {
	
							plane.copy( planes[ i ] ).
									applyMatrix4( viewMatrix, viewNormalMatrix );
	
							plane.normal.toArray( dstArray, i4 );
							dstArray[ i4 + 3 ] = plane.constant;
	
						}
	
					}
	
					uniform.value = dstArray;
					uniform.needsUpdate = true;
	
				}
	
				scope.numPlanes = nPlanes;
				
				return dstArray;
	
			}
	
		}
	
		// import { Sphere } from '../math/Sphere';
		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 * @author tschw
		 */
	
		function WebGLRenderer( parameters ) {
	
			console.log( 'THREE.WebGLRenderer', REVISION );
	
			parameters = parameters || {};
	
			var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
				_context = parameters.context !== undefined ? parameters.context : null,
	
				_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
				_depth = parameters.depth !== undefined ? parameters.depth : true,
				_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
				_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
				_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
				_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
	
			var lights = [];
	
			var currentRenderList = null;
	
			var morphInfluences = new Float32Array( 8 );
	
			var sprites = [];
			var lensFlares = [];
	
			// public properties
	
			this.domElement = _canvas;
			this.context = null;
	
			// clearing
	
			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;
	
			// scene graph
	
			this.sortObjects = true;
	
			// user-defined clipping
	
			this.clippingPlanes = [];
			this.localClippingEnabled = false;
	
			// physically based shading
	
			this.gammaFactor = 2.0;	// for backwards compatibility
			this.gammaInput = false;
			this.gammaOutput = false;
	
			// physical lights
	
			this.physicallyCorrectLights = false;
	
			// tone mapping
	
			this.toneMapping = LinearToneMapping;
			this.toneMappingExposure = 1.0;
			this.toneMappingWhitePoint = 1.0;
	
			// morphs
	
			this.maxMorphTargets = 8;
			this.maxMorphNormals = 4;
	
			// internal properties
	
			var _this = this,
	
				// internal state cache
	
				_currentProgram = null,
				_currentRenderTarget = null,
				_currentFramebuffer = null,
				_currentMaterialId = - 1,
				_currentGeometryProgram = '',
	
				_currentCamera = null,
				_currentArrayCamera = null,
	
				_currentScissor = new Vector4(),
				_currentScissorTest = null,
	
				_currentViewport = new Vector4(),
	
				//
	
				_usedTextureUnits = 0,
	
				//
	
				_width = _canvas.width,
				_height = _canvas.height,
	
				_pixelRatio = 1,
	
				_scissor = new Vector4( 0, 0, _width, _height ),
				_scissorTest = false,
	
				_viewport = new Vector4( 0, 0, _width, _height ),
	
				// frustum
	
				_frustum = new Frustum(),
	
				// clipping
	
				_clipping = new WebGLClipping(),
				_clippingEnabled = false,
				_localClippingEnabled = false,
	
				// camera matrices cache
	
				_projScreenMatrix = new Matrix4(),
	
				_vector3 = new Vector3(),
				_matrix4 = new Matrix4(),
				_matrix42 = new Matrix4(),
	
				// light arrays cache
	
				_lights = {
	
					hash: '',
	
					ambient: [ 0, 0, 0 ],
					directional: [],
					directionalShadowMap: [],
					directionalShadowMatrix: [],
					spot: [],
					spotShadowMap: [],
					spotShadowMatrix: [],
					rectArea: [],
					point: [],
					pointShadowMap: [],
					pointShadowMatrix: [],
					hemi: [],
	
					shadows: []
	
				},
	
				// info
	
				_infoMemory = {
					geometries: 0,
					textures: 0
				},
	
				_infoRender = {
	
					frame: 0,
					calls: 0,
					vertices: 0,
					faces: 0,
					points: 0
	
				};
	
			this.info = {
	
				render: _infoRender,
				memory: _infoMemory,
				programs: null
	
			};
	
	
			// initialize
	
			var _gl;
	
			try {
	
				var contextAttributes = {
					alpha: _alpha,
					depth: _depth,
					stencil: _stencil,
					antialias: _antialias,
					premultipliedAlpha: _premultipliedAlpha,
					preserveDrawingBuffer: _preserveDrawingBuffer
				};
	
				_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );
	
				if ( _gl === null ) {
	
					if ( _canvas.getContext( 'webgl' ) !== null ) {
	
						throw 'Error creating WebGL context with your selected attributes.';
	
					} else {
	
						throw 'Error creating WebGL context.';
	
					}
	
				}
	
				// Some experimental-webgl implementations do not have getShaderPrecisionFormat
	
				if ( _gl.getShaderPrecisionFormat === undefined ) {
	
					_gl.getShaderPrecisionFormat = function () {
	
						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
	
					};
	
				}
	
				_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
	
			} catch ( error ) {
	
				console.error( 'THREE.WebGLRenderer: ' + error );
	
			}
	
			var extensions = new WebGLExtensions( _gl );
	
			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extensions.get( 'OES_element_index_uint' ) ) {
	
				BufferGeometry.MaxIndex = 4294967296;
	
			}
	
			var capabilities = new WebGLCapabilities( _gl, extensions, parameters );
	
			var state = new WebGLState( _gl, extensions, paramThreeToGL );
	
			var properties = new WebGLProperties();
			var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, _infoMemory );
			var attributes = new WebGLAttributes( _gl );
			var geometries = new WebGLGeometries( _gl, attributes, _infoMemory );
			var objects = new WebGLObjects( _gl, geometries, _infoRender );
			var programCache = new WebGLPrograms( this, capabilities );
			var lightCache = new WebGLLights();
			var renderLists = new WebGLRenderLists();
	
			var background = new WebGLBackground( this, state, objects, _premultipliedAlpha );
			var vr = new WebVRManager( this );
	
			this.info.programs = programCache.programs;
	
			var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
			var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );
	
			//
	
			function getTargetPixelRatio() {
	
				return _currentRenderTarget === null ? _pixelRatio : 1;
	
			}
	
			function setDefaultGLState() {
	
				state.init();
	
				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
			}
	
			function resetGLState() {
	
				_currentProgram = null;
				_currentCamera = null;
	
				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
	
				state.reset();
	
			}
	
			setDefaultGLState();
	
			this.context = _gl;
			this.capabilities = capabilities;
			this.extensions = extensions;
			this.properties = properties;
			this.renderLists = renderLists;
			this.state = state;
			this.vr = vr;
	
			// shadow map
	
			var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );
	
			this.shadowMap = shadowMap;
	
	
			// Plugins
	
			var spritePlugin = new SpritePlugin( this, sprites );
			var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );
	
			// API
	
			this.getContext = function () {
	
				return _gl;
	
			};
	
			this.getContextAttributes = function () {
	
				return _gl.getContextAttributes();
	
			};
	
			this.forceContextLoss = function () {
	
				var extension = extensions.get( 'WEBGL_lose_context' );
				if ( extension ) extension.loseContext();
	
			};
	
			this.getMaxAnisotropy = function () {
	
				return capabilities.getMaxAnisotropy();
	
			};
	
			this.getPrecision = function () {
	
				return capabilities.precision;
	
			};
	
			this.getPixelRatio = function () {
	
				return _pixelRatio;
	
			};
	
			this.setPixelRatio = function ( value ) {
	
				if ( value === undefined ) return;
	
				_pixelRatio = value;
	
				this.setSize( _width, _height, false );
	
			};
	
			this.getSize = function () {
	
				return {
					width: _width,
					height: _height
				};
	
			};
	
			this.setSize = function ( width, height, updateStyle ) {
	
				var device = vr.getDevice();
	
				if ( device && device.isPresenting ) {
	
					console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
					return;
	
				}
	
				_width = width;
				_height = height;
	
				_canvas.width = width * _pixelRatio;
				_canvas.height = height * _pixelRatio;
	
				if ( updateStyle !== false ) {
	
					_canvas.style.width = width + 'px';
					_canvas.style.height = height + 'px';
	
				}
	
				this.setViewport( 0, 0, width, height );
	
			};
	
			this.getDrawingBufferSize = function () {
	
				return {
					width: _width * _pixelRatio,
					height: _height * _pixelRatio
				};
	
			};
	
			this.setDrawingBufferSize = function ( width, height, pixelRatio ) {
	
				_width = width;
				_height = height;
	
				_pixelRatio = pixelRatio;
	
				_canvas.width = width * pixelRatio;
				_canvas.height = height * pixelRatio;
	
				this.setViewport( 0, 0, width, height );
	
			};
	
			this.setViewport = function ( x, y, width, height ) {
	
				_viewport.set( x, _height - y - height, width, height );
				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
			};
	
			this.setScissor = function ( x, y, width, height ) {
	
				_scissor.set( x, _height - y - height, width, height );
				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
	
			};
	
			this.setScissorTest = function ( boolean ) {
	
				state.setScissorTest( _scissorTest = boolean );
	
			};
	
			// Clearing
	
			this.getClearColor = background.getClearColor;
			this.setClearColor = background.setClearColor;
			this.getClearAlpha = background.getClearAlpha;
			this.setClearAlpha = background.setClearAlpha;
	
			this.clear = function ( color, depth, stencil ) {
	
				var bits = 0;
	
				if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
				if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
				if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
				_gl.clear( bits );
	
			};
	
			this.clearColor = function () {
	
				this.clear( true, false, false );
	
			};
	
			this.clearDepth = function () {
	
				this.clear( false, true, false );
	
			};
	
			this.clearStencil = function () {
	
				this.clear( false, false, true );
	
			};
	
			this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
				this.setRenderTarget( renderTarget );
				this.clear( color, depth, stencil );
	
			};
	
			// Reset
	
			this.resetGLState = resetGLState;
	
			this.dispose = function () {
	
				_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
	
				renderLists.dispose();
	
			};
	
			// Events
	
			function onContextLost( event ) {
	
				event.preventDefault();
	
				resetGLState();
				setDefaultGLState();
	
				properties.clear();
				objects.clear();
	
			}
	
			function onMaterialDispose( event ) {
	
				var material = event.target;
	
				material.removeEventListener( 'dispose', onMaterialDispose );
	
				deallocateMaterial( material );
	
			}
	
			// Buffer deallocation
	
			function deallocateMaterial( material ) {
	
				releaseMaterialProgramReference( material );
	
				properties.remove( material );
	
			}
	
	
			function releaseMaterialProgramReference( material ) {
	
				var programInfo = properties.get( material ).program;
	
				material.program = undefined;
	
				if ( programInfo !== undefined ) {
	
					programCache.releaseProgram( programInfo );
	
				}
	
			}
	
			// Buffer rendering
	
			function renderObjectImmediate( object, program, material ) {
	
				object.render( function ( object ) {
	
					_this.renderBufferImmediate( object, program, material );
	
				} );
	
			}
	
			this.renderBufferImmediate = function ( object, program, material ) {
	
				state.initAttributes();
	
				var buffers = properties.get( object );
	
				if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
				if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
				if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
				if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
	
				var programAttributes = program.getAttributes();
	
				if ( object.hasPositions ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( programAttributes.position );
					_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasNormals ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
	
					if ( ! material.isMeshPhongMaterial &&
						! material.isMeshStandardMaterial &&
						! material.isMeshNormalMaterial &&
						material.shading === FlatShading ) {
	
						for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {
	
							var array = object.normalArray;
	
							var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
							var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
							var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;
	
							array[ i + 0 ] = nx;
							array[ i + 1 ] = ny;
							array[ i + 2 ] = nz;
	
							array[ i + 3 ] = nx;
							array[ i + 4 ] = ny;
							array[ i + 5 ] = nz;
	
							array[ i + 6 ] = nx;
							array[ i + 7 ] = ny;
							array[ i + 8 ] = nz;
	
						}
	
					}
	
					_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( programAttributes.normal );
	
					_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasUvs && material.map ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( programAttributes.uv );
	
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasColors && material.vertexColors !== NoColors ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( programAttributes.color );
	
					_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				state.disableUnusedAttributes();
	
				_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
				object.count = 0;
	
			};
	
			function absNumericalSort( a, b ) {
	
				return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );
	
			}
	
			this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
	
				state.setMaterial( material );
	
				var program = setProgram( camera, fog, material, object );
				var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );
	
				var updateBuffers = false;
	
				if ( geometryProgram !== _currentGeometryProgram ) {
	
					_currentGeometryProgram = geometryProgram;
					updateBuffers = true;
	
				}
	
				// morph targets
	
				var morphTargetInfluences = object.morphTargetInfluences;
	
				if ( morphTargetInfluences !== undefined ) {
	
					// TODO Remove allocations
	
					var activeInfluences = [];
	
					for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {
	
						var influence = morphTargetInfluences[ i ];
						activeInfluences.push( [ influence, i ] );
	
					}
	
					activeInfluences.sort( absNumericalSort );
	
					if ( activeInfluences.length > 8 ) {
	
						activeInfluences.length = 8;
	
					}
	
					var morphAttributes = geometry.morphAttributes;
	
					for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {
	
						var influence = activeInfluences[ i ];
						morphInfluences[ i ] = influence[ 0 ];
	
						if ( influence[ 0 ] !== 0 ) {
	
							var index = influence[ 1 ];
	
							if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
							if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );
	
						} else {
	
							if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
							if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );
	
						}
	
					}
	
					for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {
	
						morphInfluences[ i ] = 0.0;
	
					}
	
					program.getUniforms().setValue( _gl, 'morphTargetInfluences', morphInfluences );
	
					updateBuffers = true;
	
				}
	
				//
	
				var index = geometry.index;
				var position = geometry.attributes.position;
				var rangeFactor = 1;
	
				if ( material.wireframe === true ) {
	
					index = geometries.getWireframeAttribute( geometry );
					rangeFactor = 2;
	
				}
	
				var attribute;
				var renderer = bufferRenderer;
	
				if ( index !== null ) {
	
					attribute = attributes.get( index );
	
					renderer = indexedBufferRenderer;
					renderer.setIndex( attribute );
	
				}
	
				if ( updateBuffers ) {
	
					setupVertexAttributes( material, program, geometry );
	
					if ( index !== null ) {
	
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );
	
					}
	
				}
	
				//
	
				var dataCount = 0;
	
				if ( index !== null ) {
	
					dataCount = index.count;
	
				} else if ( position !== undefined ) {
	
					dataCount = position.count;
	
				}
	
				var rangeStart = geometry.drawRange.start * rangeFactor;
				var rangeCount = geometry.drawRange.count * rangeFactor;
	
				var groupStart = group !== null ? group.start * rangeFactor : 0;
				var groupCount = group !== null ? group.count * rangeFactor : Infinity;
	
				var drawStart = Math.max( rangeStart, groupStart );
				var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
	
				var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
	
				if ( drawCount === 0 ) return;
	
				//
	
				if ( object.isMesh ) {
	
					if ( material.wireframe === true ) {
	
						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );
	
					} else {
	
						switch ( object.drawMode ) {
	
							case TrianglesDrawMode:
								renderer.setMode( _gl.TRIANGLES );
								break;
	
							case TriangleStripDrawMode:
								renderer.setMode( _gl.TRIANGLE_STRIP );
								break;
	
							case TriangleFanDrawMode:
								renderer.setMode( _gl.TRIANGLE_FAN );
								break;
	
						}
	
					}
	
	
				} else if ( object.isLine ) {
	
					var lineWidth = material.linewidth;
	
					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
	
					state.setLineWidth( lineWidth * getTargetPixelRatio() );
	
					if ( object.isLineSegments ) {
	
						renderer.setMode( _gl.LINES );
	
					} else if ( object.isLineLoop ) {
	
						renderer.setMode( _gl.LINE_LOOP );
	
					} else {
	
						renderer.setMode( _gl.LINE_STRIP );
	
					}
	
				} else if ( object.isPoints ) {
	
					renderer.setMode( _gl.POINTS );
	
				}
	
				if ( geometry && geometry.isInstancedBufferGeometry ) {
	
					if ( geometry.maxInstancedCount > 0 ) {
	
						renderer.renderInstances( geometry, drawStart, drawCount );
	
					}
	
				} else {
	
					renderer.render( drawStart, drawCount );
	
				}
	
			};
	
			function setupVertexAttributes( material, program, geometry, startIndex ) {
	
				if ( geometry && geometry.isInstancedBufferGeometry ) {
	
					if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {
	
						console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
						return;
	
					}
	
				}
	
				if ( startIndex === undefined ) startIndex = 0;
	
				state.initAttributes();
	
				var geometryAttributes = geometry.attributes;
	
				var programAttributes = program.getAttributes();
	
				var materialDefaultAttributeValues = material.defaultAttributeValues;
	
				for ( var name in programAttributes ) {
	
					var programAttribute = programAttributes[ name ];
	
					if ( programAttribute >= 0 ) {
	
						var geometryAttribute = geometryAttributes[ name ];
	
						if ( geometryAttribute !== undefined ) {
	
							var normalized = geometryAttribute.normalized;
							var size = geometryAttribute.itemSize;
	
							var attribute = attributes.get( geometryAttribute );
	
							var buffer = attribute.buffer;
							var type = attribute.type;
							var bytesPerElement = attribute.bytesPerElement;
	
							if ( geometryAttribute.isInterleavedBufferAttribute ) {
	
								var data = geometryAttribute.data;
								var stride = data.stride;
								var offset = geometryAttribute.offset;
	
								if ( data && data.isInstancedInterleavedBuffer ) {
	
									state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );
	
									if ( geometry.maxInstancedCount === undefined ) {
	
										geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	
									}
	
								} else {
	
									state.enableAttribute( programAttribute );
	
								}
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );
	
							} else {
	
								if ( geometryAttribute.isInstancedBufferAttribute ) {
	
									state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );
	
									if ( geometry.maxInstancedCount === undefined ) {
	
										geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	
									}
	
								} else {
	
									state.enableAttribute( programAttribute );
	
								}
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );
	
							}
	
						} else if ( materialDefaultAttributeValues !== undefined ) {
	
							var value = materialDefaultAttributeValues[ name ];
	
							if ( value !== undefined ) {
	
								switch ( value.length ) {
	
									case 2:
										_gl.vertexAttrib2fv( programAttribute, value );
										break;
	
									case 3:
										_gl.vertexAttrib3fv( programAttribute, value );
										break;
	
									case 4:
										_gl.vertexAttrib4fv( programAttribute, value );
										break;
	
									default:
										_gl.vertexAttrib1fv( programAttribute, value );
	
								}
	
							}
	
						}
	
					}
	
				}
	
				state.disableUnusedAttributes();
	
			}
	
			// Compile
	
			this.compile = function ( scene, camera ) {
	
				lights = [];
	
				scene.traverse( function ( object ) {
	
					if ( object.isLight ) {
	
						lights.push( object );
	
					}
	
				} );
	
				setupLights( lights, camera );
	
				scene.traverse( function ( object ) {
	
					if ( object.material ) {
	
						if ( Array.isArray( object.material ) ) {
	
							for ( var i = 0; i < object.material.length; i ++ ) {
	
								initMaterial( object.material[ i ], scene.fog, object );
	
							}
	
						} else {
	
							initMaterial( object.material, scene.fog, object );
	
						}
	
					}
	
				} );
	
			};
	
			// Rendering
	
			this.animate = function ( callback ) {
	
				function onFrame() {
	
					callback();
	
					( vr.getDevice() || window ).requestAnimationFrame( onFrame );
	
				}
	
				( vr.getDevice() || window ).requestAnimationFrame( onFrame );
	
			};
	
			this.render = function ( scene, camera, renderTarget, forceClear ) {
	
				if ( ! ( camera && camera.isCamera ) ) {
	
					console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;
	
				}
	
				// reset caching for this frame
	
				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
				_currentCamera = null;
	
				// update scene graph
	
				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
				// update camera matrices and frustum
	
				if ( camera.parent === null ) camera.updateMatrixWorld();
	
				if ( vr.enabled ) {
	
					camera = vr.getCamera( camera );
	
				}
	
				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );
	
				lights.length = 0;
				sprites.length = 0;
				lensFlares.length = 0;
	
				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
	
				currentRenderList = renderLists.get( scene, camera );
				currentRenderList.init();
	
				projectObject( scene, camera, _this.sortObjects );
	
				currentRenderList.finish();
	
				if ( _this.sortObjects === true ) {
	
					currentRenderList.sort();
	
				}
	
				//
	
				if ( _clippingEnabled ) _clipping.beginShadows();
	
				setupShadows( lights );
	
				shadowMap.render( scene, camera );
	
				setupLights( lights, camera );
	
				if ( _clippingEnabled ) _clipping.endShadows();
	
				//
	
				_infoRender.frame ++;
				_infoRender.calls = 0;
				_infoRender.vertices = 0;
				_infoRender.faces = 0;
				_infoRender.points = 0;
	
				if ( renderTarget === undefined ) {
	
					renderTarget = null;
	
				}
	
				this.setRenderTarget( renderTarget );
	
				//
	
				background.render( scene, camera, forceClear );
	
				// render scene
	
				var opaqueObjects = currentRenderList.opaque;
				var transparentObjects = currentRenderList.transparent;
	
				if ( scene.overrideMaterial ) {
	
					var overrideMaterial = scene.overrideMaterial;
	
					if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
					if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );
	
				} else {
	
					// opaque pass (front-to-back order)
	
					if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );
	
					// transparent pass (back-to-front order)
	
					if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );
	
				}
	
				// custom render plugins (post pass)
	
				spritePlugin.render( scene, camera );
				lensFlarePlugin.render( scene, camera, _currentViewport );
	
				// Generate mipmap if we're using any kind of mipmap filtering
	
				if ( renderTarget ) {
	
					textures.updateRenderTargetMipmap( renderTarget );
	
				}
	
				// Ensure depth buffer writing is enabled so it can be cleared on next render
	
				state.buffers.depth.setTest( true );
				state.buffers.depth.setMask( true );
				state.buffers.color.setMask( true );
	
				if ( camera.isArrayCamera ) {
	
					_this.setScissorTest( false );
	
				}
	
				if ( vr.enabled ) {
	
					vr.submitFrame();
	
				}
	
				// _gl.finish();
	
			};
	
			/*
			// TODO Duplicated code (Frustum)
	
			var _sphere = new Sphere();
	
			function isObjectViewable( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();
	
				_sphere.copy( geometry.boundingSphere ).
				applyMatrix4( object.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSpriteViewable( sprite ) {
	
				_sphere.center.set( 0, 0, 0 );
				_sphere.radius = 0.7071067811865476;
				_sphere.applyMatrix4( sprite.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSphereViewable( sphere ) {
	
				if ( ! _frustum.intersectsSphere( sphere ) ) return false;
	
				var numPlanes = _clipping.numPlanes;
	
				if ( numPlanes === 0 ) return true;
	
				var planes = _this.clippingPlanes,
	
					center = sphere.center,
					negRad = - sphere.radius,
					i = 0;
	
				do {
	
					// out when deeper than radius in the negative halfspace
					if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
	
				} while ( ++ i !== numPlanes );
	
				return true;
	
			}
			*/
	
			function projectObject( object, camera, sortObjects ) {
	
				if ( ! object.visible ) return;
	
				var visible = object.layers.test( camera.layers );
	
				if ( visible ) {
	
					if ( object.isLight ) {
	
						lights.push( object );
	
					} else if ( object.isSprite ) {
	
						if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {
	
							sprites.push( object );
	
						}
	
					} else if ( object.isLensFlare ) {
	
						lensFlares.push( object );
	
					} else if ( object.isImmediateRenderObject ) {
	
						if ( sortObjects ) {
	
							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );
	
						}
	
						currentRenderList.push( object, null, object.material, _vector3.z, null );
	
					} else if ( object.isMesh || object.isLine || object.isPoints ) {
	
						if ( object.isSkinnedMesh ) {
	
							object.skeleton.update();
	
						}
	
						if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {
	
							if ( sortObjects ) {
	
								_vector3.setFromMatrixPosition( object.matrixWorld )
									.applyMatrix4( _projScreenMatrix );
	
							}
	
							var geometry = objects.update( object );
							var material = object.material;
	
							if ( Array.isArray( material ) ) {
	
								var groups = geometry.groups;
	
								for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
									var group = groups[ i ];
									var groupMaterial = material[ group.materialIndex ];
	
									if ( groupMaterial && groupMaterial.visible ) {
	
										currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );
	
									}
	
								}
	
							} else if ( material.visible ) {
	
								currentRenderList.push( object, geometry, material, _vector3.z, null );
	
							}
	
						}
	
					}
	
				}
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					projectObject( children[ i ], camera, sortObjects );
	
				}
	
			}
	
			function renderObjects( renderList, scene, camera, overrideMaterial ) {
	
				for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
					var renderItem = renderList[ i ];
	
					var object = renderItem.object;
					var geometry = renderItem.geometry;
					var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
					var group = renderItem.group;
	
					if ( camera.isArrayCamera ) {
	
						_currentArrayCamera = camera;
	
						var cameras = camera.cameras;
	
						for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {
	
							var camera2 = cameras[ j ];
	
							if ( object.layers.test( camera2.layers ) ) {
	
								var bounds = camera2.bounds;
	
								var x = bounds.x * _width;
								var y = bounds.y * _height;
								var width = bounds.z * _width;
								var height = bounds.w * _height;
	
								_this.setViewport( x, y, width, height );
								_this.setScissor( x, y, width, height );
								_this.setScissorTest( true );
	
								renderObject( object, scene, camera2, geometry, material, group );
	
							}
	
						}
	
					} else {
	
						_currentArrayCamera = null;
	
						renderObject( object, scene, camera, geometry, material, group );
	
					}
	
				}
	
			}
	
			function renderObject( object, scene, camera, geometry, material, group ) {
	
				object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
				object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
	
				object.onBeforeRender( _this, scene, camera, geometry, material, group );
	
				if ( object.isImmediateRenderObject ) {
	
					state.setMaterial( material );
	
					var program = setProgram( camera, scene.fog, material, object );
	
					_currentGeometryProgram = '';
	
					renderObjectImmediate( object, program, material );
	
				} else {
	
					_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );
	
				}
	
				object.onAfterRender( _this, scene, camera, geometry, material, group );
	
			}
	
			function initMaterial( material, fog, object ) {
	
				var materialProperties = properties.get( material );
	
				var parameters = programCache.getParameters(
					material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );
	
				var code = programCache.getProgramCode( material, parameters );
	
				var program = materialProperties.program;
				var programChange = true;
	
				if ( program === undefined ) {
	
					// new material
					material.addEventListener( 'dispose', onMaterialDispose );
	
				} else if ( program.code !== code ) {
	
					// changed glsl or parameters
					releaseMaterialProgramReference( material );
	
				} else if ( parameters.shaderID !== undefined ) {
	
					// same glsl and uniform list
					return;
	
				} else {
	
					// only rebuild uniform list
					programChange = false;
	
				}
	
				if ( programChange ) {
	
					if ( parameters.shaderID ) {
	
						var shader = ShaderLib[ parameters.shaderID ];
	
						materialProperties.shader = {
							name: material.type,
							uniforms: UniformsUtils.clone( shader.uniforms ),
							vertexShader: shader.vertexShader,
							fragmentShader: shader.fragmentShader
						};
	
					} else {
	
						materialProperties.shader = {
							name: material.type,
							uniforms: material.uniforms,
							vertexShader: material.vertexShader,
							fragmentShader: material.fragmentShader
						};
	
					}
	
					material.onBeforeCompile( materialProperties.shader );
	
					program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );
	
					materialProperties.program = program;
					material.program = program;
	
				}
	
				var programAttributes = program.getAttributes();
	
				if ( material.morphTargets ) {
	
					material.numSupportedMorphTargets = 0;
	
					for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
						if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {
	
							material.numSupportedMorphTargets ++;
	
						}
	
					}
	
				}
	
				if ( material.morphNormals ) {
	
					material.numSupportedMorphNormals = 0;
	
					for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
	
						if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {
	
							material.numSupportedMorphNormals ++;
	
						}
	
					}
	
				}
	
				var uniforms = materialProperties.shader.uniforms;
	
				if ( ! material.isShaderMaterial &&
					! material.isRawShaderMaterial ||
					material.clipping === true ) {
	
					materialProperties.numClippingPlanes = _clipping.numPlanes;
					materialProperties.numIntersection = _clipping.numIntersection;
					uniforms.clippingPlanes = _clipping.uniform;
	
				}
	
				materialProperties.fog = fog;
	
				// store the light setup it was created for
	
				materialProperties.lightsHash = _lights.hash;
	
				if ( material.lights ) {
	
					// wire up the material to this renderer's lighting state
	
					uniforms.ambientLightColor.value = _lights.ambient;
					uniforms.directionalLights.value = _lights.directional;
					uniforms.spotLights.value = _lights.spot;
					uniforms.rectAreaLights.value = _lights.rectArea;
					uniforms.pointLights.value = _lights.point;
					uniforms.hemisphereLights.value = _lights.hemi;
	
					uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
					uniforms.spotShadowMap.value = _lights.spotShadowMap;
					uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
					uniforms.pointShadowMap.value = _lights.pointShadowMap;
					uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
					// TODO (abelnation): add area lights shadow info to uniforms
	
				}
	
				var progUniforms = materialProperties.program.getUniforms(),
					uniformsList =
						WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
	
				materialProperties.uniformsList = uniformsList;
	
			}
	
			function setProgram( camera, fog, material, object ) {
	
				_usedTextureUnits = 0;
	
				var materialProperties = properties.get( material );
	
				if ( _clippingEnabled ) {
	
					if ( _localClippingEnabled || camera !== _currentCamera ) {
	
						var useCache =
							camera === _currentCamera &&
							material.id === _currentMaterialId;
	
						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						_clipping.setState(
							material.clippingPlanes, material.clipIntersection, material.clipShadows,
							camera, materialProperties, useCache );
	
					}
	
				}
	
				if ( material.needsUpdate === false ) {
	
					if ( materialProperties.program === undefined ) {
	
						material.needsUpdate = true;
	
					} else if ( material.fog && materialProperties.fog !== fog ) {
	
						material.needsUpdate = true;
	
					} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {
	
						material.needsUpdate = true;
	
					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
						materialProperties.numIntersection !== _clipping.numIntersection ) ) {
	
						material.needsUpdate = true;
	
					}
	
				}
	
				if ( material.needsUpdate ) {
	
					initMaterial( material, fog, object );
					material.needsUpdate = false;
	
				}
	
				var refreshProgram = false;
				var refreshMaterial = false;
				var refreshLights = false;
	
				var program = materialProperties.program,
					p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.shader.uniforms;
	
				if ( program.id !== _currentProgram ) {
	
					_gl.useProgram( program.program );
					_currentProgram = program.id;
	
					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;
	
				}
	
				if ( material.id !== _currentMaterialId ) {
	
					_currentMaterialId = material.id;
	
					refreshMaterial = true;
	
				}
	
				if ( refreshProgram || camera !== _currentCamera ) {
	
					p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
	
					if ( capabilities.logarithmicDepthBuffer ) {
	
						p_uniforms.setValue( _gl, 'logDepthBufFC',
							2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
					}
	
					// Avoid unneeded uniform updates per ArrayCamera's sub-camera
	
					if ( _currentCamera !== ( _currentArrayCamera || camera ) ) {
	
						_currentCamera = ( _currentArrayCamera || camera );
	
						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:
	
						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done
	
					}
	
					// load material specific uniforms
					// (shader material also gets them for the sake of genericity)
	
					if ( material.isShaderMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshStandardMaterial ||
						material.envMap ) {
	
						var uCamPos = p_uniforms.map.cameraPosition;
	
						if ( uCamPos !== undefined ) {
	
							uCamPos.setValue( _gl,
								_vector3.setFromMatrixPosition( camera.matrixWorld ) );
	
						}
	
					}
	
					if ( material.isMeshPhongMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ||
						material.skinning ) {
	
						p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
	
					}
	
				}
	
				// skinning uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone texture must go before other textures
				// not sure why, but otherwise weird things happen
	
				if ( material.skinning ) {
	
					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
	
					var skeleton = object.skeleton;
	
					if ( skeleton ) {
	
						var bones = skeleton.bones;
	
						if ( capabilities.floatVertexTextures ) {
	
							if ( skeleton.boneTexture === undefined ) {
	
								// layout (1 matrix = 4 pixels)
								//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
								//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
								//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
								//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
								//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	
	
								var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
								size = _Math.nextPowerOfTwo( Math.ceil( size ) );
								size = Math.max( size, 4 );
	
								var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
								boneMatrices.set( skeleton.boneMatrices ); // copy current values
	
								var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
	
								skeleton.boneMatrices = boneMatrices;
								skeleton.boneTexture = boneTexture;
								skeleton.boneTextureSize = size;
	
							}
	
							p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
							p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );
	
						} else {
	
							p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
	
						}
	
					}
	
				}
	
				if ( refreshMaterial ) {
	
					p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
					p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );
	
					if ( material.lights ) {
	
						// the current material requires lighting info
	
						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required
	
						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
	
					}
	
					// refresh uniforms common to several materials
	
					if ( fog && material.fog ) {
	
						refreshUniformsFog( m_uniforms, fog );
	
					}
	
					if ( material.isMeshBasicMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshStandardMaterial ||
						material.isMeshNormalMaterial ||
						material.isMeshDepthMaterial ) {
	
						refreshUniformsCommon( m_uniforms, material );
	
					}
	
					// refresh single material specific uniforms
	
					if ( material.isLineBasicMaterial ) {
	
						refreshUniformsLine( m_uniforms, material );
	
					} else if ( material.isLineDashedMaterial ) {
	
						refreshUniformsLine( m_uniforms, material );
						refreshUniformsDash( m_uniforms, material );
	
					} else if ( material.isPointsMaterial ) {
	
						refreshUniformsPoints( m_uniforms, material );
	
					} else if ( material.isMeshLambertMaterial ) {
	
						refreshUniformsLambert( m_uniforms, material );
	
					} else if ( material.isMeshToonMaterial ) {
	
						refreshUniformsToon( m_uniforms, material );
	
					} else if ( material.isMeshPhongMaterial ) {
	
						refreshUniformsPhong( m_uniforms, material );
	
					} else if ( material.isMeshPhysicalMaterial ) {
	
						refreshUniformsPhysical( m_uniforms, material );
	
					} else if ( material.isMeshStandardMaterial ) {
	
						refreshUniformsStandard( m_uniforms, material );
	
					} else if ( material.isMeshDepthMaterial ) {
	
						if ( material.displacementMap ) {
	
							m_uniforms.displacementMap.value = material.displacementMap;
							m_uniforms.displacementScale.value = material.displacementScale;
							m_uniforms.displacementBias.value = material.displacementBias;
	
						}
	
					} else if ( material.isMeshNormalMaterial ) {
	
						refreshUniformsNormal( m_uniforms, material );
	
					}
	
					// RectAreaLight Texture
					// TODO (mrdoob): Find a nicer implementation
	
					if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;
					if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;
	
					WebGLUniforms.upload(
						_gl, materialProperties.uniformsList, m_uniforms, _this );
	
				}
	
	
				// common matrices
	
				p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
				p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
	
				return program;
	
			}
	
			// Uniforms (refresh uniforms objects)
	
			function refreshUniformsCommon( uniforms, material ) {
	
				uniforms.opacity.value = material.opacity;
	
				uniforms.diffuse.value = material.color;
	
				if ( material.emissive ) {
	
					uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
	
				}
	
				uniforms.map.value = material.map;
				uniforms.specularMap.value = material.specularMap;
				uniforms.alphaMap.value = material.alphaMap;
	
				if ( material.lightMap ) {
	
					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
				}
	
				if ( material.aoMap ) {
	
					uniforms.aoMap.value = material.aoMap;
					uniforms.aoMapIntensity.value = material.aoMapIntensity;
	
				}
	
				// uv repeat and offset setting priorities
				// 1. color map
				// 2. specular map
				// 3. normal map
				// 4. bump map
				// 5. alpha map
				// 6. emissive map
	
				var uvScaleMap;
	
				if ( material.map ) {
	
					uvScaleMap = material.map;
	
				} else if ( material.specularMap ) {
	
					uvScaleMap = material.specularMap;
	
				} else if ( material.displacementMap ) {
	
					uvScaleMap = material.displacementMap;
	
				} else if ( material.normalMap ) {
	
					uvScaleMap = material.normalMap;
	
				} else if ( material.bumpMap ) {
	
					uvScaleMap = material.bumpMap;
	
				} else if ( material.roughnessMap ) {
	
					uvScaleMap = material.roughnessMap;
	
				} else if ( material.metalnessMap ) {
	
					uvScaleMap = material.metalnessMap;
	
				} else if ( material.alphaMap ) {
	
					uvScaleMap = material.alphaMap;
	
				} else if ( material.emissiveMap ) {
	
					uvScaleMap = material.emissiveMap;
	
				}
	
				if ( uvScaleMap !== undefined ) {
	
					// backwards compatibility
					if ( uvScaleMap.isWebGLRenderTarget ) {
	
						uvScaleMap = uvScaleMap.texture;
	
					}
	
					var offset = uvScaleMap.offset;
					var repeat = uvScaleMap.repeat;
	
					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
				}
	
				uniforms.envMap.value = material.envMap;
	
				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;
	
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;
	
			}
	
			function refreshUniformsLine( uniforms, material ) {
	
				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
	
			}
	
			function refreshUniformsDash( uniforms, material ) {
	
				uniforms.dashSize.value = material.dashSize;
				uniforms.totalSize.value = material.dashSize + material.gapSize;
				uniforms.scale.value = material.scale;
	
			}
	
			function refreshUniformsPoints( uniforms, material ) {
	
				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
				uniforms.size.value = material.size * _pixelRatio;
				uniforms.scale.value = _height * 0.5;
	
				uniforms.map.value = material.map;
	
				if ( material.map !== null ) {
	
					var offset = material.map.offset;
					var repeat = material.map.repeat;
	
					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
				}
	
			}
	
			function refreshUniformsFog( uniforms, fog ) {
	
				uniforms.fogColor.value = fog.color;
	
				if ( fog.isFog ) {
	
					uniforms.fogNear.value = fog.near;
					uniforms.fogFar.value = fog.far;
	
				} else if ( fog.isFogExp2 ) {
	
					uniforms.fogDensity.value = fog.density;
	
				}
	
			}
	
			function refreshUniformsLambert( uniforms, material ) {
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
			}
	
			function refreshUniformsPhong( uniforms, material ) {
	
				uniforms.specular.value = material.specular;
				uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
			}
	
			function refreshUniformsToon( uniforms, material ) {
	
				refreshUniformsPhong( uniforms, material );
	
				if ( material.gradientMap ) {
	
					uniforms.gradientMap.value = material.gradientMap;
	
				}
	
			}
	
			function refreshUniformsStandard( uniforms, material ) {
	
				uniforms.roughness.value = material.roughness;
				uniforms.metalness.value = material.metalness;
	
				if ( material.roughnessMap ) {
	
					uniforms.roughnessMap.value = material.roughnessMap;
	
				}
	
				if ( material.metalnessMap ) {
	
					uniforms.metalnessMap.value = material.metalnessMap;
	
				}
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
				if ( material.envMap ) {
	
					//uniforms.envMap.value = material.envMap; // part of uniforms common
					uniforms.envMapIntensity.value = material.envMapIntensity;
	
				}
	
			}
	
			function refreshUniformsPhysical( uniforms, material ) {
	
				uniforms.clearCoat.value = material.clearCoat;
				uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
	
				refreshUniformsStandard( uniforms, material );
	
			}
	
			function refreshUniformsNormal( uniforms, material ) {
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
			}
	
			// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
			function markUniformsLightsNeedsUpdate( uniforms, value ) {
	
				uniforms.ambientLightColor.needsUpdate = value;
	
				uniforms.directionalLights.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.rectAreaLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;
	
			}
	
			// Lighting
	
			function setupShadows( lights ) {
	
				var lightShadowsLength = 0;
	
				for ( var i = 0, l = lights.length; i < l; i ++ ) {
	
					var light = lights[ i ];
	
					if ( light.castShadow ) {
	
						_lights.shadows[ lightShadowsLength ] = light;
						lightShadowsLength ++;
	
					}
	
				}
	
				_lights.shadows.length = lightShadowsLength;
	
			}
	
			function setupLights( lights, camera ) {
	
				var l, ll, light, shadow,
					r = 0, g = 0, b = 0,
					color,
					intensity,
					distance,
					shadowMap,
	
					viewMatrix = camera.matrixWorldInverse,
	
					directionalLength = 0,
					pointLength = 0,
					spotLength = 0,
					rectAreaLength = 0,
					hemiLength = 0;
	
				for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
					light = lights[ l ];
	
					color = light.color;
					intensity = light.intensity;
					distance = light.distance;
	
					shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;
	
					if ( light.isAmbientLight ) {
	
						r += color.r * intensity;
						g += color.g * intensity;
						b += color.b * intensity;
	
					} else if ( light.isDirectionalLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							shadow = light.shadow;
	
							uniforms.shadowBias = shadow.bias;
							uniforms.shadowRadius = shadow.radius;
							uniforms.shadowMapSize = shadow.mapSize;
	
						}
	
						_lights.directionalShadowMap[ directionalLength ] = shadowMap;
						_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
						_lights.directional[ directionalLength ] = uniforms;
	
						directionalLength ++;
	
					} else if ( light.isSpotLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						uniforms.color.copy( color ).multiplyScalar( intensity );
						uniforms.distance = distance;
	
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );
	
						uniforms.coneCos = Math.cos( light.angle );
						uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							shadow = light.shadow;
	
							uniforms.shadowBias = shadow.bias;
							uniforms.shadowRadius = shadow.radius;
							uniforms.shadowMapSize = shadow.mapSize;
	
						}
	
						_lights.spotShadowMap[ spotLength ] = shadowMap;
						_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
						_lights.spot[ spotLength ] = uniforms;
	
						spotLength ++;
	
					} else if ( light.isRectAreaLight ) {
	
						var uniforms = lightCache.get( light );
	
						// (a) intensity controls irradiance of entire light
						uniforms.color
							.copy( color )
							.multiplyScalar( intensity / ( light.width * light.height ) );
	
						// (b) intensity controls the radiance per light area
						// uniforms.color.copy( color ).multiplyScalar( intensity );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						// extract local rotation of light to derive width/height half vectors
						_matrix42.identity();
						_matrix4.copy( light.matrixWorld );
						_matrix4.premultiply( viewMatrix );
						_matrix42.extractRotation( _matrix4 );
	
						uniforms.halfWidth.set( light.width * 0.5,                0.0, 0.0 );
						uniforms.halfHeight.set(              0.0, light.height * 0.5, 0.0 );
	
						uniforms.halfWidth.applyMatrix4( _matrix42 );
						uniforms.halfHeight.applyMatrix4( _matrix42 );
	
						// TODO (abelnation): RectAreaLight distance?
						// uniforms.distance = distance;
	
						_lights.rectArea[ rectAreaLength ] = uniforms;
	
						rectAreaLength ++;
	
					} else if ( light.isPointLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.distance = light.distance;
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							shadow = light.shadow;
	
							uniforms.shadowBias = shadow.bias;
							uniforms.shadowRadius = shadow.radius;
							uniforms.shadowMapSize = shadow.mapSize;
	
						}
	
						_lights.pointShadowMap[ pointLength ] = shadowMap;
						_lights.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
						_lights.point[ pointLength ] = uniforms;
	
						pointLength ++;
	
					} else if ( light.isHemisphereLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						uniforms.direction.transformDirection( viewMatrix );
						uniforms.direction.normalize();
	
						uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
						uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
	
						_lights.hemi[ hemiLength ] = uniforms;
	
						hemiLength ++;
	
					}
	
				}
	
				_lights.ambient[ 0 ] = r;
				_lights.ambient[ 1 ] = g;
				_lights.ambient[ 2 ] = b;
	
				_lights.directional.length = directionalLength;
				_lights.spot.length = spotLength;
				_lights.rectArea.length = rectAreaLength;
				_lights.point.length = pointLength;
				_lights.hemi.length = hemiLength;
	
				// TODO (sam-g-steel) why aren't we using join
				_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;
	
			}
	
			// GL state setting
	
			this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
				state.setCullFace( cullFace );
				state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );
	
			};
	
			// Textures
	
			function allocTextureUnit() {
	
				var textureUnit = _usedTextureUnits;
	
				if ( textureUnit >= capabilities.maxTextures ) {
	
					console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
	
				}
	
				_usedTextureUnits += 1;
	
				return textureUnit;
	
			}
	
			this.allocTextureUnit = allocTextureUnit;
	
			// this.setTexture2D = setTexture2D;
			this.setTexture2D = ( function () {
	
				var warned = false;
	
				// backwards compatibility: peel texture.texture
				return function setTexture2D( texture, slot ) {
	
					if ( texture && texture.isWebGLRenderTarget ) {
	
						if ( ! warned ) {
	
							console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
							warned = true;
	
						}
	
						texture = texture.texture;
	
					}
	
					textures.setTexture2D( texture, slot );
	
				};
	
			}() );
	
			this.setTexture = ( function () {
	
				var warned = false;
	
				return function setTexture( texture, slot ) {
	
					if ( ! warned ) {
	
						console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
						warned = true;
	
					}
	
					textures.setTexture2D( texture, slot );
	
				};
	
			}() );
	
			this.setTextureCube = ( function () {
	
				var warned = false;
	
				return function setTextureCube( texture, slot ) {
	
					// backwards compatibility: peel texture.texture
					if ( texture && texture.isWebGLRenderTargetCube ) {
	
						if ( ! warned ) {
	
							console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
							warned = true;
	
						}
	
						texture = texture.texture;
	
					}
	
					// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
					// TODO: unify these code paths
					if ( ( texture && texture.isCubeTexture ) ||
						( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
	
						// CompressedTexture can have Array in image :/
	
						// this function alone should take care of cube textures
						textures.setTextureCube( texture, slot );
	
					} else {
	
						// assumed: texture property of THREE.WebGLRenderTargetCube
	
						textures.setTextureCubeDynamic( texture, slot );
	
					}
	
				};
	
			}() );
	
			this.getRenderTarget = function () {
	
				return _currentRenderTarget;
	
			};
	
			this.setRenderTarget = function ( renderTarget ) {
	
				_currentRenderTarget = renderTarget;
	
				if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
	
					textures.setupRenderTarget( renderTarget );
	
				}
	
				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				var framebuffer;
	
				if ( renderTarget ) {
	
					var renderTargetProperties = properties.get( renderTarget );
	
					if ( isCube ) {
	
						framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
					} else {
	
						framebuffer = renderTargetProperties.__webglFramebuffer;
	
					}
	
					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;
	
					_currentViewport.copy( renderTarget.viewport );
	
				} else {
	
					framebuffer = null;
	
					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
					_currentScissorTest = _scissorTest;
	
					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
	
				}
	
				if ( _currentFramebuffer !== framebuffer ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
					_currentFramebuffer = framebuffer;
	
				}
	
				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );
	
				state.viewport( _currentViewport );
	
				if ( isCube ) {
	
					var textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );
	
				}
	
			};
	
			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
	
				if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {
	
					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;
	
				}
	
				var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
				if ( framebuffer ) {
	
					var restore = false;
	
					if ( framebuffer !== _currentFramebuffer ) {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
						restore = true;
	
					}
	
					try {
	
						var texture = renderTarget.texture;
						var textureFormat = texture.format;
						var textureType = texture.type;
	
						if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;
	
						}
	
						if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
							! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
							! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;
	
						}
	
						if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
	
							// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	
							if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {
	
								_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );
	
							}
	
						} else {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
						}
	
					} finally {
	
						if ( restore ) {
	
							_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
	
						}
	
					}
	
				}
	
			};
	
			// Map three.js constants to WebGL constants
	
			function paramThreeToGL( p ) {
	
				var extension;
	
				if ( p === RepeatWrapping ) return _gl.REPEAT;
				if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
				if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
				if ( p === NearestFilter ) return _gl.NEAREST;
				if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
				if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
				if ( p === LinearFilter ) return _gl.LINEAR;
				if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
				if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
				if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
				if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
				if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
				if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
				if ( p === ByteType ) return _gl.BYTE;
				if ( p === ShortType ) return _gl.SHORT;
				if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
				if ( p === IntType ) return _gl.INT;
				if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
				if ( p === FloatType ) return _gl.FLOAT;
	
				if ( p === HalfFloatType ) {
	
					extension = extensions.get( 'OES_texture_half_float' );
	
					if ( extension !== null ) return extension.HALF_FLOAT_OES;
	
				}
	
				if ( p === AlphaFormat ) return _gl.ALPHA;
				if ( p === RGBFormat ) return _gl.RGB;
				if ( p === RGBAFormat ) return _gl.RGBA;
				if ( p === LuminanceFormat ) return _gl.LUMINANCE;
				if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
				if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
				if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;
	
				if ( p === AddEquation ) return _gl.FUNC_ADD;
				if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
				if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
				if ( p === ZeroFactor ) return _gl.ZERO;
				if ( p === OneFactor ) return _gl.ONE;
				if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
				if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
				if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
				if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
				if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
				if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
				if ( p === DstColorFactor ) return _gl.DST_COLOR;
				if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
				if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
				if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
					p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
					if ( extension !== null ) {
	
						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
					}
	
				}
	
				if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
					p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
					if ( extension !== null ) {
	
						if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
						if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
						if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
						if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
					}
	
				}
	
				if ( p === RGB_ETC1_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
	
					if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
	
				}
	
				if ( p === MinEquation || p === MaxEquation ) {
	
					extension = extensions.get( 'EXT_blend_minmax' );
	
					if ( extension !== null ) {
	
						if ( p === MinEquation ) return extension.MIN_EXT;
						if ( p === MaxEquation ) return extension.MAX_EXT;
	
					}
	
				}
	
				if ( p === UnsignedInt248Type ) {
	
					extension = extensions.get( 'WEBGL_depth_texture' );
	
					if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;
	
				}
	
				return 0;
	
			}
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function FogExp2 ( color, density ) {
	
			this.name = '';
	
			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;
	
		}
	
		FogExp2.prototype.isFogExp2 = true;
	
		FogExp2.prototype.clone = function () {
	
			return new FogExp2( this.color.getHex(), this.density );
	
		};
	
		FogExp2.prototype.toJSON = function ( meta ) {
	
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Fog ( color, near, far ) {
	
			this.name = '';
	
			this.color = new Color( color );
	
			this.near = ( near !== undefined ) ? near : 1;
			this.far = ( far !== undefined ) ? far : 1000;
	
		}
	
		Fog.prototype.isFog = true;
	
		Fog.prototype.clone = function () {
	
			return new Fog( this.color.getHex(), this.near, this.far );
	
		};
	
		Fog.prototype.toJSON = function ( meta ) {
	
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Scene () {
	
			Object3D.call( this );
	
			this.type = 'Scene';
	
			this.background = null;
			this.fog = null;
			this.overrideMaterial = null;
	
			this.autoUpdate = true; // checked by the renderer
	
		}
	
		Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Scene,
	
			copy: function ( source, recursive ) {
	
				Object3D.prototype.copy.call( this, source, recursive );
	
				if ( source.background !== null ) this.background = source.background.clone();
				if ( source.fog !== null ) this.fog = source.fog.clone();
				if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
	
				this.autoUpdate = source.autoUpdate;
				this.matrixAutoUpdate = source.matrixAutoUpdate;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
				if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function LensFlare( texture, size, distance, blending, color ) {
	
			Object3D.call( this );
	
			this.lensFlares = [];
	
			this.positionScreen = new Vector3();
			this.customUpdateCallback = undefined;
	
			if ( texture !== undefined ) {
	
				this.add( texture, size, distance, blending, color );
	
			}
	
		}
	
		LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: LensFlare,
	
			isLensFlare: true,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.positionScreen.copy( source.positionScreen );
				this.customUpdateCallback = source.customUpdateCallback;
	
				for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {
	
					this.lensFlares.push( source.lensFlares[ i ] );
	
				}
	
				return this;
	
			},
	
			add: function ( texture, size, distance, blending, color, opacity ) {
	
				if ( size === undefined ) size = - 1;
				if ( distance === undefined ) distance = 0;
				if ( opacity === undefined ) opacity = 1;
				if ( color === undefined ) color = new Color( 0xffffff );
				if ( blending === undefined ) blending = NormalBlending;
	
				distance = Math.min( distance, Math.max( 0, distance ) );
	
				this.lensFlares.push( {
					texture: texture,	// THREE.Texture
					size: size, 		// size in pixels (-1 = use texture.width)
					distance: distance, 	// distance (0-1) from light source (0=at light source)
					x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
					scale: 1, 		// scale
					rotation: 0, 		// rotation
					opacity: opacity,	// opacity
					color: color,		// color
					blending: blending	// blending
				} );
	
			},
	
			/*
			 * Update lens flares update positions on all flares based on the screen position
			 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
			 */
	
			updateLensFlares: function () {
	
				var f, fl = this.lensFlares.length;
				var flare;
				var vecX = - this.positionScreen.x * 2;
				var vecY = - this.positionScreen.y * 2;
	
				for ( f = 0; f < fl; f ++ ) {
	
					flare = this.lensFlares[ f ];
	
					flare.x = this.positionScreen.x + vecX * flare.distance;
					flare.y = this.positionScreen.y + vecY * flare.distance;
	
					flare.wantedRotation = flare.x * Math.PI * 0.25;
					flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
				}
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *	uvOffset: new THREE.Vector2(),
		 *	uvScale: new THREE.Vector2()
		 * }
		 */
	
		function SpriteMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'SpriteMaterial';
	
			this.color = new Color( 0xffffff );
			this.map = null;
	
			this.rotation = 0;
	
			this.fog = false;
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		SpriteMaterial.prototype = Object.create( Material.prototype );
		SpriteMaterial.prototype.constructor = SpriteMaterial;
		SpriteMaterial.prototype.isSpriteMaterial = true;
	
		SpriteMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.map = source.map;
	
			this.rotation = source.rotation;
	
			return this;
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Sprite( material ) {
	
			Object3D.call( this );
	
			this.type = 'Sprite';
	
			this.material = ( material !== undefined ) ? material : new SpriteMaterial();
	
		}
	
		Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Sprite,
	
			isSprite: true,
	
			raycast: ( function () {
	
				var intersectPoint = new Vector3();
				var worldPosition = new Vector3();
				var worldScale = new Vector3();
	
				return function raycast( raycaster, intersects ) {
	
					worldPosition.setFromMatrixPosition( this.matrixWorld );
					raycaster.ray.closestPointToPoint( worldPosition, intersectPoint );
	
					worldScale.setFromMatrixScale( this.matrixWorld );
					var guessSizeSq = worldScale.x * worldScale.y / 4;
	
					if ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;
	
					var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
					if ( distance < raycaster.near || distance > raycaster.far ) return;
	
					intersects.push( {
	
						distance: distance,
						point: intersectPoint.clone(),
						face: null,
						object: this
	
					} );
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LOD() {
	
			Object3D.call( this );
	
			this.type = 'LOD';
	
			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				}
			} );
	
		}
	
		LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: LOD,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source, false );
	
				var levels = source.levels;
	
				for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
					var level = levels[ i ];
	
					this.addLevel( level.object.clone(), level.distance );
	
				}
	
				return this;
	
			},
	
			addLevel: function ( object, distance ) {
	
				if ( distance === undefined ) distance = 0;
	
				distance = Math.abs( distance );
	
				var levels = this.levels;
	
				for ( var l = 0; l < levels.length; l ++ ) {
	
					if ( distance < levels[ l ].distance ) {
	
						break;
	
					}
	
				}
	
				levels.splice( l, 0, { distance: distance, object: object } );
	
				this.add( object );
	
			},
	
			getObjectForDistance: function ( distance ) {
	
				var levels = this.levels;
	
				for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
					if ( distance < levels[ i ].distance ) {
	
						break;
	
					}
	
				}
	
				return levels[ i - 1 ].object;
	
			},
	
			raycast: ( function () {
	
				var matrixPosition = new Vector3();
	
				return function raycast( raycaster, intersects ) {
	
					matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
					this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
				};
	
			}() ),
	
			update: function () {
	
				var v1 = new Vector3();
				var v2 = new Vector3();
	
				return function update( camera ) {
	
					var levels = this.levels;
	
					if ( levels.length > 1 ) {
	
						v1.setFromMatrixPosition( camera.matrixWorld );
						v2.setFromMatrixPosition( this.matrixWorld );
	
						var distance = v1.distanceTo( v2 );
	
						levels[ 0 ].object.visible = true;
	
						for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
							if ( distance >= levels[ i ].distance ) {
	
								levels[ i - 1 ].object.visible = false;
								levels[ i ].object.visible = true;
	
							} else {
	
								break;
	
							}
	
						}
	
						for ( ; i < l; i ++ ) {
	
							levels[ i ].object.visible = false;
	
						}
	
					}
	
				};
	
			}(),
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.levels = [];
	
				var levels = this.levels;
	
				for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
					var level = levels[ i ];
	
					data.object.levels.push( {
						object: level.object.uuid,
						distance: level.distance
					} );
	
				}
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author michael guerrero / http://realitymeltdown.com
		 * @author ikerr / http://verold.com
		 */
	
		function Skeleton( bones, boneInverses ) {
	
			// copy the bone array
	
			bones = bones || [];
	
			this.bones = bones.slice( 0 );
			this.boneMatrices = new Float32Array( this.bones.length * 16 );
	
			// use the supplied bone inverses or calculate the inverses
	
			if ( boneInverses === undefined ) {
	
				this.calculateInverses();
	
			} else {
	
				if ( this.bones.length === boneInverses.length ) {
	
					this.boneInverses = boneInverses.slice( 0 );
	
				} else {
	
					console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );
	
					this.boneInverses = [];
	
					for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
	
						this.boneInverses.push( new Matrix4() );
	
					}
	
				}
	
			}
	
		}
	
		Object.assign( Skeleton.prototype, {
	
			calculateInverses: function () {
	
				this.boneInverses = [];
	
				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
	
					var inverse = new Matrix4();
	
					if ( this.bones[ i ] ) {
	
						inverse.getInverse( this.bones[ i ].matrixWorld );
	
					}
	
					this.boneInverses.push( inverse );
	
				}
	
			},
	
			pose: function () {
	
				var bone, i, il;
	
				// recover the bind-time world matrices
	
				for ( i = 0, il = this.bones.length; i < il; i ++ ) {
	
					bone = this.bones[ i ];
	
					if ( bone ) {
	
						bone.matrixWorld.getInverse( this.boneInverses[ i ] );
	
					}
	
				}
	
				// compute the local matrices, positions, rotations and scales
	
				for ( i = 0, il = this.bones.length; i < il; i ++ ) {
	
					bone = this.bones[ i ];
	
					if ( bone ) {
	
						if ( bone.parent && bone.parent.isBone ) {
	
							bone.matrix.getInverse( bone.parent.matrixWorld );
							bone.matrix.multiply( bone.matrixWorld );
	
						} else {
	
							bone.matrix.copy( bone.matrixWorld );
	
						}
	
						bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
					}
	
				}
	
			},
	
			update: ( function () {
	
				var offsetMatrix = new Matrix4();
				var identityMatrix = new Matrix4();
	
				return function update() {
	
					var bones = this.bones;
					var boneInverses = this.boneInverses;
					var boneMatrices = this.boneMatrices;
					var boneTexture = this.boneTexture;
	
					// flatten bone matrices to array
	
					for ( var i = 0, il = bones.length; i < il; i ++ ) {
	
						// compute the offset between the current and the original transform
	
						var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;
	
						offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
						offsetMatrix.toArray( boneMatrices, i * 16 );
	
					}
	
					if ( boneTexture !== undefined ) {
	
						boneTexture.needsUpdate = true;
	
					}
	
				};
	
			} )(),
	
			clone: function () {
	
				return new Skeleton( this.bones, this.boneInverses );
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */
	
		function Bone() {
	
			Object3D.call( this );
	
			this.type = 'Bone';
	
		}
	
		Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Bone,
	
			isBone: true
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */
	
		function SkinnedMesh( geometry, material ) {
	
			Mesh.call( this, geometry, material );
	
			this.type = 'SkinnedMesh';
	
			this.bindMode = 'attached';
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();
	
			var bones = this.initBones();
			var skeleton = new Skeleton( bones );
	
			this.bind( skeleton, this.matrixWorld );
	
			this.normalizeSkinWeights();
	
		}
	
		SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {
	
			constructor: SkinnedMesh,
	
			isSkinnedMesh: true,
	
			initBones: function () {
	
				var bones = [], bone, gbone;
				var i, il;
	
				if ( this.geometry && this.geometry.bones !== undefined ) {
	
					// first, create array of 'Bone' objects from geometry data
	
					for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {
	
						gbone = this.geometry.bones[ i ];
	
						// create new 'Bone' object
	
						bone = new Bone();
						bones.push( bone );
	
						// apply values
	
						bone.name = gbone.name;
						bone.position.fromArray( gbone.pos );
						bone.quaternion.fromArray( gbone.rotq );
						if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
	
					}
	
					// second, create bone hierarchy
	
					for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {
	
						gbone = this.geometry.bones[ i ];
	
						if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {
	
							// subsequent bones in the hierarchy
	
							bones[ gbone.parent ].add( bones[ i ] );
	
						} else {
	
							// topmost bone, immediate child of the skinned mesh
	
							this.add( bones[ i ] );
	
						}
	
					}
	
				}
	
				// now the bones are part of the scene graph and children of the skinned mesh.
				// let's update the corresponding matrices
	
				this.updateMatrixWorld( true );
	
				return bones;
	
			},
	
			bind: function ( skeleton, bindMatrix ) {
	
				this.skeleton = skeleton;
	
				if ( bindMatrix === undefined ) {
	
					this.updateMatrixWorld( true );
	
					this.skeleton.calculateInverses();
	
					bindMatrix = this.matrixWorld;
	
				}
	
				this.bindMatrix.copy( bindMatrix );
				this.bindMatrixInverse.getInverse( bindMatrix );
	
			},
	
			pose: function () {
	
				this.skeleton.pose();
	
			},
	
			normalizeSkinWeights: function () {
	
				var scale, i;
	
				if ( this.geometry && this.geometry.isGeometry ) {
	
					for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {
	
						var sw = this.geometry.skinWeights[ i ];
	
						scale = 1.0 / sw.lengthManhattan();
	
						if ( scale !== Infinity ) {
	
							sw.multiplyScalar( scale );
	
						} else {
	
							sw.set( 1, 0, 0, 0 ); // do something reasonable
	
						}
	
					}
	
				} else if ( this.geometry && this.geometry.isBufferGeometry ) {
	
					var vec = new Vector4();
	
					var skinWeight = this.geometry.attributes.skinWeight;
	
					for ( i = 0; i < skinWeight.count; i ++ ) {
	
						vec.x = skinWeight.getX( i );
						vec.y = skinWeight.getY( i );
						vec.z = skinWeight.getZ( i );
						vec.w = skinWeight.getW( i );
	
						scale = 1.0 / vec.lengthManhattan();
	
						if ( scale !== Infinity ) {
	
							vec.multiplyScalar( scale );
	
						} else {
	
							vec.set( 1, 0, 0, 0 ); // do something reasonable
	
						}
	
						skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );
	
					}
	
				}
	
			},
	
			updateMatrixWorld: function ( force ) {
	
				Mesh.prototype.updateMatrixWorld.call( this, force );
	
				if ( this.bindMode === 'attached' ) {
	
					this.bindMatrixInverse.getInverse( this.matrixWorld );
	
				} else if ( this.bindMode === 'detached' ) {
	
					this.bindMatrixInverse.getInverse( this.bindMatrix );
	
				} else {
	
					console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *  linecap: "round",
		 *  linejoin: "round"
		 * }
		 */
	
		function LineBasicMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'LineBasicMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		LineBasicMaterial.prototype = Object.create( Material.prototype );
		LineBasicMaterial.prototype.constructor = LineBasicMaterial;
	
		LineBasicMaterial.prototype.isLineBasicMaterial = true;
	
		LineBasicMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Line( geometry, material, mode ) {
	
			if ( mode === 1 ) {
	
				console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
				return new LineSegments( geometry, material );
	
			}
	
			Object3D.call( this );
	
			this.type = 'Line';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
		}
	
		Line.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Line,
	
			isLine: true,
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				return function raycast( raycaster, intersects ) {
	
					var precision = raycaster.linePrecision;
					var precisionSq = precision * precision;
	
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					var vStart = new Vector3();
					var vEnd = new Vector3();
					var interSegment = new Vector3();
					var interRay = new Vector3();
					var step = (this && this.isLineSegments) ? 2 : 1;
	
					if ( geometry.isBufferGeometry ) {
	
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;
	
						if ( index !== null ) {
	
							var indices = index.array;
	
							for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
	
								var a = indices[ i ];
								var b = indices[ i + 1 ];
	
								vStart.fromArray( positions, a * 3 );
								vEnd.fromArray( positions, b * 3 );
	
								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
								if ( distSq > precisionSq ) continue;
	
								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
								var distance = raycaster.ray.origin.distanceTo( interRay );
	
								if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
								intersects.push( {
	
									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this
	
								} );
	
							}
	
						} else {
	
							for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
	
								vStart.fromArray( positions, 3 * i );
								vEnd.fromArray( positions, 3 * i + 3 );
	
								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
								if ( distSq > precisionSq ) continue;
	
								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
								var distance = raycaster.ray.origin.distanceTo( interRay );
	
								if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
								intersects.push( {
	
									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this
	
								} );
	
							}
	
						}
	
					} else if ( geometry.isGeometry ) {
	
						var vertices = geometry.vertices;
						var nbVertices = vertices.length;
	
						for ( var i = 0; i < nbVertices - 1; i += step ) {
	
							var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
							if ( distSq > precisionSq ) continue;
	
							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
							var distance = raycaster.ray.origin.distanceTo( interRay );
	
							if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LineSegments( geometry, material ) {
	
			Line.call( this, geometry, material );
	
			this.type = 'LineSegments';
	
		}
	
		LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {
	
			constructor: LineSegments,
	
			isLineSegments: true
	
		} );
	
		/**
		 * @author mgreter / http://github.com/mgreter
		 */
	
		function LineLoop( geometry, material ) {
	
			Line.call( this, geometry, material );
	
			this.type = 'LineLoop';
	
		}
	
		LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {
	
			constructor: LineLoop,
	
			isLineLoop: true,
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  size: <float>,
		 *  sizeAttenuation: <bool>
		 * }
		 */
	
		function PointsMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'PointsMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.map = null;
	
			this.size = 1;
			this.sizeAttenuation = true;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		PointsMaterial.prototype = Object.create( Material.prototype );
		PointsMaterial.prototype.constructor = PointsMaterial;
	
		PointsMaterial.prototype.isPointsMaterial = true;
	
		PointsMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
	
			return this;
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Points( geometry, material ) {
	
			Object3D.call( this );
	
			this.type = 'Points';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );
	
		}
	
		Points.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Points,
	
			isPoints: true,
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				return function raycast( raycaster, intersects ) {
	
					var object = this;
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
					var threshold = raycaster.params.Points.threshold;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
					sphere.radius += threshold;
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
					var localThresholdSq = localThreshold * localThreshold;
					var position = new Vector3();
	
					function testPoint( point, index ) {
	
						var rayPointDistanceSq = ray.distanceSqToPoint( point );
	
						if ( rayPointDistanceSq < localThresholdSq ) {
	
							var intersectPoint = ray.closestPointToPoint( point );
							intersectPoint.applyMatrix4( matrixWorld );
	
							var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
							if ( distance < raycaster.near || distance > raycaster.far ) return;
	
							intersects.push( {
	
								distance: distance,
								distanceToRay: Math.sqrt( rayPointDistanceSq ),
								point: intersectPoint.clone(),
								index: index,
								face: null,
								object: object
	
							} );
	
						}
	
					}
	
					if ( geometry.isBufferGeometry ) {
	
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;
	
						if ( index !== null ) {
	
							var indices = index.array;
	
							for ( var i = 0, il = indices.length; i < il; i ++ ) {
	
								var a = indices[ i ];
	
								position.fromArray( positions, a * 3 );
	
								testPoint( position, a );
	
							}
	
						} else {
	
							for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
	
								position.fromArray( positions, i * 3 );
	
								testPoint( position, i );
	
							}
	
						}
	
					} else {
	
						var vertices = geometry.vertices;
	
						for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
							testPoint( vertices[ i ], i );
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Group() {
	
			Object3D.call( this );
	
			this.type = 'Group';
	
		}
	
		Group.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Group
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
			Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.generateMipmaps = false;
	
			var scope = this;
	
			function update() {
	
				requestAnimationFrame( update );
	
				if ( video.readyState >= video.HAVE_CURRENT_DATA ) {
	
					scope.needsUpdate = true;
	
				}
	
			}
	
			update();
	
		}
	
		VideoTexture.prototype = Object.create( Texture.prototype );
		VideoTexture.prototype.constructor = VideoTexture;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;
	
			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )
	
			this.flipY = false;
	
			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files
	
			this.generateMipmaps = false;
	
		}
	
		CompressedTexture.prototype = Object.create( Texture.prototype );
		CompressedTexture.prototype.constructor = CompressedTexture;
	
		CompressedTexture.prototype.isCompressedTexture = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
			Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.needsUpdate = true;
	
		}
	
		CanvasTexture.prototype = Object.create( Texture.prototype );
		CanvasTexture.prototype.constructor = CanvasTexture;
	
		/**
		 * @author Matt DesLauriers / @mattdesl
		 * @author atix / arthursilber.de
		 */
	
		function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {
	
			format = format !== undefined ? format : DepthFormat;
	
			if ( format !== DepthFormat && format !== DepthStencilFormat ) {
	
				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )
	
			}
	
			if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
			if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.image = { width: width, height: height };
	
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
			this.flipY = false;
			this.generateMipmaps	= false;
	
		}
	
		DepthTexture.prototype = Object.create( Texture.prototype );
		DepthTexture.prototype.constructor = DepthTexture;
		DepthTexture.prototype.isDepthTexture = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function WireframeGeometry( geometry ) {
	
			BufferGeometry.call( this );
	
			this.type = 'WireframeGeometry';
	
			// buffer
	
			var vertices = [];
	
			// helper variables
	
			var i, j, l, o, ol;
			var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
			var key, keys = [ 'a', 'b', 'c' ];
			var vertex;
	
			// different logic for Geometry and BufferGeometry
	
			if ( geometry && geometry.isGeometry ) {
	
				// create a data structure that contains all edges without duplicates
	
				var faces = geometry.faces;
	
				for ( i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					for ( j = 0; j < 3; j ++ ) {
	
						edge1 = face[ keys[ j ] ];
						edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
						edge[ 1 ] = Math.max( edge1, edge2 );
	
						key = edge[ 0 ] + ',' + edge[ 1 ];
	
						if ( edges[ key ] === undefined ) {
	
							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
	
						}
	
					}
	
				}
	
				// generate vertices
	
				for ( key in edges ) {
	
					e = edges[ key ];
	
					vertex = geometry.vertices[ e.index1 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					vertex = geometry.vertices[ e.index2 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			} else if ( geometry && geometry.isBufferGeometry ) {
	
				var position, indices, groups;
				var group, start, count;
				var index1, index2;
	
				vertex = new Vector3();
	
				if ( geometry.index !== null ) {
	
					// indexed BufferGeometry
	
					position = geometry.attributes.position;
					indices = geometry.index;
					groups = geometry.groups;
	
					if ( groups.length === 0 ) {
	
						groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];
	
					}
	
					// create a data structure that contains all eges without duplicates
	
					for ( o = 0, ol = groups.length; o < ol; ++ o ) {
	
						group = groups[ o ];
	
						start = group.start;
						count = group.count;
	
						for ( i = start, l = ( start + count ); i < l; i += 3 ) {
	
							for ( j = 0; j < 3; j ++ ) {
	
								edge1 = indices.getX( i + j );
								edge2 = indices.getX( i + ( j + 1 ) % 3 );
								edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
								edge[ 1 ] = Math.max( edge1, edge2 );
	
								key = edge[ 0 ] + ',' + edge[ 1 ];
	
								if ( edges[ key ] === undefined ) {
	
									edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
	
								}
	
							}
	
						}
	
					}
	
					// generate vertices
	
					for ( key in edges ) {
	
						e = edges[ key ];
	
						vertex.fromBufferAttribute( position, e.index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );
	
						vertex.fromBufferAttribute( position, e.index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );
	
					}
	
				} else {
	
					// non-indexed BufferGeometry
	
					position = geometry.attributes.position;
	
					for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {
	
						for ( j = 0; j < 3; j ++ ) {
	
							// three edges per triangle, an edge is represented as (index1, index2)
							// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
	
							index1 = 3 * i + j;
							vertex.fromBufferAttribute( position, index1 );
							vertices.push( vertex.x, vertex.y, vertex.z );
	
							index2 = 3 * i + ( ( j + 1 ) % 3 );
							vertex.fromBufferAttribute( position, index2 );
							vertices.push( vertex.x, vertex.y, vertex.z );
	
						}
	
					}
	
				}
	
			}
	
			// build geometry
	
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	
		}
	
		WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
		WireframeGeometry.prototype.constructor = WireframeGeometry;
	
		/**
		 * @author zz85 / https://github.com/zz85
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */
	
		// ParametricGeometry
	
		function ParametricGeometry( func, slices, stacks ) {
	
			Geometry.call( this );
	
			this.type = 'ParametricGeometry';
	
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};
	
			this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
			this.mergeVertices();
	
		}
	
		ParametricGeometry.prototype = Object.create( Geometry.prototype );
		ParametricGeometry.prototype.constructor = ParametricGeometry;
	
		// ParametricBufferGeometry
	
		function ParametricBufferGeometry( func, slices, stacks ) {
	
			BufferGeometry.call( this );
	
			this.type = 'ParametricBufferGeometry';
	
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			var EPS = 0.00001;
	
			var normal = new Vector3();
	
			var p0 = new Vector3(), p1 = new Vector3();
			var pu = new Vector3(), pv = new Vector3();
	
			var i, j;
	
			// generate vertices, normals and uvs
	
			var sliceCount = slices + 1;
	
			for ( i = 0; i <= stacks; i ++ ) {
	
				var v = i / stacks;
	
				for ( j = 0; j <= slices; j ++ ) {
	
					var u = j / slices;
	
					// vertex
	
					p0 = func( u, v, p0 );
					vertices.push( p0.x, p0.y, p0.z );
	
					// normal
	
					// approximate tangent vectors via finite differences
	
					if ( u - EPS >= 0 ) {
	
						p1 = func( u - EPS, v, p1 );
						pu.subVectors( p0, p1 );
	
					} else {
	
						p1 = func( u + EPS, v, p1 );
						pu.subVectors( p1, p0 );
	
					}
	
					if ( v - EPS >= 0 ) {
	
						p1 = func( u, v - EPS, p1 );
						pv.subVectors( p0, p1 );
	
					} else {
	
						p1 = func( u, v + EPS, p1 );
						pv.subVectors( p1, p0 );
	
					}
	
					// cross product of tangent vectors returns surface normal
	
					normal.crossVectors( pu, pv ).normalize();
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( u, v );
	
				}
	
			}
	
			// generate indices
	
			for ( i = 0; i < stacks; i ++ ) {
	
				for ( j = 0; j < slices; j ++ ) {
	
					var a = i * sliceCount + j;
					var b = i * sliceCount + j + 1;
					var c = ( i + 1 ) * sliceCount + j + 1;
					var d = ( i + 1 ) * sliceCount + j;
	
					// faces one and two
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
	
		/**
		 * @author clockworkgeek / https://github.com/clockworkgeek
		 * @author timothypratley / https://github.com/timothypratley
		 * @author WestLangley / http://github.com/WestLangley
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// PolyhedronGeometry
	
		function PolyhedronGeometry( vertices, indices, radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'PolyhedronGeometry';
	
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
			this.mergeVertices();
	
		}
	
		PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
		PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
	
		// PolyhedronBufferGeometry
	
		function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {
	
			BufferGeometry.call( this );
	
			this.type = 'PolyhedronBufferGeometry';
	
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};
	
			radius = radius || 1;
			detail = detail || 0;
	
			// default buffer data
	
			var vertexBuffer = [];
			var uvBuffer = [];
	
			// the subdivision creates the vertex buffer data
	
			subdivide( detail );
	
			// all vertices should lie on a conceptual sphere with a given radius
	
			appplyRadius( radius );
	
			// finally, create the uv data
	
			generateUVs();
	
			// build non-indexed geometry
	
			this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
	
			if ( detail === 0 ) {
	
				this.computeVertexNormals(); // flat normals
	
			} else {
	
				this.normalizeNormals(); // smooth normals
	
			}
	
			// helper functions
	
			function subdivide( detail ) {
	
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
	
				// iterate over all faces and apply a subdivison with the given detail value
	
				for ( var i = 0; i < indices.length; i += 3 ) {
	
					// get the vertices of the face
	
					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );
	
					// perform subdivision
	
					subdivideFace( a, b, c, detail );
	
				}
	
			}
	
			function subdivideFace( a, b, c, detail ) {
	
				var cols = Math.pow( 2, detail );
	
				// we use this multidimensional array as a data structure for creating the subdivision
	
				var v = [];
	
				var i, j;
	
				// construct all of the vertices for this subdivision
	
				for ( i = 0; i <= cols; i ++ ) {
	
					v[ i ] = [];
	
					var aj = a.clone().lerp( c, i / cols );
					var bj = b.clone().lerp( c, i / cols );
	
					var rows = cols - i;
	
					for ( j = 0; j <= rows; j ++ ) {
	
						if ( j === 0 && i === cols ) {
	
							v[ i ][ j ] = aj;
	
						} else {
	
							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );
	
						}
	
					}
	
				}
	
				// construct all of the faces
	
				for ( i = 0; i < cols; i ++ ) {
	
					for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
	
						var k = Math.floor( j / 2 );
	
						if ( j % 2 === 0 ) {
	
							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );
	
						} else {
	
							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
	
						}
	
					}
	
				}
	
			}
	
			function appplyRadius( radius ) {
	
				var vertex = new Vector3();
	
				// iterate over the entire buffer and apply the radius to each vertex
	
				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];
	
					vertex.normalize().multiplyScalar( radius );
	
					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;
	
				}
	
			}
	
			function generateUVs() {
	
				var vertex = new Vector3();
	
				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];
	
					var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					var v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );
	
				}
	
				correctUVs();
	
				correctSeam();
	
			}
	
			function correctSeam() {
	
				// handle case when face straddles the seam, see #3269
	
				for ( var i = 0; i < uvBuffer.length; i += 6 ) {
	
					// uv data of a single face
	
					var x0 = uvBuffer[ i + 0 ];
					var x1 = uvBuffer[ i + 2 ];
					var x2 = uvBuffer[ i + 4 ];
	
					var max = Math.max( x0, x1, x2 );
					var min = Math.min( x0, x1, x2 );
	
					// 0.9 is somewhat arbitrary
	
					if ( max > 0.9 && min < 0.1 ) {
	
						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;
	
					}
	
				}
	
			}
	
			function pushVertex( vertex ) {
	
				vertexBuffer.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			function getVertexByIndex( index, vertex ) {
	
				var stride = index * 3;
	
				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];
	
			}
	
			function correctUVs() {
	
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
	
				var centroid = new Vector3();
	
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();
	
				for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {
	
					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );
	
					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );
	
					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );
	
					var azi = azimuth( centroid );
	
					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );
	
				}
	
			}
	
			function correctUV( uv, stride, vector, azimuth ) {
	
				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {
	
					uvBuffer[ stride ] = uv.x - 1;
	
				}
	
				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {
	
					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;
	
				}
	
			}
	
			// Angle around the Y axis, counter-clockwise when looking from above.
	
			function azimuth( vector ) {
	
				return Math.atan2( vector.z, - vector.x );
	
			}
	
	
			// Angle above the XZ plane.
	
			function inclination( vector ) {
	
				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
			}
	
		}
	
		PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// TetrahedronGeometry
	
		function TetrahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'TetrahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
		TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
	
		// TetrahedronBufferGeometry
	
		function TetrahedronBufferGeometry( radius, detail ) {
	
			var vertices = [
				1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
			];
	
			var indices = [
				2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'TetrahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// OctahedronGeometry
	
		function OctahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'OctahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		OctahedronGeometry.prototype = Object.create( Geometry.prototype );
		OctahedronGeometry.prototype.constructor = OctahedronGeometry;
	
		// OctahedronBufferGeometry
	
		function OctahedronBufferGeometry( radius, detail ) {
	
			var vertices = [
				1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
			];
	
			var indices = [
				0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'OctahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// IcosahedronGeometry
	
		function IcosahedronGeometry( radius, detail ) {
	
		 	Geometry.call( this );
	
			this.type = 'IcosahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
		IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
	
		// IcosahedronBufferGeometry
	
		function IcosahedronBufferGeometry( radius, detail ) {
	
			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
			var vertices = [
				- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
				 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
				 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
			];
	
			var indices = [
				 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
				 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
				 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
				 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'IcosahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
	
		/**
		 * @author Abe Pazos / https://hamoid.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// DodecahedronGeometry
	
		function DodecahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'DodecahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
		DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
	
		// DodecahedronBufferGeometry
	
		function DodecahedronBufferGeometry( radius, detail ) {
	
			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
			var r = 1 / t;
	
			var vertices = [
	
				// (1, 1, 1)
				- 1, - 1, - 1,    - 1, - 1,  1,
				- 1,  1, - 1,    - 1,  1,  1,
				  1, - 1, - 1,     1, - 1,  1,
				  1,  1, - 1,     1,  1,  1,
	
				// (0, 1/, )
				 0, - r, - t,     0, - r,  t,
				 0,  r, - t,     0,  r,  t,
	
				// (1/, , 0)
				- r, - t,  0,    - r,  t,  0,
				 r, - t,  0,     r,  t,  0,
	
				// (, 0, 1/)
				- t,  0, - r,     t,  0, - r,
				- t,  0,  r,     t,  0,  r
			];
	
			var indices = [
				 3, 11,  7,      3,  7, 15,      3, 15, 13,
				 7, 19, 17,      7, 17,  6,      7,  6, 15,
				17,  4,  8,     17,  8, 10,     17, 10,  6,
				 8,  0, 16,      8, 16,  2,      8,  2, 10,
				 0, 12,  1,      0,  1, 18,      0, 18, 16,
				 6, 10,  2,      6,  2, 13,      6, 13, 15,
				 2, 16, 18,      2, 18,  3,      2,  3, 13,
				18,  1,  9,     18,  9, 11,     18, 11,  3,
				 4, 14, 12,      4, 12,  0,      4,  0,  8,
				11,  9,  5,     11,  5, 19,     11, 19,  7,
				19,  5, 14,     19, 14,  4,     19,  4, 17,
				 1, 12, 14,      1, 14,  5,      1,  5,  9
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'DodecahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
	
		/**
		 * @author oosmoxiecode / https://github.com/oosmoxiecode
		 * @author WestLangley / https://github.com/WestLangley
		 * @author zz85 / https://github.com/zz85
		 * @author miningold / https://github.com/miningold
		 * @author jonobr1 / https://github.com/jonobr1
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 */
	
		// TubeGeometry
	
		function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {
	
			Geometry.call( this );
	
			this.type = 'TubeGeometry';
	
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
	
			if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );
	
			var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );
	
			// expose internals
	
			this.tangents = bufferGeometry.tangents;
			this.normals = bufferGeometry.normals;
			this.binormals = bufferGeometry.binormals;
	
			// create geometry
	
			this.fromBufferGeometry( bufferGeometry );
			this.mergeVertices();
	
		}
	
		TubeGeometry.prototype = Object.create( Geometry.prototype );
		TubeGeometry.prototype.constructor = TubeGeometry;
	
		// TubeBufferGeometry
	
		function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TubeBufferGeometry';
	
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
	
			tubularSegments = tubularSegments || 64;
			radius = radius || 1;
			radialSegments = radialSegments || 8;
			closed = closed || false;
	
			var frames = path.computeFrenetFrames( tubularSegments, closed );
	
			// expose internals
	
			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;
	
			// helper variables
	
			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
	
			var i, j;
	
			// buffer
	
			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];
	
			// create buffer data
	
			generateBufferData();
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// functions
	
			function generateBufferData() {
	
				for ( i = 0; i < tubularSegments; i ++ ) {
	
					generateSegment( i );
	
				}
	
				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
	
				generateSegment( ( closed === false ) ? tubularSegments : 0 );
	
				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries
	
				generateUVs();
	
				// finally create faces
	
				generateIndices();
	
			}
	
			function generateSegment( i ) {
	
				// we use getPointAt to sample evenly distributed points from the given path
	
				var P = path.getPointAt( i / tubularSegments );
	
				// retrieve corresponding normal and binormal
	
				var N = frames.normals[ i ];
				var B = frames.binormals[ i ];
	
				// generate normals and vertices for the current segment
	
				for ( j = 0; j <= radialSegments; j ++ ) {
	
					var v = j / radialSegments * Math.PI * 2;
	
					var sin =   Math.sin( v );
					var cos = - Math.cos( v );
	
					// normal
	
					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// vertex
	
					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			}
	
			function generateIndices() {
	
				for ( j = 1; j <= tubularSegments; j ++ ) {
	
					for ( i = 1; i <= radialSegments; i ++ ) {
	
						var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						var b = ( radialSegments + 1 ) * j + ( i - 1 );
						var c = ( radialSegments + 1 ) * j + i;
						var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
					}
	
				}
	
			}
	
			function generateUVs() {
	
				for ( i = 0; i <= tubularSegments; i ++ ) {
	
					for ( j = 0; j <= radialSegments; j ++ ) {
	
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
	
						uvs.push( uv.x, uv.y );
	
					}
	
				}
	
			}
	
		}
	
		TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
	
		/**
		 * @author oosmoxiecode
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * based on http://www.blackpawn.com/texts/pqtorus/
		 */
	
		// TorusKnotGeometry
	
		function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {
	
			Geometry.call( this );
	
			this.type = 'TorusKnotGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
	
			if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );
	
			this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
			this.mergeVertices();
	
		}
	
		TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
		TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
	
		// TorusKnotBufferGeometry
	
		function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TorusKnotBufferGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
	
			radius = radius || 100;
			tube = tube || 40;
			tubularSegments = Math.floor( tubularSegments ) || 64;
			radialSegments = Math.floor( radialSegments ) || 8;
			p = p || 2;
			q = q || 3;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var i, j;
	
			var vertex = new Vector3();
			var normal = new Vector3();
	
			var P1 = new Vector3();
			var P2 = new Vector3();
	
			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3();
	
			// generate vertices, normals and uvs
	
			for ( i = 0; i <= tubularSegments; ++ i ) {
	
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
	
				var u = i / tubularSegments * p * Math.PI * 2;
	
				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
	
				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );
	
				// calculate orthonormal basis
	
				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );
	
				// normalize B, N. T can be ignored, we don't use it
	
				B.normalize();
				N.normalize();
	
				for ( j = 0; j <= radialSegments; ++ j ) {
	
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
	
					var v = j / radialSegments * Math.PI * 2;
					var cx = - tube * Math.cos( v );
					var cy = tube * Math.sin( v );
	
					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
	
					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
	
					normal.subVectors( vertex, P1 ).normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );
	
				}
	
			}
	
			// generate indices
	
			for ( j = 1; j <= tubularSegments; j ++ ) {
	
				for ( i = 1; i <= radialSegments; i ++ ) {
	
					// indices
	
					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// this function calculates the current position on the torus curve
	
			function calculatePositionOnCurve( u, p, q, radius, position ) {
	
				var cu = Math.cos( u );
				var su = Math.sin( u );
				var quOverP = q / p * u;
				var cs = Math.cos( quOverP );
	
				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;
	
			}
	
		}
	
		TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
	
		/**
		 * @author oosmoxiecode
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// TorusGeometry
	
		function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
			Geometry.call( this );
	
			this.type = 'TorusGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
	
			this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
			this.mergeVertices();
	
		}
	
		TorusGeometry.prototype = Object.create( Geometry.prototype );
		TorusGeometry.prototype.constructor = TorusGeometry;
	
		// TorusBufferGeometry
	
		function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TorusBufferGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
	
			radius = radius || 100;
			tube = tube || 40;
			radialSegments = Math.floor( radialSegments ) || 8;
			tubularSegments = Math.floor( tubularSegments ) || 6;
			arc = arc || Math.PI * 2;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3();
	
			var j, i;
	
			// generate vertices, normals and uvs
	
			for ( j = 0; j <= radialSegments; j ++ ) {
	
				for ( i = 0; i <= tubularSegments; i ++ ) {
	
					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2;
	
					// vertex
	
					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );
					normal.subVectors( vertex, center ).normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );
	
				}
	
			}
	
			// generate indices
	
			for ( j = 1; j <= radialSegments; j ++ ) {
	
				for ( i = 1; i <= tubularSegments; i ++ ) {
	
					// indices
	
					var a = ( tubularSegments + 1 ) * j + i - 1;
					var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					var d = ( tubularSegments + 1 ) * j + i;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */
	
		var ShapeUtils = {
	
			// calculate area of the contour polygon
	
			area: function ( contour ) {
	
				var n = contour.length;
				var a = 0.0;
	
				for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
					a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
				}
	
				return a * 0.5;
	
			},
	
			triangulate: ( function () {
	
				/**
				 * This code is a quick port of code written in C++ which was submitted to
				 * flipcode.com by John W. Ratcliff  // July 22, 2000
				 * See original code and more information here:
				 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
				 *
				 * ported to actionscript by Zevan Rosser
				 * www.actionsnippet.com
				 *
				 * ported to javascript by Joshua Koo
				 * http://www.lab4games.net/zz85/blog
				 *
				 */
	
				function snip( contour, u, v, w, n, verts ) {
	
					var p;
					var ax, ay, bx, by;
					var cx, cy, px, py;
	
					ax = contour[ verts[ u ] ].x;
					ay = contour[ verts[ u ] ].y;
	
					bx = contour[ verts[ v ] ].x;
					by = contour[ verts[ v ] ].y;
	
					cx = contour[ verts[ w ] ].x;
					cy = contour[ verts[ w ] ].y;
	
					if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;
	
					var aX, aY, bX, bY, cX, cY;
					var apx, apy, bpx, bpy, cpx, cpy;
					var cCROSSap, bCROSScp, aCROSSbp;
	
					aX = cx - bx;  aY = cy - by;
					bX = ax - cx;  bY = ay - cy;
					cX = bx - ax;  cY = by - ay;
	
					for ( p = 0; p < n; p ++ ) {
	
						px = contour[ verts[ p ] ].x;
						py = contour[ verts[ p ] ].y;
	
						if ( ( ( px === ax ) && ( py === ay ) ) ||
							 ( ( px === bx ) && ( py === by ) ) ||
							 ( ( px === cx ) && ( py === cy ) ) )	continue;
	
						apx = px - ax;  apy = py - ay;
						bpx = px - bx;  bpy = py - by;
						cpx = px - cx;  cpy = py - cy;
	
						// see if p is inside triangle abc
	
						aCROSSbp = aX * bpy - aY * bpx;
						cCROSSap = cX * apy - cY * apx;
						bCROSScp = bX * cpy - bY * cpx;
	
						if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;
	
					}
	
					return true;
	
				}
	
				// takes in an contour array and returns
	
				return function triangulate( contour, indices ) {
	
					var n = contour.length;
	
					if ( n < 3 ) return null;
	
					var result = [],
						verts = [],
						vertIndices = [];
	
					/* we want a counter-clockwise polygon in verts */
	
					var u, v, w;
	
					if ( ShapeUtils.area( contour ) > 0.0 ) {
	
						for ( v = 0; v < n; v ++ ) verts[ v ] = v;
	
					} else {
	
						for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
	
					}
	
					var nv = n;
	
					/*  remove nv - 2 vertices, creating 1 triangle every time */
	
					var count = 2 * nv;   /* error detection */
	
					for ( v = nv - 1; nv > 2; ) {
	
						/* if we loop, it is probably a non-simple polygon */
	
						if ( ( count -- ) <= 0 ) {
	
							//** Triangulate: ERROR - probable bad polygon!
	
							//throw ( "Warning, unable to triangulate polygon!" );
							//return null;
							// Sometimes warning is fine, especially polygons are triangulated in reverse.
							console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );
	
							if ( indices ) return vertIndices;
							return result;
	
						}
	
						/* three consecutive vertices in current polygon, <u,v,w> */
	
						u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
						v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
						w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
						if ( snip( contour, u, v, w, nv, verts ) ) {
	
							var a, b, c, s, t;
	
							/* true names of the vertices */
	
							a = verts[ u ];
							b = verts[ v ];
							c = verts[ w ];
	
							/* output Triangle */
	
							result.push( [ contour[ a ],
								contour[ b ],
								contour[ c ] ] );
	
	
							vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
							/* remove v from the remaining polygon */
	
							for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
	
								verts[ s ] = verts[ t ];
	
							}
	
							nv --;
	
							/* reset error detection counter */
	
							count = 2 * nv;
	
						}
	
					}
	
					if ( indices ) return vertIndices;
					return result;
	
				}
	
			} )(),
	
			triangulateShape: function ( contour, holes ) {
	
				function removeDupEndPts(points) {
	
					var l = points.length;
	
					if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {
	
						points.pop();
	
					}
	
				}
	
				removeDupEndPts( contour );
				holes.forEach( removeDupEndPts );
	
				function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
	
					// inOtherPt needs to be collinear to the inSegment
					if ( inSegPt1.x !== inSegPt2.x ) {
	
						if ( inSegPt1.x < inSegPt2.x ) {
	
							return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
	
						} else {
	
							return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
	
						}
	
					} else {
	
						if ( inSegPt1.y < inSegPt2.y ) {
	
							return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
	
						} else {
	
							return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
	
						}
	
					}
	
				}
	
				function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
	
					var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
					var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	
					var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
					var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	
					var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
					var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	
					if ( Math.abs( limit ) > Number.EPSILON ) {
	
						// not parallel
	
						var perpSeg2;
						if ( limit > 0 ) {
	
							if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
	
						} else {
	
							if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
	
						}
	
						// i.e. to reduce rounding errors
						// intersection at endpoint of segment#1?
						if ( perpSeg2 === 0 ) {
	
							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt1 ];
	
						}
						if ( perpSeg2 === limit ) {
	
							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt2 ];
	
						}
						// intersection at endpoint of segment#2?
						if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
						if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];
	
						// return real intersection point
						var factorSeg1 = perpSeg2 / limit;
						return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
									y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
	
					} else {
	
						// parallel or collinear
						if ( ( perpSeg1 !== 0 ) ||
							 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];
	
						// they are collinear or degenerate
						var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
						var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
						// both segments are points
						if ( seg1Pt && seg2Pt ) {
	
							if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
								 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
							return [ inSeg1Pt1 ];                 						// they are the same point
	
						}
						// segment#1  is a single point
						if ( seg1Pt ) {
	
							if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
							return [ inSeg1Pt1 ];
	
						}
						// segment#2  is a single point
						if ( seg2Pt ) {
	
							if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
							return [ inSeg2Pt1 ];
	
						}
	
						// they are collinear segments, which might overlap
						var seg1min, seg1max, seg1minVal, seg1maxVal;
						var seg2min, seg2max, seg2minVal, seg2maxVal;
						if ( seg1dx !== 0 ) {
	
							// the segments are NOT on a vertical line
							if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
	
								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
	
							} else {
	
								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
	
							}
							if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
	
								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
	
							} else {
	
								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
	
							}
	
						} else {
	
							// the segments are on a vertical line
							if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
	
								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
	
							} else {
	
								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
	
							}
							if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
	
								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
	
							} else {
	
								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
	
							}
	
						}
						if ( seg1minVal <= seg2minVal ) {
	
							if ( seg1maxVal <  seg2minVal )	return [];
							if ( seg1maxVal === seg2minVal )	{
	
								if ( inExcludeAdjacentSegs )		return [];
								return [ seg2min ];
	
							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
							return	[ seg2min, seg2max ];
	
						} else {
	
							if ( seg1minVal >  seg2maxVal )	return [];
							if ( seg1minVal === seg2maxVal )	{
	
								if ( inExcludeAdjacentSegs )		return [];
								return [ seg1min ];
	
							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
							return	[ seg1min, seg2max ];
	
						}
	
					}
	
				}
	
				function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
	
					// The order of legs is important
	
					// translation of all points, so that Vertex is at (0,0)
					var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
					var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
					var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;
	
					// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
					var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
					var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
	
					if ( Math.abs( from2toAngle ) > Number.EPSILON ) {
	
						// angle != 180 deg.
	
						var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
						// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	
						if ( from2toAngle > 0 ) {
	
							// main angle < 180 deg.
							return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
	
						} else {
	
							// main angle > 180 deg.
							return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
	
						}
	
					} else {
	
						// angle == 180 deg.
						// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
						return	( from2otherAngle > 0 );
	
					}
	
				}
	
	
				function removeHoles( contour, holes ) {
	
					var shape = contour.concat(); // work on this shape
					var hole;
	
					function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
	
						// Check if hole point lies within angle around shape point
						var lastShapeIdx = shape.length - 1;
	
						var prevShapeIdx = inShapeIdx - 1;
						if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
	
						var nextShapeIdx = inShapeIdx + 1;
						if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
	
						var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
						if ( ! insideAngle ) {
	
							// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
							return	false;
	
						}
	
						// Check if shape point lies within angle around hole point
						var lastHoleIdx = hole.length - 1;
	
						var prevHoleIdx = inHoleIdx - 1;
						if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
	
						var nextHoleIdx = inHoleIdx + 1;
						if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
	
						insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
						if ( ! insideAngle ) {
	
							// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
							return	false;
	
						}
	
						return	true;
	
					}
	
					function intersectsShapeEdge( inShapePt, inHolePt ) {
	
						// checks for intersections with shape edges
						var sIdx, nextIdx, intersection;
						for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
	
							nextIdx = sIdx + 1; nextIdx %= shape.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;
	
						}
	
						return	false;
	
					}
	
					var indepHoles = [];
	
					function intersectsHoleEdge( inShapePt, inHolePt ) {
	
						// checks for intersections with hole edges
						var ihIdx, chkHole,
							hIdx, nextIdx, intersection;
						for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
	
							chkHole = holes[ indepHoles[ ihIdx ]];
							for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
	
								nextIdx = hIdx + 1; nextIdx %= chkHole.length;
								intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
								if ( intersection.length > 0 )		return	true;
	
							}
	
						}
						return	false;
	
					}
	
					var holeIndex, shapeIndex,
						shapePt, holePt,
						holeIdx, cutKey, failedCuts = [],
						tmpShape1, tmpShape2,
						tmpHole1, tmpHole2;
	
					for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
						indepHoles.push( h );
	
					}
	
					var minShapeIndex = 0;
					var counter = indepHoles.length * 2;
					while ( indepHoles.length > 0 ) {
	
						counter --;
						if ( counter < 0 ) {
	
							console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
							break;
	
						}
	
						// search for shape-vertex and hole-vertex,
						// which can be connected without intersections
						for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
	
							shapePt = shape[ shapeIndex ];
							holeIndex	= - 1;
	
							// search for hole which can be reached without intersections
							for ( var h = 0; h < indepHoles.length; h ++ ) {
	
								holeIdx = indepHoles[ h ];
	
								// prevent multiple checks
								cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
								if ( failedCuts[ cutKey ] !== undefined )			continue;
	
								hole = holes[ holeIdx ];
								for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
	
									holePt = hole[ h2 ];
									if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
									if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
									if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
	
									holeIndex = h2;
									indepHoles.splice( h, 1 );
	
									tmpShape1 = shape.slice( 0, shapeIndex + 1 );
									tmpShape2 = shape.slice( shapeIndex );
									tmpHole1 = hole.slice( holeIndex );
									tmpHole2 = hole.slice( 0, holeIndex + 1 );
	
									shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
									minShapeIndex = shapeIndex;
	
									// Debug only, to show the selected cuts
									// glob_CutLines.push( [ shapePt, holePt ] );
	
									break;
	
								}
								if ( holeIndex >= 0 )	break;		// hole-vertex found
	
								failedCuts[ cutKey ] = true;			// remember failure
	
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found
	
						}
	
					}
	
					return shape; 			/* shape with no holes */
	
				}
	
	
				var i, il, f, face,
					key, index,
					allPointsMap = {};
	
				// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
				var allpoints = contour.concat();
	
				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
					Array.prototype.push.apply( allpoints, holes[ h ] );
	
				}
	
				//console.log( "allpoints",allpoints, allpoints.length );
	
				// prepare all points map
	
				for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
					key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
					if ( allPointsMap[ key ] !== undefined ) {
	
						console.warn( "THREE.ShapeUtils: Duplicate point", key, i );
	
					}
	
					allPointsMap[ key ] = i;
	
				}
	
				// remove holes by cutting paths to holes and adding them to the shape
				var shapeWithoutHoles = removeHoles( contour, holes );
	
				var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
				//console.log( "triangles",triangles, triangles.length );
	
				// check all face vertices against all points map
	
				for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
					face = triangles[ i ];
	
					for ( f = 0; f < 3; f ++ ) {
	
						key = face[ f ].x + ":" + face[ f ].y;
	
						index = allPointsMap[ key ];
	
						if ( index !== undefined ) {
	
							face[ f ] = index;
	
						}
	
					}
	
				}
	
				return triangles.concat();
	
			},
	
			isClockWise: function ( pts ) {
	
				return ShapeUtils.area( pts ) < 0;
	
			}
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Creates extruded geometry from a path shape.
		 *
		 * parameters = {
		 *
		 *  curveSegments: <int>, // number of points on the curves
		 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
		 *  amount: <int>, // Depth to extrude the shape
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into the original shape bevel goes
		 *  bevelSize: <float>, // how far from shape outline is bevel
		 *  bevelSegments: <int>, // number of bevel layers
		 *
		 *  extrudePath: <THREE.Curve> // curve to extrude shape along
		 *  frames: <Object> // containing arrays of tangents, normals, binormals
		 *
		 *  UVGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 */
	
		// ExtrudeGeometry
	
		function ExtrudeGeometry( shapes, options ) {
	
			Geometry.call( this );
	
			this.type = 'ExtrudeGeometry';
	
			this.parameters = {
				shapes: shapes,
				options: options
			};
	
			this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
			this.mergeVertices();
	
		}
	
		ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
		ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
	
		// ExtrudeBufferGeometry
	
		function ExtrudeBufferGeometry( shapes, options ) {
	
			if ( typeof ( shapes ) === "undefined" ) {
	
				return;
	
			}
	
			BufferGeometry.call( this );
	
			this.type = 'ExtrudeBufferGeometry';
	
			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	
			this.addShapeList( shapes, options );
	
			this.computeVertexNormals();
	
			// can't really use automatic vertex normals
			// as then front and back sides get smoothed too
			// should do separate smoothing just for sides
	
			//this.computeVertexNormals();
	
			//console.log( "took", ( Date.now() - startTime ) );
	
		}
	
		ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
	
		ExtrudeBufferGeometry.prototype.getArrays = function () {
	
			var positionAttribute = this.getAttribute( "position" );
			var verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];
	
			var uvAttribute = this.getAttribute( "uv" );
			var uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];
	
			var IndexAttribute = this.index;
			var indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];
	
			return {
				position: verticesArray,
				uv: uvArray,
				index: indicesArray
			};
	
		};
	
		ExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {
	
			var sl = shapes.length;
			options.arrays = this.getArrays();
	
			for ( var s = 0; s < sl; s ++ ) {
	
				var shape = shapes[ s ];
				this.addShape( shape, options );
	
			}
	
			this.setIndex( options.arrays.index );
			this.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );
	
		};
	
		ExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {
	
			var arrays = options.arrays ? options.arrays : this.getArrays();
			var verticesArray = arrays.position;
			var indicesArray = arrays.index;
			var uvArray = arrays.uv;
	
			var placeholder = [];
	
	
			var amount = options.amount !== undefined ? options.amount : 100;
	
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
			var steps = options.steps !== undefined ? options.steps : 1;
	
			var extrudePath = options.extrudePath;
			var extrudePts, extrudeByPath = false;
	
			// Use default WorldUVGenerator if no UV generators are specified.
			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
	
			var splineTube, binormal, normal, position2;
			if ( extrudePath ) {
	
				extrudePts = extrudePath.getSpacedPoints( steps );
	
				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion
	
				// SETUP TNB variables
	
				// TODO1 - have a .isClosed in spline?
	
				splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );
	
				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();
	
			}
	
			// Safeguards if bevels are not enabled
	
			if ( ! bevelEnabled ) {
	
				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
	
			}
	
			// Variables initialization
	
			var ahole, h, hl; // looping of holes
			var scope = this;
	
			var shapePoints = shape.extractPoints( curveSegments );
	
			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;
	
			var reverse = ! ShapeUtils.isClockWise( vertices );
	
			if ( reverse ) {
	
				vertices = vertices.reverse();
	
				// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
	
					if ( ShapeUtils.isClockWise( ahole ) ) {
	
						holes[ h ] = ahole.reverse();
	
					}
	
				}
	
			}
	
	
			var faces = ShapeUtils.triangulateShape( vertices, holes );
	
			/* Vertices */
	
			var contour = vertices; // vertices has all points but contour has only points of circumference
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				vertices = vertices.concat( ahole );
	
			}
	
	
			function scalePt2( pt, vec, size ) {
	
				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
				return vec.clone().multiplyScalar( size ).add( pt );
	
			}
	
			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;
	
	
			// Find directions for point movement
	
	
			function getBevelVec( inPt, inPrev, inNext ) {
	
				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.
	
				var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
	
				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html
	
				var v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;
	
				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
	
				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
				if ( Math.abs( collinear0 ) > Number.EPSILON ) {
	
					// not collinear
	
					// length of vectors for normalizing
	
					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
	
					// shift adjacent points by unit vectors to the left
	
					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
	
					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
					// scaling factor for v_prev to intersection point
	
					var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
					// vector from inPt to intersection point
	
					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {
	
						return new Vector2( v_trans_x, v_trans_y );
	
					} else {
	
						shrink_by = Math.sqrt( v_trans_lensq / 2 );
	
					}
	
				} else {
	
					// handle special case of collinear edges
	
					var direction_eq = false; // assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {
	
						if ( v_next_x > Number.EPSILON ) {
	
							direction_eq = true;
	
						}
	
					} else {
	
						if ( v_prev_x < - Number.EPSILON ) {
	
							if ( v_next_x < - Number.EPSILON ) {
	
								direction_eq = true;
	
							}
	
						} else {
	
							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
	
								direction_eq = true;
	
							}
	
						}
	
					}
	
					if ( direction_eq ) {
	
						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );
	
					} else {
	
						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );
	
					}
	
				}
	
				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
			}
	
	
			var contourMovements = [];
	
			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)
	
				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
			}
	
			var holesMovements = [],
				oneHoleMovements, verticesMovements = contourMovements.concat();
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				oneHoleMovements = [];
	
				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
					if ( j === il ) j = 0;
					if ( k === il ) k = 0;
	
					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
				}
	
				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );
	
			}
	
	
			// Loop bevelSegments, 1 for the front, 1 for the back
	
			for ( b = 0; b < bevelSegments; b ++ ) {
	
				//for ( b = bevelSegments; b > 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
					v( vert.x, vert.y, - z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						v( vert.x, vert.y, - z );
	
					}
	
				}
	
			}
	
			bs = bevelSize;
	
			// Back facing vertices
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, 0 );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
			// Add stepped vertices...
			// Including front facing vertices
	
			var s;
	
			for ( s = 1; s <= steps; s ++ ) {
	
				for ( i = 0; i < vlen; i ++ ) {
	
					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y, amount / steps * s );
	
					} else {
	
						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
	
						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
	
						v( position2.x, position2.y, position2.z );
	
					}
	
				}
	
			}
	
	
			// Add bevel segments planes
	
			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, amount + z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						if ( ! extrudeByPath ) {
	
							v( vert.x, vert.y, amount + z );
	
						} else {
	
							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
						}
	
					}
	
				}
	
			}
	
			/* Faces */
	
			// Top and bottom faces
	
			buildLidFaces();
	
			// Sides faces
	
			buildSideFaces();
	
	
			/////  Internal functions
	
			function buildLidFaces() {
	
				var start = verticesArray.length/3;
	
				if ( bevelEnabled ) {
	
					var layer = 0; // steps + 1
					var offset = vlen * layer;
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
					}
	
					layer = steps + bevelSegments * 2;
					offset = vlen * layer;
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
					}
	
				} else {
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
					}
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
					}
	
				}
	
				scope.addGroup( start, verticesArray.length/3 -start, options.material !== undefined ? options.material : 0);
	
			}
	
			// Create faces for the z-sides of the shape
	
			function buildSideFaces() {
	
				var start = verticesArray.length/3;
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );
	
					//, true
					layeroffset += ahole.length;
	
				}
	
	
				scope.addGroup( start, verticesArray.length/3 -start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1);
	
	
			}
	
			function sidewalls( contour, layeroffset ) {
	
				var j, k;
				i = contour.length;
	
				while ( -- i >= 0 ) {
	
					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;
	
					//console.log('b', i,j, i-1, k,vertices.length);
	
					var s = 0,
						sl = steps + bevelSegments * 2;
	
					for ( s = 0; s < sl; s ++ ) {
	
						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );
	
						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;
	
						f4( a, b, c, d, contour, s, sl, j, k );
	
					}
	
				}
	
			}
	
			function v( x, y, z ) {
	
				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );
	
			}
	
	
			function f3( a, b, c ) {
	
				addVertex( a );
				addVertex( b );
				addVertex( c );
	
				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
	
				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
	
			}
	
			function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
				addVertex( a );
				addVertex( b );
				addVertex( d );
	
				addVertex( b );
				addVertex( c );
				addVertex( d );
	
	
				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
	
				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );
	
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );
	
			}
	
			function addVertex( index ) {
	
				indicesArray.push( verticesArray.length / 3 );
				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );
	
			}
	
	
			function addUV( vector2 ) {
	
				uvArray.push( vector2.x );
				uvArray.push( vector2.y );
	
			}
	
			if ( ! options.arrays ) {
	
				this.setIndex( indicesArray );
				this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
				this.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );
	
			}
	
		};
	
		ExtrudeGeometry.WorldUVGenerator = {
	
			generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {
	
				var a_x = vertices[ indexA * 3 ];
				var a_y = vertices[ indexA * 3 + 1 ];
				var b_x = vertices[ indexB * 3 ];
				var b_y = vertices[ indexB * 3 + 1 ];
				var c_x = vertices[ indexC * 3 ];
				var c_y = vertices[ indexC * 3 + 1 ];
	
				return [
					new Vector2( a_x, a_y ),
					new Vector2( b_x, b_y ),
					new Vector2( c_x, c_y )
				];
	
			},
	
			generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {
	
				var a_x = vertices[ indexA * 3 ];
				var a_y = vertices[ indexA * 3 + 1 ];
				var a_z = vertices[ indexA * 3 + 2 ];
				var b_x = vertices[ indexB * 3 ];
				var b_y = vertices[ indexB * 3 + 1 ];
				var b_z = vertices[ indexB * 3 + 2 ];
				var c_x = vertices[ indexC * 3 ];
				var c_y = vertices[ indexC * 3 + 1 ];
				var c_z = vertices[ indexC * 3 + 2 ];
				var d_x = vertices[ indexD * 3 ];
				var d_y = vertices[ indexD * 3 + 1 ];
				var d_z = vertices[ indexD * 3 + 2 ];
	
				if ( Math.abs( a_y - b_y ) < 0.01 ) {
	
					return [
						new Vector2( a_x, 1 - a_z ),
						new Vector2( b_x, 1 - b_z ),
						new Vector2( c_x, 1 - c_z ),
						new Vector2( d_x, 1 - d_z )
					];
	
				} else {
	
					return [
						new Vector2( a_y, 1 - a_z ),
						new Vector2( b_y, 1 - b_z ),
						new Vector2( c_y, 1 - c_z ),
						new Vector2( d_y, 1 - d_z )
					];
	
				}
	
			}
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * Text = 3D Text
		 *
		 * parameters = {
		 *  font: <THREE.Font>, // font
		 *
		 *  size: <float>, // size of the text
		 *  height: <float>, // thickness to extrude text
		 *  curveSegments: <int>, // number of points on the curves
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into text bevel goes
		 *  bevelSize: <float> // how far from text outline is bevel
		 * }
		 */
	
		// TextGeometry
	
		function TextGeometry(  text, parameters ) {
	
			Geometry.call( this );
	
			this.type = 'TextGeometry';
	
			this.parameters = {
				text: text,
				parameters: parameters
			};
	
			this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
			this.mergeVertices();
	
		}
	
		TextGeometry.prototype = Object.create( Geometry.prototype );
		TextGeometry.prototype.constructor = TextGeometry;
	
		// TextBufferGeometry
	
		function TextBufferGeometry( text, parameters ) {
	
			parameters = parameters || {};
	
			var font = parameters.font;
	
			if ( ! ( font && font.isFont ) ) {
	
				console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
				return new Geometry();
	
			}
	
			var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );
	
			// translate parameters to ExtrudeGeometry API
	
			parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
			// defaults
	
			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
			ExtrudeBufferGeometry.call( this, shapes, parameters );
	
			this.type = 'TextBufferGeometry';
	
		}
	
		TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
		TextBufferGeometry.prototype.constructor = TextBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// SphereGeometry
	
		function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'SphereGeometry';
	
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
			this.mergeVertices();
	
		}
	
		SphereGeometry.prototype = Object.create( Geometry.prototype );
		SphereGeometry.prototype.constructor = SphereGeometry;
	
		// SphereBufferGeometry
	
		function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'SphereBufferGeometry';
	
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			radius = radius || 50;
	
			widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
			phiStart = phiStart !== undefined ? phiStart : 0;
			phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
			var thetaEnd = thetaStart + thetaLength;
	
			var ix, iy;
	
			var index = 0;
			var grid = [];
	
			var vertex = new Vector3();
			var normal = new Vector3();
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// generate vertices, normals and uvs
	
			for ( iy = 0; iy <= heightSegments; iy ++ ) {
	
				var verticesRow = [];
	
				var v = iy / heightSegments;
	
				for ( ix = 0; ix <= widthSegments; ix ++ ) {
	
					var u = ix / widthSegments;
	
					// vertex
	
					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normal.set( vertex.x, vertex.y, vertex.z ).normalize();
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( u, 1 - v );
	
					verticesRow.push( index ++ );
	
				}
	
				grid.push( verticesRow );
	
			}
	
			// indices
	
			for ( iy = 0; iy < heightSegments; iy ++ ) {
	
				for ( ix = 0; ix < widthSegments; ix ++ ) {
	
					var a = grid[ iy ][ ix + 1 ];
					var b = grid[ iy ][ ix ];
					var c = grid[ iy + 1 ][ ix ];
					var d = grid[ iy + 1 ][ ix + 1 ];
	
					if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
	
		/**
		 * @author Kaleb Murphy
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// RingGeometry
	
		function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'RingGeometry';
	
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
			this.mergeVertices();
	
		}
	
		RingGeometry.prototype = Object.create( Geometry.prototype );
		RingGeometry.prototype.constructor = RingGeometry;
	
		// RingBufferGeometry
	
		function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'RingBufferGeometry';
	
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			innerRadius = innerRadius || 20;
			outerRadius = outerRadius || 50;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
			thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
			phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// some helper variables
	
			var segment;
			var radius = innerRadius;
			var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			var vertex = new Vector3();
			var uv = new Vector2();
			var j, i;
	
			// generate vertices, normals and uvs
	
			for ( j = 0; j <= phiSegments; j ++ ) {
	
				for ( i = 0; i <= thetaSegments; i ++ ) {
	
					// values are generate from the inside of the ring to the outside
	
					segment = thetaStart + i / thetaSegments * thetaLength;
	
					// vertex
	
					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normals.push( 0, 0, 1 );
	
					// uv
	
					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;
	
					uvs.push( uv.x, uv.y );
	
				}
	
				// increase the radius for next row of vertices
	
				radius += radiusStep;
	
			}
	
			// indices
	
			for ( j = 0; j < phiSegments; j ++ ) {
	
				var thetaSegmentLevel = j * ( thetaSegments + 1 );
	
				for ( i = 0; i < thetaSegments; i ++ ) {
	
					segment = i + thetaSegmentLevel;
	
					var a = segment;
					var b = segment + thetaSegments + 1;
					var c = segment + thetaSegments + 2;
					var d = segment + 1;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		RingBufferGeometry.prototype.constructor = RingBufferGeometry;
	
		/**
		 * @author astrodud / http://astrodud.isgreat.org/
		 * @author zz85 / https://github.com/zz85
		 * @author bhouston / http://clara.io
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// LatheGeometry
	
		function LatheGeometry( points, segments, phiStart, phiLength ) {
	
			Geometry.call( this );
	
			this.type = 'LatheGeometry';
	
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
	
			this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
			this.mergeVertices();
	
		}
	
		LatheGeometry.prototype = Object.create( Geometry.prototype );
		LatheGeometry.prototype.constructor = LatheGeometry;
	
		// LatheBufferGeometry
	
		function LatheBufferGeometry( points, segments, phiStart, phiLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'LatheBufferGeometry';
	
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
	
			segments = Math.floor( segments ) || 12;
			phiStart = phiStart || 0;
			phiLength = phiLength || Math.PI * 2;
	
			// clamp phiLength so it's in range of [ 0, 2PI ]
	
			phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );
	
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var uvs = [];
	
			// helper variables
	
			var base;
			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2();
			var i, j;
	
			// generate vertices and uvs
	
			for ( i = 0; i <= segments; i ++ ) {
	
				var phi = phiStart + i * inverseSegments * phiLength;
	
				var sin = Math.sin( phi );
				var cos = Math.cos( phi );
	
				for ( j = 0; j <= ( points.length - 1 ); j ++ ) {
	
					// vertex
	
					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// uv
	
					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );
	
					uvs.push( uv.x, uv.y );
	
	
				}
	
			}
	
			// indices
	
			for ( i = 0; i < segments; i ++ ) {
	
				for ( j = 0; j < ( points.length - 1 ); j ++ ) {
	
					base = j + i * points.length;
	
					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// generate normals
	
			this.computeVertexNormals();
	
			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).
	
			if ( phiLength === Math.PI * 2 ) {
	
				var normals = this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3();
	
				// this is the buffer offset for the last line of vertices
	
				base = segments * points.length * 3;
	
				for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {
	
					// select the normal of the vertex in the first line
	
					n1.x = normals[ j + 0 ];
					n1.y = normals[ j + 1 ];
					n1.z = normals[ j + 2 ];
	
					// select the normal of the vertex in the last line
	
					n2.x = normals[ base + j + 0 ];
					n2.y = normals[ base + j + 1 ];
					n2.z = normals[ base + j + 2 ];
	
					// average normals
	
					n.addVectors( n1, n2 ).normalize();
	
					// assign the new values to both normals
	
					normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
					normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
					normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;
	
				}
	
			}
	
		}
	
		LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
	
		/**
		 * @author jonobr1 / http://jonobr1.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// ShapeGeometry
	
		function ShapeGeometry( shapes, curveSegments ) {
	
			Geometry.call( this );
	
			this.type = 'ShapeGeometry';
	
			if ( typeof curveSegments === 'object' ) {
	
				console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );
	
				curveSegments = curveSegments.curveSegments;
	
			}
	
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};
	
			this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
			this.mergeVertices();
	
		}
	
		ShapeGeometry.prototype = Object.create( Geometry.prototype );
		ShapeGeometry.prototype.constructor = ShapeGeometry;
	
		// ShapeBufferGeometry
	
		function ShapeBufferGeometry( shapes, curveSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'ShapeBufferGeometry';
	
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};
	
			curveSegments = curveSegments || 12;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var groupStart = 0;
			var groupCount = 0;
	
			// allow single and array values for "shapes" parameter
	
			if ( Array.isArray( shapes ) === false ) {
	
				addShape( shapes );
	
			} else {
	
				for ( var i = 0; i < shapes.length; i ++ ) {
	
					addShape( shapes[ i ] );
	
					this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support
	
					groupStart += groupCount;
					groupCount = 0;
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	
			// helper functions
	
			function addShape( shape ) {
	
				var i, l, shapeHole;
	
				var indexOffset = vertices.length / 3;
				var points = shape.extractPoints( curveSegments );
	
				var shapeVertices = points.shape;
				var shapeHoles = points.holes;
	
				// check direction of vertices
	
				if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {
	
					shapeVertices = shapeVertices.reverse();
	
					// also check if holes are in the opposite direction
	
					for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
	
						shapeHole = shapeHoles[ i ];
	
						if ( ShapeUtils.isClockWise( shapeHole ) === true ) {
	
							shapeHoles[ i ] = shapeHole.reverse();
	
						}
	
					}
	
				}
	
				var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );
	
				// join vertices of inner and outer paths to a single array
	
				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
	
					shapeHole = shapeHoles[ i ];
					shapeVertices = shapeVertices.concat( shapeHole );
	
				}
	
				// vertices, normals, uvs
	
				for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {
	
					var vertex = shapeVertices[ i ];
	
					vertices.push( vertex.x, vertex.y, 0 );
					normals.push( 0, 0, 1 );
					uvs.push( vertex.x, vertex.y ); // world uvs
	
				}
	
				// incides
	
				for ( i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					var a = face[ 0 ] + indexOffset;
					var b = face[ 1 ] + indexOffset;
					var c = face[ 2 ] + indexOffset;
	
					indices.push( a, b, c );
					groupCount += 3;
	
				}
	
			}
	
		}
	
		ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function EdgesGeometry( geometry, thresholdAngle ) {
	
			BufferGeometry.call( this );
	
			this.type = 'EdgesGeometry';
	
			this.parameters = {
				thresholdAngle: thresholdAngle
			};
	
			thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
			// buffer
	
			var vertices = [];
	
			// helper variables
	
			var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
			var edge = [ 0, 0 ], edges = {}, edge1, edge2;
			var key, keys = [ 'a', 'b', 'c' ];
	
			// prepare source geometry
	
			var geometry2;
	
			if ( geometry.isBufferGeometry ) {
	
				geometry2 = new Geometry();
				geometry2.fromBufferGeometry( geometry );
	
			} else {
	
				geometry2 = geometry.clone();
	
			}
	
			geometry2.mergeVertices();
			geometry2.computeFaceNormals();
	
			var sourceVertices = geometry2.vertices;
			var faces = geometry2.faces;
	
			// now create a data structure where each entry represents an edge with its adjoining faces
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 );
					edge[ 1 ] = Math.max( edge1, edge2 );
	
					key = edge[ 0 ] + ',' + edge[ 1 ];
	
					if ( edges[ key ] === undefined ) {
	
						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };
	
					} else {
	
						edges[ key ].face2 = i;
	
					}
	
				}
	
			}
	
			// generate vertices
	
			for ( key in edges ) {
	
				var e = edges[ key ];
	
				// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
	
				if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {
	
					var vertex = sourceVertices[ e.index1 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					vertex = sourceVertices[ e.index2 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			}
	
			// build geometry
	
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	
		}
	
		EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
		EdgesGeometry.prototype.constructor = EdgesGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		// CylinderGeometry
	
		function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'CylinderGeometry';
	
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
			this.mergeVertices();
	
		}
	
		CylinderGeometry.prototype = Object.create( Geometry.prototype );
		CylinderGeometry.prototype.constructor = CylinderGeometry;
	
		// CylinderBufferGeometry
	
		function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'CylinderBufferGeometry';
	
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			var scope = this;
	
			radiusTop = radiusTop !== undefined ? radiusTop : 20;
			radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
			height = height !== undefined ? height : 100;
	
			radialSegments = Math.floor( radialSegments ) || 8;
			heightSegments = Math.floor( heightSegments ) || 1;
	
			openEnded = openEnded !== undefined ? openEnded : false;
			thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
			thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var index = 0;
			var indexArray = [];
			var halfHeight = height / 2;
			var groupStart = 0;
	
			// generate geometry
	
			generateTorso();
	
			if ( openEnded === false ) {
	
				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			function generateTorso() {
	
				var x, y;
				var normal = new Vector3();
				var vertex = new Vector3();
	
				var groupCount = 0;
	
				// this will be used to calculate the normal
				var slope = ( radiusBottom - radiusTop ) / height;
	
				// generate vertices, normals and uvs
	
				for ( y = 0; y <= heightSegments; y ++ ) {
	
					var indexRow = [];
	
					var v = y / heightSegments;
	
					// calculate the radius of the current row
	
					var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
					for ( x = 0; x <= radialSegments; x ++ ) {
	
						var u = x / radialSegments;
	
						var theta = u * thetaLength + thetaStart;
	
						var sinTheta = Math.sin( theta );
						var cosTheta = Math.cos( theta );
	
						// vertex
	
						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );
	
						// normal
	
						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );
	
						// uv
	
						uvs.push( u, 1 - v );
	
						// save index of vertex in respective row
	
						indexRow.push( index ++ );
	
					}
	
					// now save vertices of the row in our index array
	
					indexArray.push( indexRow );
	
				}
	
				// generate indices
	
				for ( x = 0; x < radialSegments; x ++ ) {
	
					for ( y = 0; y < heightSegments; y ++ ) {
	
						// we use the index array to access the correct indices
	
						var a = indexArray[ y ][ x ];
						var b = indexArray[ y + 1 ][ x ];
						var c = indexArray[ y + 1 ][ x + 1 ];
						var d = indexArray[ y ][ x + 1 ];
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
						// update group counter
	
						groupCount += 6;
	
					}
	
				}
	
				// add a group to the geometry. this will ensure multi material support
	
				scope.addGroup( groupStart, groupCount, 0 );
	
				// calculate new start value for groups
	
				groupStart += groupCount;
	
			}
	
			function generateCap( top ) {
	
				var x, centerIndexStart, centerIndexEnd;
	
				var uv = new Vector2();
				var vertex = new Vector3();
	
				var groupCount = 0;
	
				var radius = ( top === true ) ? radiusTop : radiusBottom;
				var sign = ( top === true ) ? 1 : - 1;
	
				// save the index of the first center vertex
				centerIndexStart = index;
	
				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment
	
				for ( x = 1; x <= radialSegments; x ++ ) {
	
					// vertex
	
					vertices.push( 0, halfHeight * sign, 0 );
	
					// normal
	
					normals.push( 0, sign, 0 );
	
					// uv
	
					uvs.push( 0.5, 0.5 );
	
					// increase index
	
					index ++;
	
				}
	
				// save the index of the last center vertex
	
				centerIndexEnd = index;
	
				// now we generate the surrounding vertices, normals and uvs
	
				for ( x = 0; x <= radialSegments; x ++ ) {
	
					var u = x / radialSegments;
					var theta = u * thetaLength + thetaStart;
	
					var cosTheta = Math.cos( theta );
					var sinTheta = Math.sin( theta );
	
					// vertex
	
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normals.push( 0, sign, 0 );
	
					// uv
	
					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );
	
					// increase index
	
					index ++;
	
				}
	
				// generate indices
	
				for ( x = 0; x < radialSegments; x ++ ) {
	
					var c = centerIndexStart + x;
					var i = centerIndexEnd + x;
	
					if ( top === true ) {
	
						// face top
	
						indices.push( i, i + 1, c );
	
					} else {
	
						// face bottom
	
						indices.push( i + 1, i, c );
	
					}
	
					groupCount += 3;
	
				}
	
				// add a group to the geometry. this will ensure multi material support
	
				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );
	
				// calculate new start value for groups
	
				groupStart += groupCount;
	
			}
	
		}
	
		CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 */
	
		// ConeGeometry
	
		function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
			this.type = 'ConeGeometry';
	
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
		}
	
		ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
		ConeGeometry.prototype.constructor = ConeGeometry;
	
		// ConeBufferGeometry
	
		function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
			this.type = 'ConeBufferGeometry';
	
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
		}
	
		ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
		ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * @author Mugen87 / https://github.com/Mugen87
		 * @author hughes
		 */
	
		// CircleGeometry
	
		function CircleGeometry( radius, segments, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'CircleGeometry';
	
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
			this.mergeVertices();
	
		}
	
		CircleGeometry.prototype = Object.create( Geometry.prototype );
		CircleGeometry.prototype.constructor = CircleGeometry;
	
		// CircleBufferGeometry
	
		function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'CircleBufferGeometry';
	
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			radius = radius || 50;
			segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var i, s;
			var vertex = new Vector3();
			var uv = new Vector2();
	
			// center point
	
			vertices.push( 0, 0, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( 0.5, 0.5 );
	
			for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {
	
				var segment = thetaStart + s / segments * thetaLength;
	
				// vertex
	
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
	
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				// normal
	
				normals.push( 0, 0, 1 );
	
				// uvs
	
				uv.x = ( vertices[ i ] / radius + 1 ) / 2;
				uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;
	
				uvs.push( uv.x, uv.y );
	
			}
	
			// indices
	
			for ( i = 1; i <= segments; i ++ ) {
	
				indices.push( i, i + 1, 0 );
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
	
	
	
		var Geometries = Object.freeze({
			WireframeGeometry: WireframeGeometry,
			ParametricGeometry: ParametricGeometry,
			ParametricBufferGeometry: ParametricBufferGeometry,
			TetrahedronGeometry: TetrahedronGeometry,
			TetrahedronBufferGeometry: TetrahedronBufferGeometry,
			OctahedronGeometry: OctahedronGeometry,
			OctahedronBufferGeometry: OctahedronBufferGeometry,
			IcosahedronGeometry: IcosahedronGeometry,
			IcosahedronBufferGeometry: IcosahedronBufferGeometry,
			DodecahedronGeometry: DodecahedronGeometry,
			DodecahedronBufferGeometry: DodecahedronBufferGeometry,
			PolyhedronGeometry: PolyhedronGeometry,
			PolyhedronBufferGeometry: PolyhedronBufferGeometry,
			TubeGeometry: TubeGeometry,
			TubeBufferGeometry: TubeBufferGeometry,
			TorusKnotGeometry: TorusKnotGeometry,
			TorusKnotBufferGeometry: TorusKnotBufferGeometry,
			TorusGeometry: TorusGeometry,
			TorusBufferGeometry: TorusBufferGeometry,
			TextGeometry: TextGeometry,
			TextBufferGeometry: TextBufferGeometry,
			SphereGeometry: SphereGeometry,
			SphereBufferGeometry: SphereBufferGeometry,
			RingGeometry: RingGeometry,
			RingBufferGeometry: RingBufferGeometry,
			PlaneGeometry: PlaneGeometry,
			PlaneBufferGeometry: PlaneBufferGeometry,
			LatheGeometry: LatheGeometry,
			LatheBufferGeometry: LatheBufferGeometry,
			ShapeGeometry: ShapeGeometry,
			ShapeBufferGeometry: ShapeBufferGeometry,
			ExtrudeGeometry: ExtrudeGeometry,
			ExtrudeBufferGeometry: ExtrudeBufferGeometry,
			EdgesGeometry: EdgesGeometry,
			ConeGeometry: ConeGeometry,
			ConeBufferGeometry: ConeBufferGeometry,
			CylinderGeometry: CylinderGeometry,
			CylinderBufferGeometry: CylinderBufferGeometry,
			CircleGeometry: CircleGeometry,
			CircleBufferGeometry: CircleBufferGeometry,
			BoxGeometry: BoxGeometry,
			BoxBufferGeometry: BoxBufferGeometry
		});
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * parameters = {
		 *  opacity: <float>
		 * }
		 */
	
		function ShadowMaterial( parameters ) {
	
			ShaderMaterial.call( this, {
				uniforms: UniformsUtils.merge( [
					UniformsLib.lights,
					{
						opacity: { value: 1.0 }
					}
				] ),
				vertexShader: ShaderChunk[ 'shadow_vert' ],
				fragmentShader: ShaderChunk[ 'shadow_frag' ]
			} );
	
			this.lights = true;
			this.transparent = true;
	
			Object.defineProperties( this, {
				opacity: {
					enumerable: true,
					get: function () {
						return this.uniforms.opacity.value;
					},
					set: function ( value ) {
						this.uniforms.opacity.value = value;
					}
				}
			} );
	
			this.setValues( parameters );
	
		}
	
		ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
		ShadowMaterial.prototype.constructor = ShadowMaterial;
	
		ShadowMaterial.prototype.isShadowMaterial = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function RawShaderMaterial( parameters ) {
	
			ShaderMaterial.call( this, parameters );
	
			this.type = 'RawShaderMaterial';
	
		}
	
		RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
		RawShaderMaterial.prototype.constructor = RawShaderMaterial;
	
		RawShaderMaterial.prototype.isRawShaderMaterial = true;
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  roughness: <float>,
		 *  metalness: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  roughnessMap: new THREE.Texture( <Image> ),
		 *
		 *  metalnessMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  envMapIntensity: <float>
		 *
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshStandardMaterial( parameters ) {
	
			Material.call( this );
	
			this.defines = { 'STANDARD': '' };
	
			this.type = 'MeshStandardMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 0.5;
			this.metalness = 0.5;
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.roughnessMap = null;
	
			this.metalnessMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.envMapIntensity = 1.0;
	
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshStandardMaterial.prototype = Object.create( Material.prototype );
		MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
	
		MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
	
		MeshStandardMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.defines = { 'STANDARD': '' };
	
			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.roughnessMap = source.roughnessMap;
	
			this.metalnessMap = source.metalnessMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
	
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  reflectivity: <float>
		 * }
		 */
	
		function MeshPhysicalMaterial( parameters ) {
	
			MeshStandardMaterial.call( this );
	
			this.defines = { 'PHYSICAL': '' };
	
			this.type = 'MeshPhysicalMaterial';
	
			this.reflectivity = 0.5; // maps to F0 = 0.04
	
			this.clearCoat = 0.0;
			this.clearCoatRoughness = 0.0;
	
			this.setValues( parameters );
	
		}
	
		MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
		MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
	
		MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
	
		MeshPhysicalMaterial.prototype.copy = function ( source ) {
	
			MeshStandardMaterial.prototype.copy.call( this, source );
	
			this.defines = { 'PHYSICAL': '' };
	
			this.reflectivity = source.reflectivity;
	
			this.clearCoat = source.clearCoat;
			this.clearCoatRoughness = source.clearCoatRoughness;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshPhongMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshPhongMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshPhongMaterial.prototype = Object.create( Material.prototype );
		MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
	
		MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
	
		MeshPhongMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author takahirox / http://github.com/takahirox
		 *
		 * parameters = {
		 *  gradientMap: new THREE.Texture( <Image> )
		 * }
		 */
	
		function MeshToonMaterial( parameters ) {
	
			MeshPhongMaterial.call( this );
	
			this.defines = { 'TOON': '' };
	
			this.type = 'MeshToonMaterial';
	
			this.gradientMap = null;
	
			this.setValues( parameters );
	
		}
	
		MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
		MeshToonMaterial.prototype.constructor = MeshToonMaterial;
	
		MeshToonMaterial.prototype.isMeshToonMaterial = true;
	
		MeshToonMaterial.prototype.copy = function ( source ) {
	
			MeshPhongMaterial.prototype.copy.call( this, source );
	
			this.gradientMap = source.gradientMap;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  opacity: <float>,
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshNormalMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshNormalMaterial';
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false;
			this.lights = false;
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshNormalMaterial.prototype = Object.create( Material.prototype );
		MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
	
		MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
	
		MeshNormalMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshLambertMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshLambertMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshLambertMaterial.prototype = Object.create( Material.prototype );
		MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
	
		MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
	
		MeshLambertMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *
		 *  scale: <float>,
		 *  dashSize: <float>,
		 *  gapSize: <float>
		 * }
		 */
	
		function LineDashedMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'LineDashedMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.linewidth = 1;
	
			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		LineDashedMaterial.prototype = Object.create( Material.prototype );
		LineDashedMaterial.prototype.constructor = LineDashedMaterial;
	
		LineDashedMaterial.prototype.isLineDashedMaterial = true;
	
		LineDashedMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.linewidth = source.linewidth;
	
			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
	
			return this;
	
		};
	
	
	
		var Materials = Object.freeze({
			ShadowMaterial: ShadowMaterial,
			SpriteMaterial: SpriteMaterial,
			RawShaderMaterial: RawShaderMaterial,
			ShaderMaterial: ShaderMaterial,
			PointsMaterial: PointsMaterial,
			MeshPhysicalMaterial: MeshPhysicalMaterial,
			MeshStandardMaterial: MeshStandardMaterial,
			MeshPhongMaterial: MeshPhongMaterial,
			MeshToonMaterial: MeshToonMaterial,
			MeshNormalMaterial: MeshNormalMaterial,
			MeshLambertMaterial: MeshLambertMaterial,
			MeshDepthMaterial: MeshDepthMaterial,
			MeshBasicMaterial: MeshBasicMaterial,
			LineDashedMaterial: LineDashedMaterial,
			LineBasicMaterial: LineBasicMaterial,
			Material: Material
		});
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var Cache = {
	
			enabled: false,
	
			files: {},
	
			add: function ( key, file ) {
	
				if ( this.enabled === false ) return;
	
				// console.log( 'THREE.Cache', 'Adding key:', key );
	
				this.files[ key ] = file;
	
			},
	
			get: function ( key ) {
	
				if ( this.enabled === false ) return;
	
				// console.log( 'THREE.Cache', 'Checking key:', key );
	
				return this.files[ key ];
	
			},
	
			remove: function ( key ) {
	
				delete this.files[ key ];
	
			},
	
			clear: function () {
	
				this.files = {};
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LoadingManager( onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
	
			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;
	
			this.itemStart = function ( url ) {
	
				itemsTotal ++;
	
				if ( isLoading === false ) {
	
					if ( scope.onStart !== undefined ) {
	
						scope.onStart( url, itemsLoaded, itemsTotal );
	
					}
	
				}
	
				isLoading = true;
	
			};
	
			this.itemEnd = function ( url ) {
	
				itemsLoaded ++;
	
				if ( scope.onProgress !== undefined ) {
	
					scope.onProgress( url, itemsLoaded, itemsTotal );
	
				}
	
				if ( itemsLoaded === itemsTotal ) {
	
					isLoading = false;
	
					if ( scope.onLoad !== undefined ) {
	
						scope.onLoad();
	
					}
	
				}
	
			};
	
			this.itemError = function ( url ) {
	
				if ( scope.onError !== undefined ) {
	
					scope.onError( url );
	
				}
	
			};
	
		}
	
		var DefaultLoadingManager = new LoadingManager();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function FileLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( FileLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( url === undefined ) url = '';
	
				if ( this.path !== undefined ) url = this.path + url;
	
				var scope = this;
	
				var cached = Cache.get( url );
	
				if ( cached !== undefined ) {
	
					scope.manager.itemStart( url );
	
					setTimeout( function () {
	
						if ( onLoad ) onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
					return cached;
	
				}
	
				// Check for data: URI
				var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
				var dataUriRegexResult = url.match( dataUriRegex );
	
				// Safari can not handle Data URIs through XMLHttpRequest so process manually
				if ( dataUriRegexResult ) {
	
					var mimeType = dataUriRegexResult[ 1 ];
					var isBase64 = !! dataUriRegexResult[ 2 ];
					var data = dataUriRegexResult[ 3 ];
	
					data = window.decodeURIComponent( data );
	
					if ( isBase64 ) data = window.atob( data );
	
					try {
	
						var response;
						var responseType = ( this.responseType || '' ).toLowerCase();
	
						switch ( responseType ) {
	
							case 'arraybuffer':
							case 'blob':
	
							 	response = new ArrayBuffer( data.length );
	
								var view = new Uint8Array( response );
	
								for ( var i = 0; i < data.length; i ++ ) {
	
									view[ i ] = data.charCodeAt( i );
	
								}
	
								if ( responseType === 'blob' ) {
	
									response = new Blob( [ response ], { type: mimeType } );
	
								}
	
								break;
	
							case 'document':
	
								var parser = new DOMParser();
								response = parser.parseFromString( data, mimeType );
	
								break;
	
							case 'json':
	
								response = JSON.parse( data );
	
								break;
	
							default: // 'text' or other
	
								response = data;
	
								break;
	
						}
	
						// Wait for next browser tick
						window.setTimeout( function () {
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						}, 0 );
	
					} catch ( error ) {
	
						// Wait for next browser tick
						window.setTimeout( function () {
	
							if ( onError ) onError( error );
	
							scope.manager.itemEnd( url );
							scope.manager.itemError( url );
	
						}, 0 );
	
					}
	
				} else {
	
					var request = new XMLHttpRequest();
					request.open( 'GET', url, true );
	
					request.addEventListener( 'load', function ( event ) {
	
						var response = event.target.response;
	
						Cache.add( url, response );
	
						if ( this.status === 200 ) {
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						} else if ( this.status === 0 ) {
	
							// Some browsers return HTTP Status 0 when using non-http protocol
							// e.g. 'file://' or 'data://'. Handle as success.
	
							console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						} else {
	
							if ( onError ) onError( event );
	
							scope.manager.itemEnd( url );
							scope.manager.itemError( url );
	
						}
	
					}, false );
	
					if ( onProgress !== undefined ) {
	
						request.addEventListener( 'progress', function ( event ) {
	
							onProgress( event );
	
						}, false );
	
					}
	
					request.addEventListener( 'error', function ( event ) {
	
						if ( onError ) onError( event );
	
						scope.manager.itemEnd( url );
						scope.manager.itemError( url );
	
					}, false );
	
					if ( this.responseType !== undefined ) request.responseType = this.responseType;
					if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
	
					if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );
	
					for ( var header in this.requestHeader ) {
	
						request.setRequestHeader( header, this.requestHeader[ header ] );
	
					}
	
					request.send( null );
	
				}
	
				scope.manager.itemStart( url );
	
				return request;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			},
	
			setResponseType: function ( value ) {
	
				this.responseType = value;
				return this;
	
			},
	
			setWithCredentials: function ( value ) {
	
				this.withCredentials = value;
				return this;
	
			},
	
			setMimeType: function ( value ) {
	
				this.mimeType = value;
				return this;
	
			},
	
			setRequestHeader: function ( value ) {
	
				this.requestHeader = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * Abstract Base class to block based textures loader (dds, pvr, ...)
		 */
	
		function CompressedTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			// override in sub classes
			this._parser = null;
	
		}
	
		Object.assign( CompressedTextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var images = [];
	
				var texture = new CompressedTexture();
				texture.image = images;
	
				var loader = new FileLoader( this.manager );
				loader.setPath( this.path );
				loader.setResponseType( 'arraybuffer' );
	
				function loadTexture( i ) {
	
					loader.load( url[ i ], function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};
	
						loaded += 1;
	
						if ( loaded === 6 ) {
	
							if ( texDatas.mipmapCount === 1 )
								texture.minFilter = LinearFilter;
	
							texture.format = texDatas.format;
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					}, onProgress, onError );
	
				}
	
				if ( Array.isArray( url ) ) {
	
					var loaded = 0;
	
					for ( var i = 0, il = url.length; i < il; ++ i ) {
	
						loadTexture( i );
	
					}
	
				} else {
	
					// compressed cubemap texture stored in a single DDS file
	
					loader.load( url, function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						if ( texDatas.isCubemap ) {
	
							var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
							for ( var f = 0; f < faces; f ++ ) {
	
								images[ f ] = { mipmaps : [] };
	
								for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
									images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
									images[ f ].format = texDatas.format;
									images[ f ].width = texDatas.width;
									images[ f ].height = texDatas.height;
	
								}
	
							}
	
						} else {
	
							texture.image.width = texDatas.width;
							texture.image.height = texDatas.height;
							texture.mipmaps = texDatas.mipmaps;
	
						}
	
						if ( texDatas.mipmapCount === 1 ) {
	
							texture.minFilter = LinearFilter;
	
						}
	
						texture.format = texDatas.format;
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}, onProgress, onError );
	
				}
	
				return texture;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author Nikos M. / https://github.com/foo123/
		 *
		 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
		 */
	
		function DataTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			// override in sub classes
			this._parser = null;
	
		}
	
		Object.assign( DataTextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var texture = new DataTexture();
	
				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
	
				loader.load( url, function ( buffer ) {
	
					var texData = scope._parser( buffer );
	
					if ( ! texData ) return;
	
					if ( undefined !== texData.image ) {
	
						texture.image = texData.image;
	
					} else if ( undefined !== texData.data ) {
	
						texture.image.width = texData.width;
						texture.image.height = texData.height;
						texture.image.data = texData.data;
	
					}
	
					texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
					texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
	
					texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
					texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
	
					texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	
					if ( undefined !== texData.format ) {
	
						texture.format = texData.format;
	
					}
					if ( undefined !== texData.type ) {
	
						texture.type = texData.type;
	
					}
	
					if ( undefined !== texData.mipmaps ) {
	
						texture.mipmaps = texData.mipmaps;
	
					}
	
					if ( 1 === texData.mipmapCount ) {
	
						texture.minFilter = LinearFilter;
	
					}
	
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture, texData );
	
				}, onProgress, onError );
	
	
				return texture;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ImageLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( ImageLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( url === undefined ) url = '';
	
				if ( this.path !== undefined ) url = this.path + url;
	
				var scope = this;
	
				var cached = Cache.get( url );
	
				if ( cached !== undefined ) {
	
					scope.manager.itemStart( url );
	
					setTimeout( function () {
	
						if ( onLoad ) onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
					return cached;
	
				}
	
				var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
	
				image.addEventListener( 'load', function () {
	
					Cache.add( url, this );
	
					if ( onLoad ) onLoad( this );
	
					scope.manager.itemEnd( url );
	
				}, false );
	
				/*
				image.addEventListener( 'progress', function ( event ) {
	
					if ( onProgress ) onProgress( event );
	
				}, false );
				*/
	
				image.addEventListener( 'error', function ( event ) {
	
					if ( onError ) onError( event );
	
					scope.manager.itemEnd( url );
					scope.manager.itemError( url );
	
				}, false );
	
				if ( url.substr( 0, 5 ) !== 'data:' ) {
	
					if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
	
				}
	
				scope.manager.itemStart( url );
	
				image.src = url;
	
				return image;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CubeTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( CubeTextureLoader.prototype, {
	
			load: function ( urls, onLoad, onProgress, onError ) {
	
				var texture = new CubeTexture();
	
				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );
	
				var loaded = 0;
	
				function loadTexture( i ) {
	
					loader.load( urls[ i ], function ( image ) {
	
						texture.images[ i ] = image;
	
						loaded ++;
	
						if ( loaded === 6 ) {
	
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					}, undefined, onError );
	
				}
	
				for ( var i = 0; i < urls.length; ++ i ) {
	
					loadTexture( i );
	
				}
	
				return texture;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function TextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( TextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );
	
				var texture = new Texture();
				texture.image = loader.load( url, function () {
	
					// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
					var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
	
					texture.format = isJPEG ? RGBFormat : RGBAFormat;
					texture.needsUpdate = true;
	
					if ( onLoad !== undefined ) {
	
						onLoad( texture );
	
					}
	
				}, onProgress, onError );
	
				return texture;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Light( color, intensity ) {
	
			Object3D.call( this );
	
			this.type = 'Light';
	
			this.color = new Color( color );
			this.intensity = intensity !== undefined ? intensity : 1;
	
			this.receiveShadow = undefined;
	
		}
	
		Light.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Light,
	
			isLight: true,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.color.copy( source.color );
				this.intensity = source.intensity;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.color = this.color.getHex();
				data.object.intensity = this.intensity;
	
				if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
	
				if ( this.distance !== undefined ) data.object.distance = this.distance;
				if ( this.angle !== undefined ) data.object.angle = this.angle;
				if ( this.decay !== undefined ) data.object.decay = this.decay;
				if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
	
				if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function HemisphereLight( skyColor, groundColor, intensity ) {
	
			Light.call( this, skyColor, intensity );
	
			this.type = 'HemisphereLight';
	
			this.castShadow = undefined;
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.groundColor = new Color( groundColor );
	
		}
	
		HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: HemisphereLight,
	
			isHemisphereLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.groundColor.copy( source.groundColor );
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LightShadow( camera ) {
	
			this.camera = camera;
	
			this.bias = 0;
			this.radius = 1;
	
			this.mapSize = new Vector2( 512, 512 );
	
			this.map = null;
			this.matrix = new Matrix4();
	
		}
	
		Object.assign( LightShadow.prototype, {
	
			copy: function ( source ) {
	
				this.camera = source.camera.clone();
	
				this.bias = source.bias;
				this.radius = source.radius;
	
				this.mapSize.copy( source.mapSize );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			toJSON: function () {
	
				var object = {};
	
				if ( this.bias !== 0 ) object.bias = this.bias;
				if ( this.radius !== 1 ) object.radius = this.radius;
				if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();
	
				object.camera = this.camera.toJSON( false ).object;
				delete object.camera.matrix;
	
				return object;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function SpotLightShadow() {
	
			LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );
	
		}
	
		SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
			constructor: SpotLightShadow,
	
			isSpotLightShadow: true,
	
			update: function ( light ) {
	
				var camera = this.camera;
	
				var fov = _Math.RAD2DEG * 2 * light.angle;
				var aspect = this.mapSize.width / this.mapSize.height;
				var far = light.distance || camera.far;
	
				if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {
	
					camera.fov = fov;
					camera.aspect = aspect;
					camera.far = far;
					camera.updateProjectionMatrix();
	
				}
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function SpotLight( color, intensity, distance, angle, penumbra, decay ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'SpotLight';
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.target = new Object3D();
	
			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * Math.PI;
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / Math.PI;
				}
			} );
	
			this.distance = ( distance !== undefined ) ? distance : 0;
			this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
			this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
			this.shadow = new SpotLightShadow();
	
		}
	
		SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: SpotLight,
	
			isSpotLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.distance = source.distance;
				this.angle = source.angle;
				this.penumbra = source.penumbra;
				this.decay = source.decay;
	
				this.target = source.target.clone();
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
	
		function PointLight( color, intensity, distance, decay ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'PointLight';
	
			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * 4 * Math.PI;
	
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / ( 4 * Math.PI );
				}
			} );
	
			this.distance = ( distance !== undefined ) ? distance : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
			this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
		}
	
		PointLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: PointLight,
	
			isPointLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.distance = source.distance;
				this.decay = source.decay;
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function DirectionalLightShadow( ) {
	
			LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
	
		}
	
		DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
			constructor: DirectionalLightShadow
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function DirectionalLight( color, intensity ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'DirectionalLight';
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.target = new Object3D();
	
			this.shadow = new DirectionalLightShadow();
	
		}
	
		DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: DirectionalLight,
	
			isDirectionalLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.target = source.target.clone();
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AmbientLight( color, intensity ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'AmbientLight';
	
			this.castShadow = undefined;
	
		}
	
		AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: AmbientLight,
	
			isAmbientLight: true
	
		} );
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 */
	
		function RectAreaLight( color, intensity, width, height ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'RectAreaLight';
	
			this.position.set( 0, 1, 0 );
			this.updateMatrix();
	
			this.width = ( width !== undefined ) ? width : 10;
			this.height = ( height !== undefined ) ? height : 10;
	
			// TODO (abelnation): distance/decay
	
			// TODO (abelnation): update method for RectAreaLight to update transform to lookat target
	
			// TODO (abelnation): shadows
	
		}
	
		// TODO (abelnation): RectAreaLight update when light shape is changed
		RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: RectAreaLight,
	
			isRectAreaLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.width = source.width;
				this.height = source.height;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Light.prototype.toJSON.call( this, meta );
	
				data.object.width = this.width;
				data.object.height = this.height;
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author tschw
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */
	
		var AnimationUtils = {
	
			// same as Array.prototype.slice, but also works on typed arrays
			arraySlice: function ( array, from, to ) {
	
				if ( AnimationUtils.isTypedArray( array ) ) {
	
					// in ios9 array.subarray(from, undefined) will return empty array
					// but array.subarray(from) or array.subarray(from, len) is correct
					return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );
	
				}
	
				return array.slice( from, to );
	
			},
	
			// converts an array to a specific type
			convertArray: function ( array, type, forceClone ) {
	
				if ( ! array || // let 'undefined' and 'null' pass
						! forceClone && array.constructor === type ) return array;
	
				if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
	
					return new type( array ); // create typed array
	
				}
	
				return Array.prototype.slice.call( array ); // create Array
	
			},
	
			isTypedArray: function ( object ) {
	
				return ArrayBuffer.isView( object ) &&
						! ( object instanceof DataView );
	
			},
	
			// returns an array by which times and values can be sorted
			getKeyframeOrder: function ( times ) {
	
				function compareTime( i, j ) {
	
					return times[ i ] - times[ j ];
	
				}
	
				var n = times.length;
				var result = new Array( n );
				for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
	
				result.sort( compareTime );
	
				return result;
	
			},
	
			// uses the array previously returned by 'getKeyframeOrder' to sort data
			sortedArray: function ( values, stride, order ) {
	
				var nValues = values.length;
				var result = new values.constructor( nValues );
	
				for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
	
					var srcOffset = order[ i ] * stride;
	
					for ( var j = 0; j !== stride; ++ j ) {
	
						result[ dstOffset ++ ] = values[ srcOffset + j ];
	
					}
	
				}
	
				return result;
	
			},
	
			// function for parsing AOS keyframe formats
			flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {
	
				var i = 1, key = jsonKeys[ 0 ];
	
				while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
	
					key = jsonKeys[ i ++ ];
	
				}
	
				if ( key === undefined ) return; // no data
	
				var value = key[ valuePropertyName ];
				if ( value === undefined ) return; // no data
	
				if ( Array.isArray( value ) ) {
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							values.push.apply( values, value ); // push all elements
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				} else if ( value.toArray !== undefined ) {
	
					// ...assume THREE.Math-ish
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							value.toArray( values, values.length );
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				} else {
	
					// otherwise push as-is
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							values.push( value );
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				}
	
			}
	
		};
	
		/**
		 * Abstract base class of interpolants over parametric samples.
		 *
		 * The parameter domain is one dimensional, typically the time or a path
		 * along a curve defined by the data.
		 *
		 * The sample values can have any dimensionality and derived classes may
		 * apply special interpretations to the data.
		 *
		 * This class provides the interval seek in a Template Method, deferring
		 * the actual interpolation to derived classes.
		 *
		 * Time complexity is O(1) for linear access crossing at most two points
		 * and O(log N) for random access, where N is the number of positions.
		 *
		 * References:
		 *
		 * 		http://www.oodesign.com/template-method-pattern.html
		 *
		 * @author tschw
		 */
	
		function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
	
			this.resultBuffer = resultBuffer !== undefined ?
					resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
	
		}
	
		Object.assign( Interpolant.prototype, {
	
			evaluate: function( t ) {
	
				var pp = this.parameterPositions,
					i1 = this._cachedIndex,
	
					t1 = pp[   i1   ],
					t0 = pp[ i1 - 1 ];
	
				validate_interval: {
	
					seek: {
	
						var right;
	
						linear_scan: {
							//- See http://jsperf.com/comparison-to-undefined/3
							//- slower code:
							//-
							//- 				if ( t >= t1 || t1 === undefined ) {
							forward_scan: if ( ! ( t < t1 ) ) {
	
								for ( var giveUpAt = i1 + 2; ;) {
	
									if ( t1 === undefined ) {
	
										if ( t < t0 ) break forward_scan;
	
										// after end
	
										i1 = pp.length;
										this._cachedIndex = i1;
										return this.afterEnd_( i1 - 1, t, t0 );
	
									}
	
									if ( i1 === giveUpAt ) break; // this loop
	
									t0 = t1;
									t1 = pp[ ++ i1 ];
	
									if ( t < t1 ) {
	
										// we have arrived at the sought interval
										break seek;
	
									}
	
								}
	
								// prepare binary search on the right side of the index
								right = pp.length;
								break linear_scan;
	
							}
	
							//- slower code:
							//-					if ( t < t0 || t0 === undefined ) {
							if ( ! ( t >= t0 ) ) {
	
								// looping?
	
								var t1global = pp[ 1 ];
	
								if ( t < t1global ) {
	
									i1 = 2; // + 1, using the scan for the details
									t0 = t1global;
	
								}
	
								// linear reverse scan
	
								for ( var giveUpAt = i1 - 2; ;) {
	
									if ( t0 === undefined ) {
	
										// before start
	
										this._cachedIndex = 0;
										return this.beforeStart_( 0, t, t1 );
	
									}
	
									if ( i1 === giveUpAt ) break; // this loop
	
									t1 = t0;
									t0 = pp[ -- i1 - 1 ];
	
									if ( t >= t0 ) {
	
										// we have arrived at the sought interval
										break seek;
	
									}
	
								}
	
								// prepare binary search on the left side of the index
								right = i1;
								i1 = 0;
								break linear_scan;
	
							}
	
							// the interval is valid
	
							break validate_interval;
	
						} // linear scan
	
						// binary search
	
						while ( i1 < right ) {
	
							var mid = ( i1 + right ) >>> 1;
	
							if ( t < pp[ mid ] ) {
	
								right = mid;
	
							} else {
	
								i1 = mid + 1;
	
							}
	
						}
	
						t1 = pp[   i1   ];
						t0 = pp[ i1 - 1 ];
	
						// check boundary cases, again
	
						if ( t0 === undefined ) {
	
							this._cachedIndex = 0;
							return this.beforeStart_( 0, t, t1 );
	
						}
	
						if ( t1 === undefined ) {
	
							i1 = pp.length;
							this._cachedIndex = i1;
							return this.afterEnd_( i1 - 1, t0, t );
	
						}
	
					} // seek
	
					this._cachedIndex = i1;
	
					this.intervalChanged_( i1, t0, t1 );
	
				} // validate_interval
	
				return this.interpolate_( i1, t0, t, t1 );
	
			},
	
			settings: null, // optional, subclass-specific settings structure
			// Note: The indirection allows central control of many interpolants.
	
			// --- Protected interface
	
			DefaultSettings_: {},
	
			getSettings_: function() {
	
				return this.settings || this.DefaultSettings_;
	
			},
	
			copySampleValue_: function( index ) {
	
				// copies a sample value to the result buffer
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] = values[ offset + i ];
	
				}
	
				return result;
	
			},
	
			// Template methods for derived classes:
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				throw new Error( "call to abstract method" );
				// implementations shall return this.resultBuffer
	
			},
	
			intervalChanged_: function( i1, t0, t1 ) {
	
				// empty
	
			}
	
		} );
	
		//!\ DECLARE ALIAS AFTER assign prototype !
		Object.assign( Interpolant.prototype, {
	
			//( 0, t, t0 ), returns this.resultBuffer
			beforeStart_: Interpolant.prototype.copySampleValue_,
	
			//( N-1, tN-1, t ), returns this.resultBuffer
			afterEnd_: Interpolant.prototype.copySampleValue_,
	
		} );
	
		/**
		 * Fast and simple cubic spline interpolant.
		 *
		 * It was derived from a Hermitian construction setting the first derivative
		 * at each sample position to the linear slope between neighboring positions
		 * over their parameter interval.
		 *
		 * @author tschw
		 */
	
		function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;
	
		}
	
		CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: CubicInterpolant,
	
			DefaultSettings_: {
	
				endingStart: 	ZeroCurvatureEnding,
				endingEnd:		ZeroCurvatureEnding
	
			},
	
			intervalChanged_: function( i1, t0, t1 ) {
	
				var pp = this.parameterPositions,
					iPrev = i1 - 2,
					iNext = i1 + 1,
	
					tPrev = pp[ iPrev ],
					tNext = pp[ iNext ];
	
				if ( tPrev === undefined ) {
	
					switch ( this.getSettings_().endingStart ) {
	
						case ZeroSlopeEnding:
	
							// f'(t0) = 0
							iPrev = i1;
							tPrev = 2 * t0 - t1;
	
							break;
	
						case WrapAroundEnding:
	
							// use the other end of the curve
							iPrev = pp.length - 2;
							tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
	
							break;
	
						default: // ZeroCurvatureEnding
	
							// f''(t0) = 0 a.k.a. Natural Spline
							iPrev = i1;
							tPrev = t1;
	
					}
	
				}
	
				if ( tNext === undefined ) {
	
					switch ( this.getSettings_().endingEnd ) {
	
						case ZeroSlopeEnding:
	
							// f'(tN) = 0
							iNext = i1;
							tNext = 2 * t1 - t0;
	
							break;
	
						case WrapAroundEnding:
	
							// use the other end of the curve
							iNext = 1;
							tNext = t1 + pp[ 1 ] - pp[ 0 ];
	
							break;
	
						default: // ZeroCurvatureEnding
	
							// f''(tN) = 0, a.k.a. Natural Spline
							iNext = i1 - 1;
							tNext = t0;
	
					}
	
				}
	
				var halfDt = ( t1 - t0 ) * 0.5,
					stride = this.valueSize;
	
				this._weightPrev = halfDt / ( t0 - tPrev );
				this._weightNext = halfDt / ( tNext - t1 );
				this._offsetPrev = iPrev * stride;
				this._offsetNext = iNext * stride;
	
			},
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					o1 = i1 * stride,		o0 = o1 - stride,
					oP = this._offsetPrev, 	oN = this._offsetNext,
					wP = this._weightPrev,	wN = this._weightNext,
	
					p = ( t - t0 ) / ( t1 - t0 ),
					pp = p * p,
					ppp = pp * p;
	
				// evaluate polynomials
	
				var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
				var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
				var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
				var sN =       wN   * ppp   -           wN      * pp;
	
				// combine data linearly
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] =
							sP * values[ oP + i ] +
							s0 * values[ o0 + i ] +
							s1 * values[ o1 + i ] +
							sN * values[ oN + i ];
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 * @author tschw
		 */
	
		function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: LinearInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					offset1 = i1 * stride,
					offset0 = offset1 - stride,
	
					weight1 = ( t - t0 ) / ( t1 - t0 ),
					weight0 = 1 - weight1;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] =
							values[ offset0 + i ] * weight0 +
							values[ offset1 + i ] * weight1;
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 *
		 * Interpolant that evaluates to the sample value at the position preceeding
		 * the parameter.
		 *
		 * @author tschw
		 */
	
		function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: DiscreteInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				return this.copySampleValue_( i1 - 1 );
	
			}
	
		} );
	
		var KeyframeTrackPrototype;
	
		KeyframeTrackPrototype = {
	
			TimeBufferType: Float32Array,
			ValueBufferType: Float32Array,
	
			DefaultInterpolation: InterpolateLinear,
	
			InterpolantFactoryMethodDiscrete: function ( result ) {
	
				return new DiscreteInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodLinear: function ( result ) {
	
				return new LinearInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodSmooth: function ( result ) {
	
				return new CubicInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			setInterpolation: function ( interpolation ) {
	
				var factoryMethod;
	
				switch ( interpolation ) {
	
					case InterpolateDiscrete:
	
						factoryMethod = this.InterpolantFactoryMethodDiscrete;
	
						break;
	
					case InterpolateLinear:
	
						factoryMethod = this.InterpolantFactoryMethodLinear;
	
						break;
	
					case InterpolateSmooth:
	
						factoryMethod = this.InterpolantFactoryMethodSmooth;
	
						break;
	
				}
	
				if ( factoryMethod === undefined ) {
	
					var message = "unsupported interpolation for " +
							this.ValueTypeName + " keyframe track named " + this.name;
	
					if ( this.createInterpolant === undefined ) {
	
						// fall back to default, unless the default itself is messed up
						if ( interpolation !== this.DefaultInterpolation ) {
	
							this.setInterpolation( this.DefaultInterpolation );
	
						} else {
	
							throw new Error( message ); // fatal, in this case
	
						}
	
					}
	
					console.warn( 'THREE.KeyframeTrackPrototype:', message );
					return;
	
				}
	
				this.createInterpolant = factoryMethod;
	
			},
	
			getInterpolation: function () {
	
				switch ( this.createInterpolant ) {
	
					case this.InterpolantFactoryMethodDiscrete:
	
						return InterpolateDiscrete;
	
					case this.InterpolantFactoryMethodLinear:
	
						return InterpolateLinear;
	
					case this.InterpolantFactoryMethodSmooth:
	
						return InterpolateSmooth;
	
				}
	
			},
	
			getValueSize: function () {
	
				return this.values.length / this.times.length;
	
			},
	
			// move all keyframes either forwards or backwards in time
			shift: function ( timeOffset ) {
	
				if ( timeOffset !== 0.0 ) {
	
					var times = this.times;
	
					for ( var i = 0, n = times.length; i !== n; ++ i ) {
	
						times[ i ] += timeOffset;
	
					}
	
				}
	
				return this;
	
			},
	
			// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
			scale: function ( timeScale ) {
	
				if ( timeScale !== 1.0 ) {
	
					var times = this.times;
	
					for ( var i = 0, n = times.length; i !== n; ++ i ) {
	
						times[ i ] *= timeScale;
	
					}
	
				}
	
				return this;
	
			},
	
			// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
			// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
			trim: function ( startTime, endTime ) {
	
				var times = this.times,
					nKeys = times.length,
					from = 0,
					to = nKeys - 1;
	
				while ( from !== nKeys && times[ from ] < startTime ) ++ from;
				while ( to !== - 1 && times[ to ] > endTime ) -- to;
	
				++ to; // inclusive -> exclusive bound
	
				if ( from !== 0 || to !== nKeys ) {
	
					// empty tracks are forbidden, so keep at least one keyframe
					if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;
	
					var stride = this.getValueSize();
					this.times = AnimationUtils.arraySlice( times, from, to );
					this.values = AnimationUtils.
							arraySlice( this.values, from * stride, to * stride );
	
				}
	
				return this;
	
			},
	
			// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
			validate: function () {
	
				var valid = true;
	
				var valueSize = this.getValueSize();
				if ( valueSize - Math.floor( valueSize ) !== 0 ) {
	
					console.error( 'THREE.KeyframeTrackPrototype: Invalid value size in track.', this );
					valid = false;
	
				}
	
				var times = this.times,
					values = this.values,
	
					nKeys = times.length;
	
				if ( nKeys === 0 ) {
	
					console.error( 'THREE.KeyframeTrackPrototype: Track is empty.', this );
					valid = false;
	
				}
	
				var prevTime = null;
	
				for ( var i = 0; i !== nKeys; i ++ ) {
	
					var currTime = times[ i ];
	
					if ( typeof currTime === 'number' && isNaN( currTime ) ) {
	
						console.error( 'THREE.KeyframeTrackPrototype: Time is not a valid number.', this, i, currTime );
						valid = false;
						break;
	
					}
	
					if ( prevTime !== null && prevTime > currTime ) {
	
						console.error( 'THREE.KeyframeTrackPrototype: Out of order keys.', this, i, currTime, prevTime );
						valid = false;
						break;
	
					}
	
					prevTime = currTime;
	
				}
	
				if ( values !== undefined ) {
	
					if ( AnimationUtils.isTypedArray( values ) ) {
	
						for ( var i = 0, n = values.length; i !== n; ++ i ) {
	
							var value = values[ i ];
	
							if ( isNaN( value ) ) {
	
								console.error( 'THREE.KeyframeTrackPrototype: Value is not a valid number.', this, i, value );
								valid = false;
								break;
	
							}
	
						}
	
					}
	
				}
	
				return valid;
	
			},
	
			// removes equivalent sequential keys as common in morph target sequences
			// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
			optimize: function () {
	
				var times = this.times,
					values = this.values,
					stride = this.getValueSize(),
	
					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
	
					writeIndex = 1,
					lastIndex = times.length - 1;
	
				for ( var i = 1; i < lastIndex; ++ i ) {
	
					var keep = false;
	
					var time = times[ i ];
					var timeNext = times[ i + 1 ];
	
					// remove adjacent keyframes scheduled at the same time
	
					if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
	
						if ( ! smoothInterpolation ) {
	
							// remove unnecessary keyframes same as their neighbors
	
							var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;
	
							for ( var j = 0; j !== stride; ++ j ) {
	
								var value = values[ offset + j ];
	
								if ( value !== values[ offsetP + j ] ||
										value !== values[ offsetN + j ] ) {
	
									keep = true;
									break;
	
								}
	
							}
	
						} else keep = true;
	
					}
	
					// in-place compaction
	
					if ( keep ) {
	
						if ( i !== writeIndex ) {
	
							times[ writeIndex ] = times[ i ];
	
							var readOffset = i * stride,
								writeOffset = writeIndex * stride;
	
							for ( var j = 0; j !== stride; ++ j )
	
								values[ writeOffset + j ] = values[ readOffset + j ];
	
						}
	
						++ writeIndex;
	
					}
	
				}
	
				// flush last keyframe (compaction looks ahead)
	
				if ( lastIndex > 0 ) {
	
					times[ writeIndex ] = times[ lastIndex ];
	
					for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )
	
						values[ writeOffset + j ] = values[ readOffset + j ];
	
					++ writeIndex;
	
				}
	
				if ( writeIndex !== times.length ) {
	
					this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
					this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );
	
				}
	
				return this;
	
			}
	
		};
	
		function KeyframeTrackConstructor( name, times, values, interpolation ) {
	
			if ( name === undefined ) throw new Error( "track name is undefined" );
	
			if ( times === undefined || times.length === 0 ) {
	
				throw new Error( "no keyframes in track named " + name );
	
			}
	
			this.name = name;
	
			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );
	
			this.setInterpolation( interpolation || this.DefaultInterpolation );
	
			this.validate();
			this.optimize();
	
		}
	
		/**
		 *
		 * A Track of vectored keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function VectorKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		VectorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: VectorKeyframeTrack,
	
			ValueTypeName: 'vector'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
		} );
	
		/**
		 * Spherical linear unit quaternion interpolant.
		 *
		 * @author tschw
		 */
	
		function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: QuaternionLinearInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					offset = i1 * stride,
	
					alpha = ( t - t0 ) / ( t1 - t0 );
	
				for ( var end = offset + stride; offset !== end; offset += 4 ) {
	
					Quaternion.slerpFlat( result, 0,
							values, offset - stride, values, offset, alpha );
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 *
		 * A Track of quaternion keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function QuaternionKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		QuaternionKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: QuaternionKeyframeTrack,
	
			ValueTypeName: 'quaternion',
	
			// ValueBufferType is inherited
	
			DefaultInterpolation: InterpolateLinear,
	
			InterpolantFactoryMethodLinear: function( result ) {
	
				return new QuaternionLinearInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodSmooth: undefined // not yet implemented
	
		} );
	
		/**
		 *
		 * A Track of numeric keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function NumberKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		NumberKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: NumberKeyframeTrack,
	
			ValueTypeName: 'number'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
		} );
	
		/**
		 *
		 * A Track that interpolates Strings
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function StringKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		StringKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: StringKeyframeTrack,
	
			ValueTypeName: 'string',
			ValueBufferType: Array,
	
			DefaultInterpolation: InterpolateDiscrete,
	
			InterpolantFactoryMethodLinear: undefined,
	
			InterpolantFactoryMethodSmooth: undefined
	
		} );
	
		/**
		 *
		 * A Track of Boolean keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function BooleanKeyframeTrack( name, times, values ) {
	
			KeyframeTrackConstructor.call( this, name, times, values );
	
		}
	
		BooleanKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: BooleanKeyframeTrack,
	
			ValueTypeName: 'bool',
			ValueBufferType: Array,
	
			DefaultInterpolation: InterpolateDiscrete,
	
			InterpolantFactoryMethodLinear: undefined,
			InterpolantFactoryMethodSmooth: undefined
	
			// Note: Actually this track could have a optimized / compressed
			// representation of a single value and a custom interpolant that
			// computes "firstValue ^ isOdd( index )".
	
		} );
	
		/**
		 *
		 * A Track of keyframe values that represent color.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function ColorKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		ColorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: ColorKeyframeTrack,
	
			ValueTypeName: 'color'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
	
			// Note: Very basic implementation and nothing special yet.
			// However, this is the place for color space parameterization.
	
		} );
	
		/**
		 *
		 * A timed sequence of keyframes for a specific property.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function KeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.apply( this, arguments );
	
		}
	
		KeyframeTrack.prototype = KeyframeTrackPrototype;
		KeyframeTrackPrototype.constructor = KeyframeTrack;
	
		// Static methods:
	
		Object.assign( KeyframeTrack, {
	
			// Serialization (in static context, because of constructor invocation
			// and automatic invocation of .toJSON):
	
			parse: function( json ) {
	
				if( json.type === undefined ) {
	
					throw new Error( "track type undefined, can not parse" );
	
				}
	
				var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );
	
				if ( json.times === undefined ) {
	
					var times = [], values = [];
	
					AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
	
					json.times = times;
					json.values = values;
	
				}
	
				// derived classes can define a static parse method
				if ( trackType.parse !== undefined ) {
	
					return trackType.parse( json );
	
				} else {
	
					// by default, we asssume a constructor compatible with the base
					return new trackType(
							json.name, json.times, json.values, json.interpolation );
	
				}
	
			},
	
			toJSON: function( track ) {
	
				var trackType = track.constructor;
	
				var json;
	
				// derived classes can define a static toJSON method
				if ( trackType.toJSON !== undefined ) {
	
					json = trackType.toJSON( track );
	
				} else {
	
					// by default, we assume the data can be serialized as-is
					json = {
	
						'name': track.name,
						'times': AnimationUtils.convertArray( track.times, Array ),
						'values': AnimationUtils.convertArray( track.values, Array )
	
					};
	
					var interpolation = track.getInterpolation();
	
					if ( interpolation !== track.DefaultInterpolation ) {
	
						json.interpolation = interpolation;
	
					}
	
				}
	
				json.type = track.ValueTypeName; // mandatory
	
				return json;
	
			},
	
			_getTrackTypeForValueTypeName: function( typeName ) {
	
				switch( typeName.toLowerCase() ) {
	
					case "scalar":
					case "double":
					case "float":
					case "number":
					case "integer":
	
						return NumberKeyframeTrack;
	
					case "vector":
					case "vector2":
					case "vector3":
					case "vector4":
	
						return VectorKeyframeTrack;
	
					case "color":
	
						return ColorKeyframeTrack;
	
					case "quaternion":
	
						return QuaternionKeyframeTrack;
	
					case "bool":
					case "boolean":
	
						return BooleanKeyframeTrack;
	
					case "string":
	
						return StringKeyframeTrack;
	
				}
	
				throw new Error( "Unsupported typeName: " + typeName );
	
			}
	
		} );
	
		/**
		 *
		 * Reusable set of Tracks that represent an animation.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */
	
		function AnimationClip( name, duration, tracks ) {
	
			this.name = name;
			this.tracks = tracks;
			this.duration = ( duration !== undefined ) ? duration : - 1;
	
			this.uuid = _Math.generateUUID();
	
			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {
	
				this.resetDuration();
	
			}
	
			this.optimize();
	
		}
	
		Object.assign( AnimationClip, {
	
			parse: function ( json ) {
	
				var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / ( json.fps || 1.0 );
	
				for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
	
					tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );
	
				}
	
				return new AnimationClip( json.name, json.duration, tracks );
	
			},
	
			toJSON: function ( clip ) {
	
				var tracks = [],
					clipTracks = clip.tracks;
	
				var json = {
	
					'name': clip.name,
					'duration': clip.duration,
					'tracks': tracks
	
				};
	
				for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
	
					tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );
	
				}
	
				return json;
	
			},
	
			CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {
	
				var numMorphTargets = morphTargetSequence.length;
				var tracks = [];
	
				for ( var i = 0; i < numMorphTargets; i ++ ) {
	
					var times = [];
					var values = [];
	
					times.push(
							( i + numMorphTargets - 1 ) % numMorphTargets,
							i,
							( i + 1 ) % numMorphTargets );
	
					values.push( 0, 1, 0 );
	
					var order = AnimationUtils.getKeyframeOrder( times );
					times = AnimationUtils.sortedArray( times, 1, order );
					values = AnimationUtils.sortedArray( values, 1, order );
	
					// if there is a key at the first frame, duplicate it as the
					// last frame as well for perfect loop.
					if ( ! noLoop && times[ 0 ] === 0 ) {
	
						times.push( numMorphTargets );
						values.push( values[ 0 ] );
	
					}
	
					tracks.push(
							new NumberKeyframeTrack(
								'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
								times, values
							).scale( 1.0 / fps ) );
	
				}
	
				return new AnimationClip( name, - 1, tracks );
	
			},
	
			findByName: function ( objectOrClipArray, name ) {
	
				var clipArray = objectOrClipArray;
	
				if ( ! Array.isArray( objectOrClipArray ) ) {
	
					var o = objectOrClipArray;
					clipArray = o.geometry && o.geometry.animations || o.animations;
	
				}
	
				for ( var i = 0; i < clipArray.length; i ++ ) {
	
					if ( clipArray[ i ].name === name ) {
	
						return clipArray[ i ];
	
					}
	
				}
	
				return null;
	
			},
	
			CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {
	
				var animationToMorphTargets = {};
	
				// tested with https://regex101.com/ on trick sequences
				// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
				var pattern = /^([\w-]*?)([\d]+)$/;
	
				// sort morph target names into animation groups based
				// patterns like Walk_001, Walk_002, Run_001, Run_002
				for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
	
					var morphTarget = morphTargets[ i ];
					var parts = morphTarget.name.match( pattern );
	
					if ( parts && parts.length > 1 ) {
	
						var name = parts[ 1 ];
	
						var animationMorphTargets = animationToMorphTargets[ name ];
						if ( ! animationMorphTargets ) {
	
							animationToMorphTargets[ name ] = animationMorphTargets = [];
	
						}
	
						animationMorphTargets.push( morphTarget );
	
					}
	
				}
	
				var clips = [];
	
				for ( var name in animationToMorphTargets ) {
	
					clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );
	
				}
	
				return clips;
	
			},
	
			// parse the animation.hierarchy format
			parseAnimation: function ( animation, bones ) {
	
				if ( ! animation ) {
	
					console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
					return null;
	
				}
	
				var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {
	
					// only return track if there are actually keys.
					if ( animationKeys.length !== 0 ) {
	
						var times = [];
						var values = [];
	
						AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );
	
						// empty keys are filtered out, so check again
						if ( times.length !== 0 ) {
	
							destTracks.push( new trackType( trackName, times, values ) );
	
						}
	
					}
	
				};
	
				var tracks = [];
	
				var clipName = animation.name || 'default';
				// automatic length determination in AnimationClip.
				var duration = animation.length || - 1;
				var fps = animation.fps || 30;
	
				var hierarchyTracks = animation.hierarchy || [];
	
				for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
	
					var animationKeys = hierarchyTracks[ h ].keys;
	
					// skip empty tracks
					if ( ! animationKeys || animationKeys.length === 0 ) continue;
	
					// process morph targets
					if ( animationKeys[ 0 ].morphTargets ) {
	
						// figure out all morph targets used in this track
						var morphTargetNames = {};
	
						for ( var k = 0; k < animationKeys.length; k ++ ) {
	
							if ( animationKeys[ k ].morphTargets ) {
	
								for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {
	
									morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;
	
								}
	
							}
	
						}
	
						// create a track for each morph target with all zero
						// morphTargetInfluences except for the keys in which
						// the morphTarget is named.
						for ( var morphTargetName in morphTargetNames ) {
	
							var times = [];
							var values = [];
	
							for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {
	
								var animationKey = animationKeys[ k ];
	
								times.push( animationKey.time );
								values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );
	
							}
	
							tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
	
						}
	
						duration = morphTargetNames.length * ( fps || 1.0 );
	
					} else {
	
						// ...assume skeletal animation
	
						var boneName = '.bones[' + bones[ h ].name + ']';
	
						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.position',
								animationKeys, 'pos', tracks );
	
						addNonemptyTrack(
								QuaternionKeyframeTrack, boneName + '.quaternion',
								animationKeys, 'rot', tracks );
	
						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.scale',
								animationKeys, 'scl', tracks );
	
					}
	
				}
	
				if ( tracks.length === 0 ) {
	
					return null;
	
				}
	
				var clip = new AnimationClip( clipName, duration, tracks );
	
				return clip;
	
			}
	
		} );
	
		Object.assign( AnimationClip.prototype, {
	
			resetDuration: function () {
	
				var tracks = this.tracks, duration = 0;
	
				for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
	
					var track = this.tracks[ i ];
	
					duration = Math.max( duration, track.times[ track.times.length - 1 ] );
	
				}
	
				this.duration = duration;
	
			},
	
			trim: function () {
	
				for ( var i = 0; i < this.tracks.length; i ++ ) {
	
					this.tracks[ i ].trim( 0, this.duration );
	
				}
	
				return this;
	
			},
	
			optimize: function () {
	
				for ( var i = 0; i < this.tracks.length; i ++ ) {
	
					this.tracks[ i ].optimize();
	
				}
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function MaterialLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.textures = {};
	
		}
	
		Object.assign( MaterialLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					onLoad( scope.parse( JSON.parse( text ) ) );
	
				}, onProgress, onError );
	
			},
	
			setTextures: function ( value ) {
	
				this.textures = value;
	
			},
	
			parse: function ( json ) {
	
				var textures = this.textures;
	
				function getTexture( name ) {
	
					if ( textures[ name ] === undefined ) {
	
						console.warn( 'THREE.MaterialLoader: Undefined texture', name );
	
					}
	
					return textures[ name ];
	
				}
	
				var material = new Materials[ json.type ]();
	
				if ( json.uuid !== undefined ) material.uuid = json.uuid;
				if ( json.name !== undefined ) material.name = json.name;
				if ( json.color !== undefined ) material.color.setHex( json.color );
				if ( json.roughness !== undefined ) material.roughness = json.roughness;
				if ( json.metalness !== undefined ) material.metalness = json.metalness;
				if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
				if ( json.specular !== undefined ) material.specular.setHex( json.specular );
				if ( json.shininess !== undefined ) material.shininess = json.shininess;
				if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
				if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
				if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
				if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
				if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
				if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
				if ( json.fog !== undefined ) material.fog = json.fog;
				if ( json.shading !== undefined ) material.shading = json.shading;
				if ( json.blending !== undefined ) material.blending = json.blending;
				if ( json.side !== undefined ) material.side = json.side;
				if ( json.opacity !== undefined ) material.opacity = json.opacity;
				if ( json.transparent !== undefined ) material.transparent = json.transparent;
				if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
				if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
				if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
				if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
				if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
				if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
				if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
				if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
				if ( json.skinning !== undefined ) material.skinning = json.skinning;
				if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
	
				// for PointsMaterial
	
				if ( json.size !== undefined ) material.size = json.size;
				if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
				// maps
	
				if ( json.map !== undefined ) material.map = getTexture( json.map );
	
				if ( json.alphaMap !== undefined ) {
	
					material.alphaMap = getTexture( json.alphaMap );
					material.transparent = true;
	
				}
	
				if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
				if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
	
				if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
				if ( json.normalScale !== undefined ) {
	
					var normalScale = json.normalScale;
	
					if ( Array.isArray( normalScale ) === false ) {
	
						// Blender exporter used to export a scalar. See #7459
	
						normalScale = [ normalScale, normalScale ];
	
					}
	
					material.normalScale = new Vector2().fromArray( normalScale );
	
				}
	
				if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
				if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
				if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
	
				if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
				if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );
	
				if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
				if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
	
				if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
	
				if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
	
				if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
	
				if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
				if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
	
				if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
				if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
	
				if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );
	
				return material;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferGeometryLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( BufferGeometryLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					onLoad( scope.parse( JSON.parse( text ) ) );
	
				}, onProgress, onError );
	
			},
	
			parse: function ( json ) {
	
				var geometry = new BufferGeometry();
	
				var index = json.data.index;
	
				if ( index !== undefined ) {
	
					var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
					geometry.setIndex( new BufferAttribute( typedArray, 1 ) );
	
				}
	
				var attributes = json.data.attributes;
	
				for ( var key in attributes ) {
	
					var attribute = attributes[ key ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
	
					geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );
	
				}
	
				var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	
				if ( groups !== undefined ) {
	
					for ( var i = 0, n = groups.length; i !== n; ++ i ) {
	
						var group = groups[ i ];
	
						geometry.addGroup( group.start, group.count, group.materialIndex );
	
					}
	
				}
	
				var boundingSphere = json.data.boundingSphere;
	
				if ( boundingSphere !== undefined ) {
	
					var center = new Vector3();
	
					if ( boundingSphere.center !== undefined ) {
	
						center.fromArray( boundingSphere.center );
	
					}
	
					geometry.boundingSphere = new Sphere( center, boundingSphere.radius );
	
				}
	
				return geometry;
	
			}
	
		} );
	
		var TYPED_ARRAYS = {
			Int8Array: Int8Array,
			Uint8Array: Uint8Array,
			// Workaround for IE11 pre KB2929437. See #11440
			Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
			Int16Array: Int16Array,
			Uint16Array: Uint16Array,
			Int32Array: Int32Array,
			Uint32Array: Uint32Array,
			Float32Array: Float32Array,
			Float64Array: Float64Array
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Loader() {
	
			this.onLoadStart = function () {};
			this.onLoadProgress = function () {};
			this.onLoadComplete = function () {};
	
		}
	
		Loader.Handlers = {
	
			handlers: [],
	
			add: function ( regex, loader ) {
	
				this.handlers.push( regex, loader );
	
			},
	
			get: function ( file ) {
	
				var handlers = this.handlers;
	
				for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
	
					var regex = handlers[ i ];
					var loader = handlers[ i + 1 ];
	
					if ( regex.test( file ) ) {
	
						return loader;
	
					}
	
				}
	
				return null;
	
			}
	
		};
	
		Object.assign( Loader.prototype, {
	
			crossOrigin: undefined,
	
			extractUrlBase: function ( url ) {
	
				var parts = url.split( '/' );
	
				if ( parts.length === 1 ) return './';
	
				parts.pop();
	
				return parts.join( '/' ) + '/';
	
			},
	
			initMaterials: function ( materials, texturePath, crossOrigin ) {
	
				var array = [];
	
				for ( var i = 0; i < materials.length; ++ i ) {
	
					array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
	
				}
	
				return array;
	
			},
	
			createMaterial: ( function () {
	
				var BlendingMode = {
					NoBlending: NoBlending,
					NormalBlending: NormalBlending,
					AdditiveBlending: AdditiveBlending,
					SubtractiveBlending: SubtractiveBlending,
					MultiplyBlending: MultiplyBlending,
					CustomBlending: CustomBlending
				};
	
				var color = new Color();
				var textureLoader = new TextureLoader();
				var materialLoader = new MaterialLoader();
	
				return function createMaterial( m, texturePath, crossOrigin ) {
	
					// convert from old material format
	
					var textures = {};
	
					function loadTexture( path, repeat, offset, wrap, anisotropy ) {
	
						var fullPath = texturePath + path;
						var loader = Loader.Handlers.get( fullPath );
	
						var texture;
	
						if ( loader !== null ) {
	
							texture = loader.load( fullPath );
	
						} else {
	
							textureLoader.setCrossOrigin( crossOrigin );
							texture = textureLoader.load( fullPath );
	
						}
	
						if ( repeat !== undefined ) {
	
							texture.repeat.fromArray( repeat );
	
							if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
							if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;
	
						}
	
						if ( offset !== undefined ) {
	
							texture.offset.fromArray( offset );
	
						}
	
						if ( wrap !== undefined ) {
	
							if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
							if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;
	
							if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
							if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;
	
						}
	
						if ( anisotropy !== undefined ) {
	
							texture.anisotropy = anisotropy;
	
						}
	
						var uuid = _Math.generateUUID();
	
						textures[ uuid ] = texture;
	
						return uuid;
	
					}
	
					//
	
					var json = {
						uuid: _Math.generateUUID(),
						type: 'MeshLambertMaterial'
					};
	
					for ( var name in m ) {
	
						var value = m[ name ];
	
						switch ( name ) {
	
							case 'DbgColor':
							case 'DbgIndex':
							case 'opticalDensity':
							case 'illumination':
								break;
							case 'DbgName':
								json.name = value;
								break;
							case 'blending':
								json.blending = BlendingMode[ value ];
								break;
							case 'colorAmbient':
							case 'mapAmbient':
								console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
								break;
							case 'colorDiffuse':
								json.color = color.fromArray( value ).getHex();
								break;
							case 'colorSpecular':
								json.specular = color.fromArray( value ).getHex();
								break;
							case 'colorEmissive':
								json.emissive = color.fromArray( value ).getHex();
								break;
							case 'specularCoef':
								json.shininess = value;
								break;
							case 'shading':
								if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
								if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
								if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
								break;
							case 'mapDiffuse':
								json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
								break;
							case 'mapDiffuseRepeat':
							case 'mapDiffuseOffset':
							case 'mapDiffuseWrap':
							case 'mapDiffuseAnisotropy':
								break;
							case 'mapEmissive':
								json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
								break;
							case 'mapEmissiveRepeat':
							case 'mapEmissiveOffset':
							case 'mapEmissiveWrap':
							case 'mapEmissiveAnisotropy':
								break;
							case 'mapLight':
								json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
								break;
							case 'mapLightRepeat':
							case 'mapLightOffset':
							case 'mapLightWrap':
							case 'mapLightAnisotropy':
								break;
							case 'mapAO':
								json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
								break;
							case 'mapAORepeat':
							case 'mapAOOffset':
							case 'mapAOWrap':
							case 'mapAOAnisotropy':
								break;
							case 'mapBump':
								json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
								break;
							case 'mapBumpScale':
								json.bumpScale = value;
								break;
							case 'mapBumpRepeat':
							case 'mapBumpOffset':
							case 'mapBumpWrap':
							case 'mapBumpAnisotropy':
								break;
							case 'mapNormal':
								json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
								break;
							case 'mapNormalFactor':
								json.normalScale = [ value, value ];
								break;
							case 'mapNormalRepeat':
							case 'mapNormalOffset':
							case 'mapNormalWrap':
							case 'mapNormalAnisotropy':
								break;
							case 'mapSpecular':
								json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
								break;
							case 'mapSpecularRepeat':
							case 'mapSpecularOffset':
							case 'mapSpecularWrap':
							case 'mapSpecularAnisotropy':
								break;
							case 'mapMetalness':
								json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
								break;
							case 'mapMetalnessRepeat':
							case 'mapMetalnessOffset':
							case 'mapMetalnessWrap':
							case 'mapMetalnessAnisotropy':
								break;
							case 'mapRoughness':
								json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
								break;
							case 'mapRoughnessRepeat':
							case 'mapRoughnessOffset':
							case 'mapRoughnessWrap':
							case 'mapRoughnessAnisotropy':
								break;
							case 'mapAlpha':
								json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
								break;
							case 'mapAlphaRepeat':
							case 'mapAlphaOffset':
							case 'mapAlphaWrap':
							case 'mapAlphaAnisotropy':
								break;
							case 'flipSided':
								json.side = BackSide;
								break;
							case 'doubleSided':
								json.side = DoubleSide;
								break;
							case 'transparency':
								console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
								json.opacity = value;
								break;
							case 'depthTest':
							case 'depthWrite':
							case 'colorWrite':
							case 'opacity':
							case 'reflectivity':
							case 'transparent':
							case 'visible':
							case 'wireframe':
								json[ name ] = value;
								break;
							case 'vertexColors':
								if ( value === true ) json.vertexColors = VertexColors;
								if ( value === 'face' ) json.vertexColors = FaceColors;
								break;
							default:
								console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
								break;
	
						}
	
					}
	
					if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
					if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
	
					if ( json.opacity < 1 ) json.transparent = true;
	
					materialLoader.setTextures( textures );
	
					return materialLoader.parse( json );
	
				};
	
			} )()
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function JSONLoader( manager ) {
	
			if ( typeof manager === 'boolean' ) {
	
				console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
				manager = undefined;
	
			}
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			this.withCredentials = false;
	
		}
	
		Object.assign( JSONLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );
	
				var loader = new FileLoader( this.manager );
				loader.setWithCredentials( this.withCredentials );
				loader.load( url, function ( text ) {
	
					var json = JSON.parse( text );
					var metadata = json.metadata;
	
					if ( metadata !== undefined ) {
	
						var type = metadata.type;
	
						if ( type !== undefined ) {
	
							if ( type.toLowerCase() === 'object' ) {
	
								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;
	
							}
	
							if ( type.toLowerCase() === 'scene' ) {
	
								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
								return;
	
							}
	
						}
	
					}
	
					var object = scope.parse( json, texturePath );
					onLoad( object.geometry, object.materials );
	
				}, onProgress, onError );
	
			},
	
			setTexturePath: function ( value ) {
	
				this.texturePath = value;
	
			},
	
			parse: ( function () {
	
				function parseModel( json, geometry ) {
	
					function isBitSet( value, position ) {
	
						return value & ( 1 << position );
	
					}
	
					var i, j, fi,
	
						offset, zLength,
	
						colorIndex, normalIndex, uvIndex, materialIndex,
	
						type,
						isQuad,
						hasMaterial,
						hasFaceVertexUv,
						hasFaceNormal, hasFaceVertexNormal,
						hasFaceColor, hasFaceVertexColor,
	
						vertex, face, faceA, faceB, hex, normal,
	
						uvLayer, uv, u, v,
	
						faces = json.faces,
						vertices = json.vertices,
						normals = json.normals,
						colors = json.colors,
	
						scale = json.scale,
	
						nUvLayers = 0;
	
	
					if ( json.uvs !== undefined ) {
	
						// disregard empty arrays
	
						for ( i = 0; i < json.uvs.length; i ++ ) {
	
							if ( json.uvs[ i ].length ) nUvLayers ++;
	
						}
	
						for ( i = 0; i < nUvLayers; i ++ ) {
	
							geometry.faceVertexUvs[ i ] = [];
	
						}
	
					}
	
					offset = 0;
					zLength = vertices.length;
	
					while ( offset < zLength ) {
	
						vertex = new Vector3();
	
						vertex.x = vertices[ offset ++ ] * scale;
						vertex.y = vertices[ offset ++ ] * scale;
						vertex.z = vertices[ offset ++ ] * scale;
	
						geometry.vertices.push( vertex );
	
					}
	
					offset = 0;
					zLength = faces.length;
	
					while ( offset < zLength ) {
	
						type = faces[ offset ++ ];
	
						isQuad = isBitSet( type, 0 );
						hasMaterial = isBitSet( type, 1 );
						hasFaceVertexUv = isBitSet( type, 3 );
						hasFaceNormal = isBitSet( type, 4 );
						hasFaceVertexNormal = isBitSet( type, 5 );
						hasFaceColor = isBitSet( type, 6 );
						hasFaceVertexColor = isBitSet( type, 7 );
	
						// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
						if ( isQuad ) {
	
							faceA = new Face3();
							faceA.a = faces[ offset ];
							faceA.b = faces[ offset + 1 ];
							faceA.c = faces[ offset + 3 ];
	
							faceB = new Face3();
							faceB.a = faces[ offset + 1 ];
							faceB.b = faces[ offset + 2 ];
							faceB.c = faces[ offset + 3 ];
	
							offset += 4;
	
							if ( hasMaterial ) {
	
								materialIndex = faces[ offset ++ ];
								faceA.materialIndex = materialIndex;
								faceB.materialIndex = materialIndex;
	
							}
	
							// to get face <=> uv index correspondence
	
							fi = geometry.faces.length;
	
							if ( hasFaceVertexUv ) {
	
								for ( i = 0; i < nUvLayers; i ++ ) {
	
									uvLayer = json.uvs[ i ];
	
									geometry.faceVertexUvs[ i ][ fi ] = [];
									geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
	
									for ( j = 0; j < 4; j ++ ) {
	
										uvIndex = faces[ offset ++ ];
	
										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];
	
										uv = new Vector2( u, v );
	
										if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
										if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
									}
	
								}
	
							}
	
							if ( hasFaceNormal ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								faceA.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
								faceB.normal.copy( faceA.normal );
	
							}
	
							if ( hasFaceVertexNormal ) {
	
								for ( i = 0; i < 4; i ++ ) {
	
									normalIndex = faces[ offset ++ ] * 3;
	
									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);
	
	
									if ( i !== 2 ) faceA.vertexNormals.push( normal );
									if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
								}
	
							}
	
	
							if ( hasFaceColor ) {
	
								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];
	
								faceA.color.setHex( hex );
								faceB.color.setHex( hex );
	
							}
	
	
							if ( hasFaceVertexColor ) {
	
								for ( i = 0; i < 4; i ++ ) {
	
									colorIndex = faces[ offset ++ ];
									hex = colors[ colorIndex ];
	
									if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
									if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );
	
								}
	
							}
	
							geometry.faces.push( faceA );
							geometry.faces.push( faceB );
	
						} else {
	
							face = new Face3();
							face.a = faces[ offset ++ ];
							face.b = faces[ offset ++ ];
							face.c = faces[ offset ++ ];
	
							if ( hasMaterial ) {
	
								materialIndex = faces[ offset ++ ];
								face.materialIndex = materialIndex;
	
							}
	
							// to get face <=> uv index correspondence
	
							fi = geometry.faces.length;
	
							if ( hasFaceVertexUv ) {
	
								for ( i = 0; i < nUvLayers; i ++ ) {
	
									uvLayer = json.uvs[ i ];
	
									geometry.faceVertexUvs[ i ][ fi ] = [];
	
									for ( j = 0; j < 3; j ++ ) {
	
										uvIndex = faces[ offset ++ ];
	
										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];
	
										uv = new Vector2( u, v );
	
										geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
									}
	
								}
	
							}
	
							if ( hasFaceNormal ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								face.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
							}
	
							if ( hasFaceVertexNormal ) {
	
								for ( i = 0; i < 3; i ++ ) {
	
									normalIndex = faces[ offset ++ ] * 3;
	
									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);
	
									face.vertexNormals.push( normal );
	
								}
	
							}
	
	
							if ( hasFaceColor ) {
	
								colorIndex = faces[ offset ++ ];
								face.color.setHex( colors[ colorIndex ] );
	
							}
	
	
							if ( hasFaceVertexColor ) {
	
								for ( i = 0; i < 3; i ++ ) {
	
									colorIndex = faces[ offset ++ ];
									face.vertexColors.push( new Color( colors[ colorIndex ] ) );
	
								}
	
							}
	
							geometry.faces.push( face );
	
						}
	
					}
	
				}
	
				function parseSkin( json, geometry ) {
	
					var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
	
					if ( json.skinWeights ) {
	
						for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
	
							var x = json.skinWeights[ i ];
							var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
							var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
							var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
	
							geometry.skinWeights.push( new Vector4( x, y, z, w ) );
	
						}
	
					}
	
					if ( json.skinIndices ) {
	
						for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
	
							var a = json.skinIndices[ i ];
							var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
							var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
							var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
	
							geometry.skinIndices.push( new Vector4( a, b, c, d ) );
	
						}
	
					}
	
					geometry.bones = json.bones;
	
					if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
	
						console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
							geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
	
					}
	
				}
	
				function parseMorphing( json, geometry ) {
	
					var scale = json.scale;
	
					if ( json.morphTargets !== undefined ) {
	
						for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
							geometry.morphTargets[ i ] = {};
							geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
							geometry.morphTargets[ i ].vertices = [];
	
							var dstVertices = geometry.morphTargets[ i ].vertices;
							var srcVertices = json.morphTargets[ i ].vertices;
	
							for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
								var vertex = new Vector3();
								vertex.x = srcVertices[ v ] * scale;
								vertex.y = srcVertices[ v + 1 ] * scale;
								vertex.z = srcVertices[ v + 2 ] * scale;
	
								dstVertices.push( vertex );
	
							}
	
						}
	
					}
	
					if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {
	
						console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );
	
						var faces = geometry.faces;
						var morphColors = json.morphColors[ 0 ].colors;
	
						for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
							faces[ i ].color.fromArray( morphColors, i * 3 );
	
						}
	
					}
	
				}
	
				function parseAnimations( json, geometry ) {
	
					var outputAnimations = [];
	
					// parse old style Bone/Hierarchy animations
					var animations = [];
	
					if ( json.animation !== undefined ) {
	
						animations.push( json.animation );
	
					}
	
					if ( json.animations !== undefined ) {
	
						if ( json.animations.length ) {
	
							animations = animations.concat( json.animations );
	
						} else {
	
							animations.push( json.animations );
	
						}
	
					}
	
					for ( var i = 0; i < animations.length; i ++ ) {
	
						var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
						if ( clip ) outputAnimations.push( clip );
	
					}
	
					// parse implicit morph animations
					if ( geometry.morphTargets ) {
	
						// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
						var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
						outputAnimations = outputAnimations.concat( morphAnimationClips );
	
					}
	
					if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;
	
				}
	
				return function ( json, texturePath ) {
	
					if ( json.data !== undefined ) {
	
						// Geometry 4.0 spec
						json = json.data;
	
					}
	
					if ( json.scale !== undefined ) {
	
						json.scale = 1.0 / json.scale;
	
					} else {
	
						json.scale = 1.0;
	
					}
	
					var geometry = new Geometry();
	
					parseModel( json, geometry );
					parseSkin( json, geometry );
					parseMorphing( json, geometry );
					parseAnimations( json, geometry );
	
					geometry.computeFaceNormals();
					geometry.computeBoundingSphere();
	
					if ( json.materials === undefined || json.materials.length === 0 ) {
	
						return { geometry: geometry };
	
					} else {
	
						var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );
	
						return { geometry: geometry, materials: materials };
	
					}
	
				};
	
			} )()
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ObjectLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.texturePath = '';
	
		}
	
		Object.assign( ObjectLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( this.texturePath === '' ) {
	
					this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
	
				}
	
				var scope = this;
	
				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					var json = null;
	
					try {
	
						json = JSON.parse( text );
	
					} catch ( error ) {
	
						if ( onError !== undefined ) onError( error );
	
						console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );
	
						return;
	
					}
	
					var metadata = json.metadata;
	
					if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {
	
						console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
						return;
	
					}
	
					scope.parse( json, onLoad );
	
				}, onProgress, onError );
	
			},
	
			setTexturePath: function ( value ) {
	
				this.texturePath = value;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
	
			},
	
			parse: function ( json, onLoad ) {
	
				var geometries = this.parseGeometries( json.geometries );
	
				var images = this.parseImages( json.images, function () {
	
					if ( onLoad !== undefined ) onLoad( object );
	
				} );
	
				var textures = this.parseTextures( json.textures, images );
				var materials = this.parseMaterials( json.materials, textures );
	
				var object = this.parseObject( json.object, geometries, materials );
	
				if ( json.animations ) {
	
					object.animations = this.parseAnimations( json.animations );
	
				}
	
				if ( json.images === undefined || json.images.length === 0 ) {
	
					if ( onLoad !== undefined ) onLoad( object );
	
				}
	
				return object;
	
			},
	
			parseGeometries: function ( json ) {
	
				var geometries = {};
	
				if ( json !== undefined ) {
	
					var geometryLoader = new JSONLoader();
					var bufferGeometryLoader = new BufferGeometryLoader();
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var geometry;
						var data = json[ i ];
	
						switch ( data.type ) {
	
							case 'PlaneGeometry':
							case 'PlaneBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.widthSegments,
									data.heightSegments
								);
	
								break;
	
							case 'BoxGeometry':
							case 'BoxBufferGeometry':
							case 'CubeGeometry': // backwards compatible
	
								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.depth,
									data.widthSegments,
									data.heightSegments,
									data.depthSegments
								);
	
								break;
	
							case 'CircleGeometry':
							case 'CircleBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.segments,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'CylinderGeometry':
							case 'CylinderBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radiusTop,
									data.radiusBottom,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'ConeGeometry':
							case 'ConeBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'SphereGeometry':
							case 'SphereBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.widthSegments,
									data.heightSegments,
									data.phiStart,
									data.phiLength,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'DodecahedronGeometry':
							case 'IcosahedronGeometry':
							case 'OctahedronGeometry':
							case 'TetrahedronGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.detail
								);
	
								break;
	
							case 'RingGeometry':
							case 'RingBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.innerRadius,
									data.outerRadius,
									data.thetaSegments,
									data.phiSegments,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'TorusGeometry':
							case 'TorusBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.radialSegments,
									data.tubularSegments,
									data.arc
								);
	
								break;
	
							case 'TorusKnotGeometry':
							case 'TorusKnotBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.tubularSegments,
									data.radialSegments,
									data.p,
									data.q
								);
	
								break;
	
							case 'LatheGeometry':
							case 'LatheBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.points,
									data.segments,
									data.phiStart,
									data.phiLength
								);
	
								break;
	
							case 'BufferGeometry':
	
								geometry = bufferGeometryLoader.parse( data );
	
								break;
	
							case 'Geometry':
	
								geometry = geometryLoader.parse( data, this.texturePath ).geometry;
	
								break;
	
							default:
	
								console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
	
								continue;
	
						}
	
						geometry.uuid = data.uuid;
	
						if ( data.name !== undefined ) geometry.name = data.name;
	
						geometries[ data.uuid ] = geometry;
	
					}
	
				}
	
				return geometries;
	
			},
	
			parseMaterials: function ( json, textures ) {
	
				var materials = {};
	
				if ( json !== undefined ) {
	
					var loader = new MaterialLoader();
					loader.setTextures( textures );
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var data = json[ i ];
	
						if ( data.type === 'MultiMaterial' ) {
	
							// Deprecated
	
							var array = [];
	
							for ( var j = 0; j < data.materials.length; j ++ ) {
	
								array.push( loader.parse( data.materials[ j ] ) );
	
							}
	
							materials[ data.uuid ] = array;
	
						} else {
	
							materials[ data.uuid ] = loader.parse( data );
	
						}
	
					}
	
				}
	
				return materials;
	
			},
	
			parseAnimations: function ( json ) {
	
				var animations = [];
	
				for ( var i = 0; i < json.length; i ++ ) {
	
					var clip = AnimationClip.parse( json[ i ] );
	
					animations.push( clip );
	
				}
	
				return animations;
	
			},
	
			parseImages: function ( json, onLoad ) {
	
				var scope = this;
				var images = {};
	
				function loadImage( url ) {
	
					scope.manager.itemStart( url );
	
					return loader.load( url, function () {
	
						scope.manager.itemEnd( url );
	
					}, undefined, function () {
	
						scope.manager.itemEnd( url );
						scope.manager.itemError( url );
	
					} );
	
				}
	
				if ( json !== undefined && json.length > 0 ) {
	
					var manager = new LoadingManager( onLoad );
	
					var loader = new ImageLoader( manager );
					loader.setCrossOrigin( this.crossOrigin );
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var image = json[ i ];
						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
	
						images[ image.uuid ] = loadImage( path );
	
					}
	
				}
	
				return images;
	
			},
	
			parseTextures: function ( json, images ) {
	
				function parseConstant( value, type ) {
	
					if ( typeof( value ) === 'number' ) return value;
	
					console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
	
					return type[ value ];
	
				}
	
				var textures = {};
	
				if ( json !== undefined ) {
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var data = json[ i ];
	
						if ( data.image === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
	
						}
	
						if ( images[ data.image ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
						}
	
						var texture = new Texture( images[ data.image ] );
						texture.needsUpdate = true;
	
						texture.uuid = data.uuid;
	
						if ( data.name !== undefined ) texture.name = data.name;
	
						if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );
	
						if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
						if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
						if ( data.wrap !== undefined ) {
	
							texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
							texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );
	
						}
	
						if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
						if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
						if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
	
						if ( data.flipY !== undefined ) texture.flipY = data.flipY;
	
						textures[ data.uuid ] = texture;
	
					}
	
				}
	
				return textures;
	
			},
	
			parseObject: function () {
	
				var matrix = new Matrix4();
	
				return function parseObject( data, geometries, materials ) {
	
					var object;
	
					function getGeometry( name ) {
	
						if ( geometries[ name ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
						}
	
						return geometries[ name ];
	
					}
	
					function getMaterial( name ) {
	
						if ( name === undefined ) return undefined;
	
						if ( Array.isArray( name ) ) {
	
							var array = [];
	
							for ( var i = 0, l = name.length; i < l; i ++ ) {
	
								var uuid = name[ i ];
	
								if ( materials[ uuid ] === undefined ) {
	
									console.warn( 'THREE.ObjectLoader: Undefined material', uuid );
	
								}
	
								array.push( materials[ uuid ] );
	
							}
	
							return array;
	
						}
	
						if ( materials[ name ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined material', name );
	
						}
	
						return materials[ name ];
	
					}
	
					switch ( data.type ) {
	
						case 'Scene':
	
							object = new Scene();
	
							if ( data.background !== undefined ) {
	
								if ( Number.isInteger( data.background ) ) {
	
									object.background = new Color( data.background );
	
								}
	
							}
	
							if ( data.fog !== undefined ) {
	
								if ( data.fog.type === 'Fog' ) {
	
									object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );
	
								} else if ( data.fog.type === 'FogExp2' ) {
	
									object.fog = new FogExp2( data.fog.color, data.fog.density );
	
								}
	
							}
	
							break;
	
						case 'PerspectiveCamera':
	
							object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
							if ( data.focus !== undefined ) object.focus = data.focus;
							if ( data.zoom !== undefined ) object.zoom = data.zoom;
							if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
							if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
							if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
	
							break;
	
						case 'OrthographicCamera':
	
							object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
							break;
	
						case 'AmbientLight':
	
							object = new AmbientLight( data.color, data.intensity );
	
							break;
	
						case 'DirectionalLight':
	
							object = new DirectionalLight( data.color, data.intensity );
	
							break;
	
						case 'PointLight':
	
							object = new PointLight( data.color, data.intensity, data.distance, data.decay );
	
							break;
	
						case 'RectAreaLight':
	
							object = new RectAreaLight( data.color, data.intensity, data.width, data.height );
	
							break;
	
						case 'SpotLight':
	
							object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
	
							break;
	
						case 'HemisphereLight':
	
							object = new HemisphereLight( data.color, data.groundColor, data.intensity );
	
							break;
	
						case 'SkinnedMesh':
	
							console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );
	
						case 'Mesh':
	
							var geometry = getGeometry( data.geometry );
							var material = getMaterial( data.material );
	
							if ( geometry.bones && geometry.bones.length > 0 ) {
	
								object = new SkinnedMesh( geometry, material );
	
							} else {
	
								object = new Mesh( geometry, material );
	
							}
	
							break;
	
						case 'LOD':
	
							object = new LOD();
	
							break;
	
						case 'Line':
	
							object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
							break;
	
						case 'LineLoop':
	
							object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );
	
							break;
	
						case 'LineSegments':
	
							object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );
	
							break;
	
						case 'PointCloud':
						case 'Points':
	
							object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );
	
							break;
	
						case 'Sprite':
	
							object = new Sprite( getMaterial( data.material ) );
	
							break;
	
						case 'Group':
	
							object = new Group();
	
							break;
	
						default:
	
							object = new Object3D();
	
					}
	
					object.uuid = data.uuid;
	
					if ( data.name !== undefined ) object.name = data.name;
					if ( data.matrix !== undefined ) {
	
						matrix.fromArray( data.matrix );
						matrix.decompose( object.position, object.quaternion, object.scale );
	
					} else {
	
						if ( data.position !== undefined ) object.position.fromArray( data.position );
						if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
						if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
						if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
					}
	
					if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
					if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
	
					if ( data.shadow ) {
	
						if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
						if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
						if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
						if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );
	
					}
	
					if ( data.visible !== undefined ) object.visible = data.visible;
					if ( data.userData !== undefined ) object.userData = data.userData;
	
					if ( data.children !== undefined ) {
	
						for ( var child in data.children ) {
	
							object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
						}
	
					}
	
					if ( data.type === 'LOD' ) {
	
						var levels = data.levels;
	
						for ( var l = 0; l < levels.length; l ++ ) {
	
							var level = levels[ l ];
							var child = object.getObjectByProperty( 'uuid', level.object );
	
							if ( child !== undefined ) {
	
								object.addLevel( child, level.distance );
	
							}
	
						}
	
					}
	
					return object;
	
				};
	
			}()
	
		} );
	
		var TEXTURE_MAPPING = {
			UVMapping: UVMapping,
			CubeReflectionMapping: CubeReflectionMapping,
			CubeRefractionMapping: CubeRefractionMapping,
			EquirectangularReflectionMapping: EquirectangularReflectionMapping,
			EquirectangularRefractionMapping: EquirectangularRefractionMapping,
			SphericalReflectionMapping: SphericalReflectionMapping,
			CubeUVReflectionMapping: CubeUVReflectionMapping,
			CubeUVRefractionMapping: CubeUVRefractionMapping
		};
	
		var TEXTURE_WRAPPING = {
			RepeatWrapping: RepeatWrapping,
			ClampToEdgeWrapping: ClampToEdgeWrapping,
			MirroredRepeatWrapping: MirroredRepeatWrapping
		};
	
		var TEXTURE_FILTER = {
			NearestFilter: NearestFilter,
			NearestMipMapNearestFilter: NearestMipMapNearestFilter,
			NearestMipMapLinearFilter: NearestMipMapLinearFilter,
			LinearFilter: LinearFilter,
			LinearMipMapNearestFilter: LinearMipMapNearestFilter,
			LinearMipMapLinearFilter: LinearMipMapLinearFilter
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Bezier Curves formulas obtained from
		 * http://en.wikipedia.org/wiki/Bzier_curve
		 */
	
		function CatmullRom( t, p0, p1, p2, p3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
		//
	
		function QuadraticBezierP0( t, p ) {
	
			var k = 1 - t;
			return k * k * p;
	
		}
	
		function QuadraticBezierP1( t, p ) {
	
			return 2 * ( 1 - t ) * t * p;
	
		}
	
		function QuadraticBezierP2( t, p ) {
	
			return t * t * p;
	
		}
	
		function QuadraticBezier( t, p0, p1, p2 ) {
	
			return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
				QuadraticBezierP2( t, p2 );
	
		}
	
		//
	
		function CubicBezierP0( t, p ) {
	
			var k = 1 - t;
			return k * k * k * p;
	
		}
	
		function CubicBezierP1( t, p ) {
	
			var k = 1 - t;
			return 3 * k * k * t * p;
	
		}
	
		function CubicBezierP2( t, p ) {
	
			return 3 * ( 1 - t ) * t * t * p;
	
		}
	
		function CubicBezierP3( t, p ) {
	
			return t * t * t * p;
	
		}
	
		function CubicBezier( t, p0, p1, p2, p3 ) {
	
			return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
				CubicBezierP3( t, p3 );
	
		}
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Extensible curve object
		 *
		 * Some common of curve methods:
		 * .getPoint(t), getTangent(t)
		 * .getPointAt(u), getTangentAt(u)
		 * .getPoints(), .getSpacedPoints()
		 * .getLength()
		 * .updateArcLengths()
		 *
		 * This following curves inherit from THREE.Curve:
		 *
		 * -- 2D curves --
		 * THREE.ArcCurve
		 * THREE.CubicBezierCurve
		 * THREE.EllipseCurve
		 * THREE.LineCurve
		 * THREE.QuadraticBezierCurve
		 * THREE.SplineCurve
		 *
		 * -- 3D curves --
		 * THREE.CatmullRomCurve3
		 * THREE.CubicBezierCurve3
		 * THREE.LineCurve3
		 * THREE.QuadraticBezierCurve3
		 *
		 * A series of curves can be represented as a THREE.CurvePath.
		 *
		 **/
	
		/**************************************************************
		 *	Abstract Curve base class
		 **************************************************************/
	
		function Curve() {
	
			this.arcLengthDivisions = 200;
	
		}
	
		Object.assign( Curve.prototype, {
	
			// Virtual base class method to overwrite and implement in subclasses
			//	- t [0 .. 1]
	
			getPoint: function () {
	
				console.warn( 'THREE.Curve: .getPoint() not implemented.' );
				return null;
	
			},
	
			// Get point at relative position in curve according to arc length
			// - u [0 .. 1]
	
			getPointAt: function ( u ) {
	
				var t = this.getUtoTmapping( u );
				return this.getPoint( t );
	
			},
	
			// Get sequence of points using getPoint( t )
	
			getPoints: function ( divisions ) {
	
				if ( divisions === undefined ) divisions = 5;
	
				var points = [];
	
				for ( var d = 0; d <= divisions; d ++ ) {
	
					points.push( this.getPoint( d / divisions ) );
	
				}
	
				return points;
	
			},
	
			// Get sequence of points using getPointAt( u )
	
			getSpacedPoints: function ( divisions ) {
	
				if ( divisions === undefined ) divisions = 5;
	
				var points = [];
	
				for ( var d = 0; d <= divisions; d ++ ) {
	
					points.push( this.getPointAt( d / divisions ) );
	
				}
	
				return points;
	
			},
	
			// Get total curve arc length
	
			getLength: function () {
	
				var lengths = this.getLengths();
				return lengths[ lengths.length - 1 ];
	
			},
	
			// Get list of cumulative segment lengths
	
			getLengths: function ( divisions ) {
	
				if ( divisions === undefined ) divisions = this.arcLengthDivisions;
	
				if ( this.cacheArcLengths &&
					( this.cacheArcLengths.length === divisions + 1 ) &&
					! this.needsUpdate ) {
	
					return this.cacheArcLengths;
	
				}
	
				this.needsUpdate = false;
	
				var cache = [];
				var current, last = this.getPoint( 0 );
				var p, sum = 0;
	
				cache.push( 0 );
	
				for ( p = 1; p <= divisions; p ++ ) {
	
					current = this.getPoint( p / divisions );
					sum += current.distanceTo( last );
					cache.push( sum );
					last = current;
	
				}
	
				this.cacheArcLengths = cache;
	
				return cache; // { sums: cache, sum: sum }; Sum is in the last element.
	
			},
	
			updateArcLengths: function () {
	
				this.needsUpdate = true;
				this.getLengths();
	
			},
	
			// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	
			getUtoTmapping: function ( u, distance ) {
	
				var arcLengths = this.getLengths();
	
				var i = 0, il = arcLengths.length;
	
				var targetArcLength; // The targeted u distance value to get
	
				if ( distance ) {
	
					targetArcLength = distance;
	
				} else {
	
					targetArcLength = u * arcLengths[ il - 1 ];
	
				}
	
				// binary search for the index with largest value smaller than target u distance
	
				var low = 0, high = il - 1, comparison;
	
				while ( low <= high ) {
	
					i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
					comparison = arcLengths[ i ] - targetArcLength;
	
					if ( comparison < 0 ) {
	
						low = i + 1;
	
					} else if ( comparison > 0 ) {
	
						high = i - 1;
	
					} else {
	
						high = i;
						break;
	
						// DONE
	
					}
	
				}
	
				i = high;
	
				if ( arcLengths[ i ] === targetArcLength ) {
	
					return i / ( il - 1 );
	
				}
	
				// we could get finer grain at lengths, or use simple interpolation between two points
	
				var lengthBefore = arcLengths[ i ];
				var lengthAfter = arcLengths[ i + 1 ];
	
				var segmentLength = lengthAfter - lengthBefore;
	
				// determine where we are between the 'before' and 'after' points
	
				var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
				// add that fractional amount to t
	
				var t = ( i + segmentFraction ) / ( il - 1 );
	
				return t;
	
			},
	
			// Returns a unit vector tangent at t
			// In case any sub curve does not implement its tangent derivation,
			// 2 points a small delta apart will be used to find its gradient
			// which seems to give a reasonable approximation
	
			getTangent: function ( t ) {
	
				var delta = 0.0001;
				var t1 = t - delta;
				var t2 = t + delta;
	
				// Capping in case of danger
	
				if ( t1 < 0 ) t1 = 0;
				if ( t2 > 1 ) t2 = 1;
	
				var pt1 = this.getPoint( t1 );
				var pt2 = this.getPoint( t2 );
	
				var vec = pt2.clone().sub( pt1 );
				return vec.normalize();
	
			},
	
			getTangentAt: function ( u ) {
	
				var t = this.getUtoTmapping( u );
				return this.getTangent( t );
	
			},
	
			computeFrenetFrames: function ( segments, closed ) {
	
				// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	
				var normal = new Vector3();
	
				var tangents = [];
				var normals = [];
				var binormals = [];
	
				var vec = new Vector3();
				var mat = new Matrix4();
	
				var i, u, theta;
	
				// compute the tangent vectors for each segment on the curve
	
				for ( i = 0; i <= segments; i ++ ) {
	
					u = i / segments;
	
					tangents[ i ] = this.getTangentAt( u );
					tangents[ i ].normalize();
	
				}
	
				// select an initial normal vector perpendicular to the first tangent vector,
				// and in the direction of the minimum tangent xyz component
	
				normals[ 0 ] = new Vector3();
				binormals[ 0 ] = new Vector3();
				var min = Number.MAX_VALUE;
				var tx = Math.abs( tangents[ 0 ].x );
				var ty = Math.abs( tangents[ 0 ].y );
				var tz = Math.abs( tangents[ 0 ].z );
	
				if ( tx <= min ) {
	
					min = tx;
					normal.set( 1, 0, 0 );
	
				}
	
				if ( ty <= min ) {
	
					min = ty;
					normal.set( 0, 1, 0 );
	
				}
	
				if ( tz <= min ) {
	
					normal.set( 0, 0, 1 );
	
				}
	
				vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
				normals[ 0 ].crossVectors( tangents[ 0 ], vec );
				binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	
	
				// compute the slowly-varying normal and binormal vectors for each segment on the curve
	
				for ( i = 1; i <= segments; i ++ ) {
	
					normals[ i ] = normals[ i - 1 ].clone();
	
					binormals[ i ] = binormals[ i - 1 ].clone();
	
					vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
					if ( vec.length() > Number.EPSILON ) {
	
						vec.normalize();
	
						theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
						normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
					}
	
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
				}
	
				// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
				if ( closed === true ) {
	
					theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
					theta /= segments;
	
					if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {
	
						theta = - theta;
	
					}
	
					for ( i = 1; i <= segments; i ++ ) {
	
						// twist a little...
						normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
						binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
					}
	
				}
	
				return {
					tangents: tangents,
					normals: normals,
					binormals: binormals
				};
	
			}
	
		} );
	
		function LineCurve( v1, v2 ) {
	
			Curve.call( this );
	
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		LineCurve.prototype = Object.create( Curve.prototype );
		LineCurve.prototype.constructor = LineCurve;
	
		LineCurve.prototype.isLineCurve = true;
	
		LineCurve.prototype.getPoint = function ( t ) {
	
			if ( t === 1 ) {
	
				return this.v2.clone();
	
			}
	
			var point = this.v2.clone().sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );
	
			return point;
	
		};
	
		// Line curve is linear, so we can overwrite default getPointAt
	
		LineCurve.prototype.getPointAt = function ( u ) {
	
			return this.getPoint( u );
	
		};
	
		LineCurve.prototype.getTangent = function ( t ) {
	
			var tangent = this.v2.clone().sub( this.v1 );
	
			return tangent.normalize();
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 **/
	
		/**************************************************************
		 *	Curved Path - a curve path is simply a array of connected
		 *  curves, but retains the api of a curve
		 **************************************************************/
	
		function CurvePath() {
	
			Curve.call( this );
	
			this.curves = [];
	
			this.autoClose = false; // Automatically closes the path
	
		}
	
		CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {
	
			constructor: CurvePath,
	
			add: function ( curve ) {
	
				this.curves.push( curve );
	
			},
	
			closePath: function () {
	
				// Add a line curve if start and end of lines are not connected
				var startPoint = this.curves[ 0 ].getPoint( 0 );
				var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
	
				if ( ! startPoint.equals( endPoint ) ) {
	
					this.curves.push( new LineCurve( endPoint, startPoint ) );
	
				}
	
			},
	
			// To get accurate point with reference to
			// entire path distance at time t,
			// following has to be done:
	
			// 1. Length of each sub path have to be known
			// 2. Locate and identify type of curve
			// 3. Get t for the curve
			// 4. Return curve.getPointAt(t')
	
			getPoint: function ( t ) {
	
				var d = t * this.getLength();
				var curveLengths = this.getCurveLengths();
				var i = 0;
	
				// To think about boundaries points.
	
				while ( i < curveLengths.length ) {
	
					if ( curveLengths[ i ] >= d ) {
	
						var diff = curveLengths[ i ] - d;
						var curve = this.curves[ i ];
	
						var segmentLength = curve.getLength();
						var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
	
						return curve.getPointAt( u );
	
					}
	
					i ++;
	
				}
	
				return null;
	
				// loop where sum != 0, sum > d , sum+1 <d
	
			},
	
			// We cannot use the default THREE.Curve getPoint() with getLength() because in
			// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
			// getPoint() depends on getLength
	
			getLength: function () {
	
				var lens = this.getCurveLengths();
				return lens[ lens.length - 1 ];
	
			},
	
			// cacheLengths must be recalculated.
			updateArcLengths: function () {
	
				this.needsUpdate = true;
				this.cacheLengths = null;
				this.getCurveLengths();
	
			},
	
			// Compute lengths and cache them
			// We cannot overwrite getLengths() because UtoT mapping uses it.
	
			getCurveLengths: function () {
	
				// We use cache values if curves and cache array are same length
	
				if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
	
					return this.cacheLengths;
	
				}
	
				// Get length of sub-curve
				// Push sums into cached array
	
				var lengths = [], sums = 0;
	
				for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
					sums += this.curves[ i ].getLength();
					lengths.push( sums );
	
				}
	
				this.cacheLengths = lengths;
	
				return lengths;
	
			},
	
			getSpacedPoints: function ( divisions ) {
	
				if ( divisions === undefined ) divisions = 40;
	
				var points = [];
	
				for ( var i = 0; i <= divisions; i ++ ) {
	
					points.push( this.getPoint( i / divisions ) );
	
				}
	
				if ( this.autoClose ) {
	
					points.push( points[ 0 ] );
	
				}
	
				return points;
	
			},
	
			getPoints: function ( divisions ) {
	
				divisions = divisions || 12;
	
				var points = [], last;
	
				for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {
	
					var curve = curves[ i ];
					var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
						: (curve && curve.isLineCurve) ? 1
						: (curve && curve.isSplineCurve) ? divisions * curve.points.length
						: divisions;
	
					var pts = curve.getPoints( resolution );
	
					for ( var j = 0; j < pts.length; j++ ) {
	
						var point = pts[ j ];
	
						if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates
	
						points.push( point );
						last = point;
	
					}
	
				}
	
				if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {
	
					points.push( points[ 0 ] );
	
				}
	
				return points;
	
			},
	
			/**************************************************************
			 *	Create Geometries Helpers
			 **************************************************************/
	
			/// Generate geometry from path points (for Line or Points objects)
	
			createPointsGeometry: function ( divisions ) {
	
				var pts = this.getPoints( divisions );
				return this.createGeometry( pts );
	
			},
	
			// Generate geometry from equidistant sampling along the path
	
			createSpacedPointsGeometry: function ( divisions ) {
	
				var pts = this.getSpacedPoints( divisions );
				return this.createGeometry( pts );
	
			},
	
			createGeometry: function ( points ) {
	
				var geometry = new Geometry();
	
				for ( var i = 0, l = points.length; i < l; i ++ ) {
	
					var point = points[ i ];
					geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
	
				}
	
				return geometry;
	
			}
	
		} );
	
		function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
			Curve.call( this );
	
			this.aX = aX;
			this.aY = aY;
	
			this.xRadius = xRadius;
			this.yRadius = yRadius;
	
			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;
	
			this.aClockwise = aClockwise;
	
			this.aRotation = aRotation || 0;
	
		}
	
		EllipseCurve.prototype = Object.create( Curve.prototype );
		EllipseCurve.prototype.constructor = EllipseCurve;
	
		EllipseCurve.prototype.isEllipseCurve = true;
	
		EllipseCurve.prototype.getPoint = function ( t ) {
	
			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;
	
			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;
	
			if ( deltaAngle < Number.EPSILON ) {
	
				if ( samePoints ) {
	
					deltaAngle = 0;
	
				} else {
	
					deltaAngle = twoPi;
	
				}
	
			}
	
			if ( this.aClockwise === true && ! samePoints ) {
	
				if ( deltaAngle === twoPi ) {
	
					deltaAngle = - twoPi;
	
				} else {
	
					deltaAngle = deltaAngle - twoPi;
	
				}
	
			}
	
			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos( angle );
			var y = this.aY + this.yRadius * Math.sin( angle );
	
			if ( this.aRotation !== 0 ) {
	
				var cos = Math.cos( this.aRotation );
				var sin = Math.sin( this.aRotation );
	
				var tx = x - this.aX;
				var ty = y - this.aY;
	
				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
	
			}
	
			return new Vector2( x, y );
	
		};
	
		function SplineCurve( points /* array of Vector2 */ ) {
	
			Curve.call( this );
	
			this.points = ( points === undefined ) ? [] : points;
	
		}
	
		SplineCurve.prototype = Object.create( Curve.prototype );
		SplineCurve.prototype.constructor = SplineCurve;
	
		SplineCurve.prototype.isSplineCurve = true;
	
		SplineCurve.prototype.getPoint = function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 1 ) * t;
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
			return new Vector2(
				CatmullRom( weight, point0.x, point1.x, point2.x, point3.x ),
				CatmullRom( weight, point0.y, point1.y, point2.y, point3.y )
			);
	
		};
	
		function CubicBezierCurve( v0, v1, v2, v3 ) {
	
			Curve.call( this );
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		}
	
		CubicBezierCurve.prototype = Object.create( Curve.prototype );
		CubicBezierCurve.prototype.constructor = CubicBezierCurve;
	
		CubicBezierCurve.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	
			return new Vector2(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
			);
	
		};
	
		function QuadraticBezierCurve( v0, v1, v2 ) {
	
			Curve.call( this );
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
	
		QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	
			return new Vector2(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y )
			);
	
		};
	
		var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {
	
			fromPoints: function ( vectors ) {
	
				this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
				for ( var i = 1, l = vectors.length; i < l; i ++ ) {
	
					this.lineTo( vectors[ i ].x, vectors[ i ].y );
	
				}
	
			},
	
			moveTo: function ( x, y ) {
	
				this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?
	
			},
	
			lineTo: function ( x, y ) {
	
				var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
				this.curves.push( curve );
	
				this.currentPoint.set( x, y );
	
			},
	
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
				var curve = new QuadraticBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCPx, aCPy ),
					new Vector2( aX, aY )
				);
	
				this.curves.push( curve );
	
				this.currentPoint.set( aX, aY );
	
			},
	
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
				var curve = new CubicBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCP1x, aCP1y ),
					new Vector2( aCP2x, aCP2y ),
					new Vector2( aX, aY )
				);
	
				this.curves.push( curve );
	
				this.currentPoint.set( aX, aY );
	
			},
	
			splineThru: function ( pts /*Array of Vector*/ ) {
	
				var npts = [ this.currentPoint.clone() ].concat( pts );
	
				var curve = new SplineCurve( npts );
				this.curves.push( curve );
	
				this.currentPoint.copy( pts[ pts.length - 1 ] );
	
			},
	
			arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;
	
				this.absarc( aX + x0, aY + y0, aRadius,
					aStartAngle, aEndAngle, aClockwise );
	
			},
	
			absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
				this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
			},
	
			ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;
	
				this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
			},
	
			absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
				var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
				if ( this.curves.length > 0 ) {
	
					// if a previous curve is present, attempt to join
					var firstPoint = curve.getPoint( 0 );
	
					if ( ! firstPoint.equals( this.currentPoint ) ) {
	
						this.lineTo( firstPoint.x, firstPoint.y );
	
					}
	
				}
	
				this.curves.push( curve );
	
				var lastPoint = curve.getPoint( 1 );
				this.currentPoint.copy( lastPoint );
	
			}
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Creates free form 2d path using series of points, lines or curves.
		 **/
	
		function Path( points ) {
	
			CurvePath.call( this );
			this.currentPoint = new Vector2();
	
			if ( points ) {
	
				this.fromPoints( points );
	
			}
	
		}
	
		Path.prototype = PathPrototype;
		PathPrototype.constructor = Path;
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Defines a 2d shape plane using paths.
		 **/
	
		// STEP 1 Create a path.
		// STEP 2 Turn path into shape.
		// STEP 3 ExtrudeGeometry takes in Shape/Shapes
		// STEP 3a - Extract points from each shape, turn to vertices
		// STEP 3b - Triangulate each shape, add faces.
	
		function Shape() {
	
			Path.apply( this, arguments );
	
			this.holes = [];
	
		}
	
		Shape.prototype = Object.assign( Object.create( PathPrototype ), {
	
			constructor: Shape,
	
			getPointsHoles: function ( divisions ) {
	
				var holesPts = [];
	
				for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
					holesPts[ i ] = this.holes[ i ].getPoints( divisions );
	
				}
	
				return holesPts;
	
			},
	
			// Get points of shape and holes (keypoints based on segments parameter)
	
			extractAllPoints: function ( divisions ) {
	
				return {
	
					shape: this.getPoints( divisions ),
					holes: this.getPointsHoles( divisions )
	
				};
	
			},
	
			extractPoints: function ( divisions ) {
	
				return this.extractAllPoints( divisions );
	
			}
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
		 **/
	
		function ShapePath() {
	
			this.subPaths = [];
			this.currentPath = null;
	
		}
	
		Object.assign( ShapePath.prototype, {
	
			moveTo: function ( x, y ) {
	
				this.currentPath = new Path();
				this.subPaths.push( this.currentPath );
				this.currentPath.moveTo( x, y );
	
			},
	
			lineTo: function ( x, y ) {
	
				this.currentPath.lineTo( x, y );
	
			},
	
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
				this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
	
			},
	
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
				this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
	
			},
	
			splineThru: function ( pts ) {
	
				this.currentPath.splineThru( pts );
	
			},
	
			toShapes: function ( isCCW, noHoles ) {
	
				function toShapesNoHoles( inSubpaths ) {
	
					var shapes = [];
	
					for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
	
						var tmpPath = inSubpaths[ i ];
	
						var tmpShape = new Shape();
						tmpShape.curves = tmpPath.curves;
	
						shapes.push( tmpShape );
	
					}
	
					return shapes;
	
				}
	
				function isPointInsidePolygon( inPt, inPolygon ) {
	
					var polyLen = inPolygon.length;
	
					// inPt on polygon contour => immediate success    or
					// toggling of inside/outside at every single! intersection point of an edge
					//  with the horizontal line through inPt, left of inPt
					//  not counting lowerY endpoints of edges and whole edges on that line
					var inside = false;
					for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
	
						var edgeLowPt  = inPolygon[ p ];
						var edgeHighPt = inPolygon[ q ];
	
						var edgeDx = edgeHighPt.x - edgeLowPt.x;
						var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
						if ( Math.abs( edgeDy ) > Number.EPSILON ) {
	
							// not parallel
							if ( edgeDy < 0 ) {
	
								edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
								edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
	
							}
							if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
							if ( inPt.y === edgeLowPt.y ) {
	
								if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
								// continue;				// no intersection or edgeLowPt => doesn't count !!!
	
							} else {
	
								var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
								if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
								if ( perpEdge < 0 ) 				continue;
								inside = ! inside;		// true intersection left of inPt
	
							}
	
						} else {
	
							// parallel or collinear
							if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
							// edge lies on the same horizontal line as inPt
							if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
								 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
							// continue;
	
						}
	
					}
	
					return	inside;
	
				}
	
				var isClockWise = ShapeUtils.isClockWise;
	
				var subPaths = this.subPaths;
				if ( subPaths.length === 0 ) return [];
	
				if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
				var solid, tmpPath, tmpShape, shapes = [];
	
				if ( subPaths.length === 1 ) {
	
					tmpPath = subPaths[ 0 ];
					tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push( tmpShape );
					return shapes;
	
				}
	
				var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
				holesFirst = isCCW ? ! holesFirst : holesFirst;
	
				// console.log("Holes first", holesFirst);
	
				var betterShapeHoles = [];
				var newShapes = [];
				var newShapeHoles = [];
				var mainIdx = 0;
				var tmpPoints;
	
				newShapes[ mainIdx ] = undefined;
				newShapeHoles[ mainIdx ] = [];
	
				for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
	
					tmpPath = subPaths[ i ];
					tmpPoints = tmpPath.getPoints();
					solid = isClockWise( tmpPoints );
					solid = isCCW ? ! solid : solid;
	
					if ( solid ) {
	
						if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
	
						newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
						newShapes[ mainIdx ].s.curves = tmpPath.curves;
	
						if ( holesFirst )	mainIdx ++;
						newShapeHoles[ mainIdx ] = [];
	
						//console.log('cw', i);
	
					} else {
	
						newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
	
						//console.log('ccw', i);
	
					}
	
				}
	
				// only Holes? -> probably all Shapes with wrong orientation
				if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
	
	
				if ( newShapes.length > 1 ) {
	
					var ambiguous = false;
					var toChange = [];
	
					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
						betterShapeHoles[ sIdx ] = [];
	
					}
	
					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
						var sho = newShapeHoles[ sIdx ];
	
						for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
	
							var ho = sho[ hIdx ];
							var hole_unassigned = true;
	
							for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
	
								if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
	
									if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
									if ( hole_unassigned ) {
	
										hole_unassigned = false;
										betterShapeHoles[ s2Idx ].push( ho );
	
									} else {
	
										ambiguous = true;
	
									}
	
								}
	
							}
							if ( hole_unassigned ) {
	
								betterShapeHoles[ sIdx ].push( ho );
	
							}
	
						}
	
					}
					// console.log("ambiguous: ", ambiguous);
					if ( toChange.length > 0 ) {
	
						// console.log("to change: ", toChange);
						if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
	
					}
	
				}
	
				var tmpHoles;
	
				for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
	
					tmpShape = newShapes[ i ].s;
					shapes.push( tmpShape );
					tmpHoles = newShapeHoles[ i ];
	
					for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
	
						tmpShape.holes.push( tmpHoles[ j ].h );
	
					}
	
				}
	
				//console.log("shape", shapes);
	
				return shapes;
	
			}
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Font( data ) {
	
			this.data = data;
	
		}
	
		Object.assign( Font.prototype, {
	
			isFont: true,
	
			generateShapes: function ( text, size, divisions ) {
	
				function createPaths( text ) {
	
					var chars = String( text ).split( '' );
					var scale = size / data.resolution;
					var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;
	
					var offsetX = 0, offsetY = 0;
	
					var paths = [];
	
					for ( var i = 0; i < chars.length; i ++ ) {
	
						var char = chars[ i ];
	
						if ( char === '\n' ) {
	
							offsetX = 0;
							offsetY -= line_height;
	
						} else {
	
							var ret = createPath( char, scale, offsetX, offsetY );
							offsetX += ret.offsetX;
							paths.push( ret.path );
	
						}
	
					}
	
					return paths;
	
				}
	
				function createPath( c, scale, offsetX, offsetY ) {
	
					var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];
	
					if ( ! glyph ) return;
	
					var path = new ShapePath();
	
					var pts = [];
					var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
	
					if ( glyph.o ) {
	
						var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
	
						for ( var i = 0, l = outline.length; i < l; ) {
	
							var action = outline[ i ++ ];
	
							switch ( action ) {
	
								case 'm': // moveTo
	
									x = outline[ i ++ ] * scale + offsetX;
									y = outline[ i ++ ] * scale + offsetY;
	
									path.moveTo( x, y );
	
									break;
	
								case 'l': // lineTo
	
									x = outline[ i ++ ] * scale + offsetX;
									y = outline[ i ++ ] * scale + offsetY;
	
									path.lineTo( x, y );
	
									break;
	
								case 'q': // quadraticCurveTo
	
									cpx  = outline[ i ++ ] * scale + offsetX;
									cpy  = outline[ i ++ ] * scale + offsetY;
									cpx1 = outline[ i ++ ] * scale + offsetX;
									cpy1 = outline[ i ++ ] * scale + offsetY;
	
									path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
	
									laste = pts[ pts.length - 1 ];
	
									if ( laste ) {
	
										cpx0 = laste.x;
										cpy0 = laste.y;
	
										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
											var t = i2 / divisions;
											QuadraticBezier( t, cpx0, cpx1, cpx );
											QuadraticBezier( t, cpy0, cpy1, cpy );
	
										}
	
									}
	
									break;
	
								case 'b': // bezierCurveTo
	
									cpx  = outline[ i ++ ] * scale + offsetX;
									cpy  = outline[ i ++ ] * scale + offsetY;
									cpx1 = outline[ i ++ ] * scale + offsetX;
									cpy1 = outline[ i ++ ] * scale + offsetY;
									cpx2 = outline[ i ++ ] * scale + offsetX;
									cpy2 = outline[ i ++ ] * scale + offsetY;
	
									path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
	
									laste = pts[ pts.length - 1 ];
	
									if ( laste ) {
	
										cpx0 = laste.x;
										cpy0 = laste.y;
	
										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
											var t = i2 / divisions;
											CubicBezier( t, cpx0, cpx1, cpx2, cpx );
											CubicBezier( t, cpy0, cpy1, cpy2, cpy );
	
										}
	
									}
	
									break;
	
							}
	
						}
	
					}
	
					return { offsetX: glyph.ha * scale, path: path };
	
				}
	
				//
	
				if ( size === undefined ) size = 100;
				if ( divisions === undefined ) divisions = 4;
	
				var data = this.data;
	
				var paths = createPaths( text );
				var shapes = [];
	
				for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
					Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
				}
	
				return shapes;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function FontLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( FontLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new FileLoader( this.manager );
				loader.load( url, function ( text ) {
	
					var json;
	
					try {
	
						json = JSON.parse( text );
	
					} catch ( e ) {
	
						console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
						json = JSON.parse( text.substring( 65, text.length - 2 ) );
	
					}
	
					var font = scope.parse( json );
	
					if ( onLoad ) onLoad( font );
	
				}, onProgress, onError );
	
			},
	
			parse: function ( json ) {
	
				return new Font( json );
	
			}
	
		} );
	
		var context;
	
		var AudioContext = {
	
			getContext: function () {
	
				if ( context === undefined ) {
	
					context = new ( window.AudioContext || window.webkitAudioContext )();
	
				}
	
				return context;
	
			},
	
			setContext: function ( value ) {
	
				context = value;
	
			}
	
		};
	
		/**
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */
	
		function AudioLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( AudioLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
				loader.load( url, function ( buffer ) {
	
					var context = AudioContext.getContext();
	
					context.decodeAudioData( buffer, function ( audioBuffer ) {
	
						onLoad( audioBuffer );
	
					} );
	
				}, onProgress, onError );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function StereoCamera() {
	
			this.type = 'StereoCamera';
	
			this.aspect = 1;
	
			this.eyeSep = 0.064;
	
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;
	
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;
	
		}
	
		Object.assign( StereoCamera.prototype, {
	
			update: ( function () {
	
				var instance, focus, fov, aspect, near, far, zoom, eyeSep;
	
				var eyeRight = new Matrix4();
				var eyeLeft = new Matrix4();
	
				return function update( camera ) {
	
					var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
														aspect !== camera.aspect * this.aspect || near !== camera.near ||
														far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
	
					if ( needsUpdate ) {
	
						instance = this;
						focus = camera.focus;
						fov = camera.fov;
						aspect = camera.aspect * this.aspect;
						near = camera.near;
						far = camera.far;
						zoom = camera.zoom;
	
						// Off-axis stereoscopic effect based on
						// http://paulbourke.net/stereographics/stereorender/
	
						var projectionMatrix = camera.projectionMatrix.clone();
						eyeSep = this.eyeSep / 2;
						var eyeSepOnProjection = eyeSep * near / focus;
						var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
						var xmin, xmax;
	
						// translate xOffset
	
						eyeLeft.elements[ 12 ] = - eyeSep;
						eyeRight.elements[ 12 ] = eyeSep;
	
						// for left eye
	
						xmin = - ymax * aspect + eyeSepOnProjection;
						xmax = ymax * aspect + eyeSepOnProjection;
	
						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
						this.cameraL.projectionMatrix.copy( projectionMatrix );
	
						// for right eye
	
						xmin = - ymax * aspect - eyeSepOnProjection;
						xmax = ymax * aspect - eyeSepOnProjection;
	
						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
						this.cameraR.projectionMatrix.copy( projectionMatrix );
	
					}
	
					this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
					this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
	
				};
	
			} )()
	
		} );
	
		/**
		 * Camera for rendering cube maps
		 *	- renders scene into axis-aligned cube
		 *
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function CubeCamera( near, far, cubeResolution ) {
	
			Object3D.call( this );
	
			this.type = 'CubeCamera';
	
			var fov = 90, aspect = 1;
	
			var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );
	
			var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );
	
			var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );
	
			var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );
	
			var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );
	
			var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );
	
			var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
	
			this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
			this.renderTarget.texture.name = "CubeCamera";
	
			this.updateCubeMap = function ( renderer, scene ) {
	
				if ( this.parent === null ) this.updateMatrixWorld();
	
				var renderTarget = this.renderTarget;
				var generateMipmaps = renderTarget.texture.generateMipmaps;
	
				renderTarget.texture.generateMipmaps = false;
	
				renderTarget.activeCubeFace = 0;
				renderer.render( scene, cameraPX, renderTarget );
	
				renderTarget.activeCubeFace = 1;
				renderer.render( scene, cameraNX, renderTarget );
	
				renderTarget.activeCubeFace = 2;
				renderer.render( scene, cameraPY, renderTarget );
	
				renderTarget.activeCubeFace = 3;
				renderer.render( scene, cameraNY, renderTarget );
	
				renderTarget.activeCubeFace = 4;
				renderer.render( scene, cameraPZ, renderTarget );
	
				renderTarget.texture.generateMipmaps = generateMipmaps;
	
				renderTarget.activeCubeFace = 5;
				renderer.render( scene, cameraNZ, renderTarget );
	
				renderer.setRenderTarget( null );
	
			};
	
		}
	
		CubeCamera.prototype = Object.create( Object3D.prototype );
		CubeCamera.prototype.constructor = CubeCamera;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AudioListener() {
	
			Object3D.call( this );
	
			this.type = 'AudioListener';
	
			this.context = AudioContext.getContext();
	
			this.gain = this.context.createGain();
			this.gain.connect( this.context.destination );
	
			this.filter = null;
	
		}
	
		AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: AudioListener,
	
			getInput: function () {
	
				return this.gain;
	
			},
	
			removeFilter: function ( ) {
	
				if ( this.filter !== null ) {
	
					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
					this.gain.connect( this.context.destination );
					this.filter = null;
	
				}
	
			},
	
			getFilter: function () {
	
				return this.filter;
	
			},
	
			setFilter: function ( value ) {
	
				if ( this.filter !== null ) {
	
					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
	
				} else {
	
					this.gain.disconnect( this.context.destination );
	
				}
	
				this.filter = value;
				this.gain.connect( this.filter );
				this.filter.connect( this.context.destination );
	
			},
	
			getMasterVolume: function () {
	
				return this.gain.gain.value;
	
			},
	
			setMasterVolume: function ( value ) {
	
				this.gain.gain.value = value;
	
			},
	
			updateMatrixWorld: ( function () {
	
				var position = new Vector3();
				var quaternion = new Quaternion();
				var scale = new Vector3();
	
				var orientation = new Vector3();
	
				return function updateMatrixWorld( force ) {
	
					Object3D.prototype.updateMatrixWorld.call( this, force );
	
					var listener = this.context.listener;
					var up = this.up;
	
					this.matrixWorld.decompose( position, quaternion, scale );
	
					orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
					if ( listener.positionX ) {
	
						listener.positionX.setValueAtTime( position.x, this.context.currentTime );
						listener.positionY.setValueAtTime( position.y, this.context.currentTime );
						listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
						listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
						listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
						listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
						listener.upX.setValueAtTime( up.x, this.context.currentTime );
						listener.upY.setValueAtTime( up.y, this.context.currentTime );
						listener.upZ.setValueAtTime( up.z, this.context.currentTime );
	
					} else {
	
						listener.setPosition( position.x, position.y, position.z );
						listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	
					}
	
				};
	
			} )()
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */
	
		function Audio( listener ) {
	
			Object3D.call( this );
	
			this.type = 'Audio';
	
			this.context = listener.context;
	
			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );
	
			this.autoplay = false;
	
			this.buffer = null;
			this.loop = false;
			this.startTime = 0;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.sourceType = 'empty';
	
			this.filters = [];
	
		}
	
		Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Audio,
	
			getOutput: function () {
	
				return this.gain;
	
			},
	
			setNodeSource: function ( audioNode ) {
	
				this.hasPlaybackControl = false;
				this.sourceType = 'audioNode';
				this.source = audioNode;
				this.connect();
	
				return this;
	
			},
	
			setBuffer: function ( audioBuffer ) {
	
				this.buffer = audioBuffer;
				this.sourceType = 'buffer';
	
				if ( this.autoplay ) this.play();
	
				return this;
	
			},
	
			play: function () {
	
				if ( this.isPlaying === true ) {
	
					console.warn( 'THREE.Audio: Audio is already playing.' );
					return;
	
				}
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				var source = this.context.createBufferSource();
	
				source.buffer = this.buffer;
				source.loop = this.loop;
				source.onended = this.onEnded.bind( this );
				source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
				source.start( 0, this.startTime );
	
				this.isPlaying = true;
	
				this.source = source;
	
				return this.connect();
	
			},
	
			pause: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.source.stop();
				this.startTime = this.context.currentTime;
				this.isPlaying = false;
	
				return this;
	
			},
	
			stop: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.source.stop();
				this.startTime = 0;
				this.isPlaying = false;
	
				return this;
	
			},
	
			connect: function () {
	
				if ( this.filters.length > 0 ) {
	
					this.source.connect( this.filters[ 0 ] );
	
					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
						this.filters[ i - 1 ].connect( this.filters[ i ] );
	
					}
	
					this.filters[ this.filters.length - 1 ].connect( this.getOutput() );
	
				} else {
	
					this.source.connect( this.getOutput() );
	
				}
	
				return this;
	
			},
	
			disconnect: function () {
	
				if ( this.filters.length > 0 ) {
	
					this.source.disconnect( this.filters[ 0 ] );
	
					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
						this.filters[ i - 1 ].disconnect( this.filters[ i ] );
	
					}
	
					this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );
	
				} else {
	
					this.source.disconnect( this.getOutput() );
	
				}
	
				return this;
	
			},
	
			getFilters: function () {
	
				return this.filters;
	
			},
	
			setFilters: function ( value ) {
	
				if ( ! value ) value = [];
	
				if ( this.isPlaying === true ) {
	
					this.disconnect();
					this.filters = value;
					this.connect();
	
				} else {
	
					this.filters = value;
	
				}
	
				return this;
	
			},
	
			getFilter: function () {
	
				return this.getFilters()[ 0 ];
	
			},
	
			setFilter: function ( filter ) {
	
				return this.setFilters( filter ? [ filter ] : [] );
	
			},
	
			setPlaybackRate: function ( value ) {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.playbackRate = value;
	
				if ( this.isPlaying === true ) {
	
					this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );
	
				}
	
				return this;
	
			},
	
			getPlaybackRate: function () {
	
				return this.playbackRate;
	
			},
	
			onEnded: function () {
	
				this.isPlaying = false;
	
			},
	
			getLoop: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return false;
	
				}
	
				return this.loop;
	
			},
	
			setLoop: function ( value ) {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.loop = value;
	
				if ( this.isPlaying === true ) {
	
					this.source.loop = this.loop;
	
				}
	
				return this;
	
			},
	
			getVolume: function () {
	
				return this.gain.gain.value;
	
			},
			
			setVolume: function ( value ) {
	
				this.gain.gain.value = value;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function PositionalAudio( listener ) {
	
			Audio.call( this, listener );
	
			this.panner = this.context.createPanner();
			this.panner.connect( this.gain );
	
		}
	
		PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {
	
			constructor: PositionalAudio,
	
			getOutput: function () {
	
				return this.panner;
	
			},
	
			getRefDistance: function () {
	
				return this.panner.refDistance;
	
			},
	
			setRefDistance: function ( value ) {
	
				this.panner.refDistance = value;
	
			},
	
			getRolloffFactor: function () {
	
				return this.panner.rolloffFactor;
	
			},
	
			setRolloffFactor: function ( value ) {
	
				this.panner.rolloffFactor = value;
	
			},
	
			getDistanceModel: function () {
	
				return this.panner.distanceModel;
	
			},
	
			setDistanceModel: function ( value ) {
	
				this.panner.distanceModel = value;
	
			},
	
			getMaxDistance: function () {
	
				return this.panner.maxDistance;
	
			},
	
			setMaxDistance: function ( value ) {
	
				this.panner.maxDistance = value;
	
			},
	
			updateMatrixWorld: ( function () {
	
				var position = new Vector3();
	
				return function updateMatrixWorld( force ) {
	
					Object3D.prototype.updateMatrixWorld.call( this, force );
	
					position.setFromMatrixPosition( this.matrixWorld );
	
					this.panner.setPosition( position.x, position.y, position.z );
	
				};
	
			} )()
	
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AudioAnalyser( audio, fftSize ) {
	
			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	
			this.data = new Uint8Array( this.analyser.frequencyBinCount );
	
			audio.getOutput().connect( this.analyser );
	
		}
	
		Object.assign( AudioAnalyser.prototype, {
	
			getFrequencyData: function () {
	
				this.analyser.getByteFrequencyData( this.data );
	
				return this.data;
	
			},
	
			getAverageFrequency: function () {
	
				var value = 0, data = this.getFrequencyData();
	
				for ( var i = 0; i < data.length; i ++ ) {
	
					value += data[ i ];
	
				}
	
				return value / data.length;
	
			}
	
		} );
	
		/**
		 *
		 * Buffered scene graph property that allows weighted accumulation.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function PropertyMixer( binding, typeName, valueSize ) {
	
			this.binding = binding;
			this.valueSize = valueSize;
	
			var bufferType = Float64Array,
				mixFunction;
	
			switch ( typeName ) {
	
				case 'quaternion':
					mixFunction = this._slerp;
					break;
	
				case 'string':
				case 'bool':
					bufferType = Array;
					mixFunction = this._select;
					break;
	
				default:
					mixFunction = this._lerp;
	
			}
	
			this.buffer = new bufferType( valueSize * 4 );
			// layout: [ incoming | accu0 | accu1 | orig ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
	
			this._mixBufferRegion = mixFunction;
	
			this.cumulativeWeight = 0;
	
			this.useCount = 0;
			this.referenceCount = 0;
	
		}
	
		Object.assign( PropertyMixer.prototype, {
	
			// accumulate data in the 'incoming' region into 'accu<i>'
			accumulate: function ( accuIndex, weight ) {
	
				// note: happily accumulating nothing when weight = 0, the caller knows
				// the weight and shouldn't have made the call in the first place
	
				var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride,
	
					currentWeight = this.cumulativeWeight;
	
				if ( currentWeight === 0 ) {
	
					// accuN := incoming * weight
	
					for ( var i = 0; i !== stride; ++ i ) {
	
						buffer[ offset + i ] = buffer[ i ];
	
					}
	
					currentWeight = weight;
	
				} else {
	
					// accuN := accuN + incoming * weight
	
					currentWeight += weight;
					var mix = weight / currentWeight;
					this._mixBufferRegion( buffer, offset, 0, mix, stride );
	
				}
	
				this.cumulativeWeight = currentWeight;
	
			},
	
			// apply the state of 'accu<i>' to the binding when accus differ
			apply: function ( accuIndex ) {
	
				var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,
	
					weight = this.cumulativeWeight,
	
					binding = this.binding;
	
				this.cumulativeWeight = 0;
	
				if ( weight < 1 ) {
	
					// accuN := accuN + original * ( 1 - cumulativeWeight )
	
					var originalValueOffset = stride * 3;
	
					this._mixBufferRegion(
						buffer, offset, originalValueOffset, 1 - weight, stride );
	
				}
	
				for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
	
					if ( buffer[ i ] !== buffer[ i + stride ] ) {
	
						// value has changed -> update scene graph
	
						binding.setValue( buffer, offset );
						break;
	
					}
	
				}
	
			},
	
			// remember the state of the bound property and copy it to both accus
			saveOriginalState: function () {
	
				var binding = this.binding;
	
				var buffer = this.buffer,
					stride = this.valueSize,
	
					originalValueOffset = stride * 3;
	
				binding.getValue( buffer, originalValueOffset );
	
				// accu[0..1] := orig -- initially detect changes against the original
				for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
	
					buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
	
				}
	
				this.cumulativeWeight = 0;
	
			},
	
			// apply the state previously taken via 'saveOriginalState' to the binding
			restoreOriginalState: function () {
	
				var originalValueOffset = this.valueSize * 3;
				this.binding.setValue( this.buffer, originalValueOffset );
	
			},
	
	
			// mix functions
	
			_select: function ( buffer, dstOffset, srcOffset, t, stride ) {
	
				if ( t >= 0.5 ) {
	
					for ( var i = 0; i !== stride; ++ i ) {
	
						buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
	
					}
	
				}
	
			},
	
			_slerp: function ( buffer, dstOffset, srcOffset, t ) {
	
				Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );
	
			},
	
			_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {
	
				var s = 1 - t;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					var j = dstOffset + i;
	
					buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
	
				}
	
			}
	
		} );
	
		/**
		 *
		 * A reference to a real property in the scene graph.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function Composite( targetGroup, path, optionalParsedPath ) {
	
			var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );
	
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );
	
		}
	
		Object.assign( Composite.prototype, {
	
			getValue: function ( array, offset ) {
	
				this.bind(); // bind all binding
	
				var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[ firstValidIndex ];
	
				// and only call .getValue on the first
				if ( binding !== undefined ) binding.getValue( array, offset );
	
			},
	
			setValue: function ( array, offset ) {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						  n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].setValue( array, offset );
	
				}
	
			},
	
			bind: function () {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						  n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].bind();
	
				}
	
			},
	
			unbind: function () {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						  n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].unbind();
	
				}
	
			}
	
		} );
	
	
		function PropertyBinding( rootNode, path, parsedPath ) {
	
			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );
	
			this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;
	
			this.rootNode = rootNode;
	
		}
	
		Object.assign( PropertyBinding, {
	
			Composite: Composite,
	
			create: function ( root, path, parsedPath ) {
	
				if ( ! ( root && root.isAnimationObjectGroup ) ) {
	
					return new PropertyBinding( root, path, parsedPath );
	
				} else {
	
					return new PropertyBinding.Composite( root, path, parsedPath );
	
				}
	
			},
	
			/**
			 * Replaces spaces with underscores and removes unsupported characters from
			 * node names, to ensure compatibility with parseTrackName().
			 *
			 * @param  {string} name Node name to be sanitized.
			 * @return {string}
			 */
			sanitizeNodeName: function ( name ) {
	
				return name.replace( /\s/g, '_' ).replace( /[^\w-]/g, '' );
	
			},
	
			parseTrackName: function () {
	
				// Parent directories, delimited by '/' or ':'. Currently unused, but must
				// be matched to parse the rest of the track name.
				var directoryRe = /((?:[\w-]+[\/:])*)/;
	
				// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
				var nodeRe = /([\w-\.]+)?/;
	
				// Object on target node, and accessor. Name may contain only word
				// characters. Accessor may contain any character except closing bracket.
				var objectRe = /(?:\.([\w-]+)(?:\[(.+)\])?)?/;
	
				// Property and accessor. May contain only word characters. Accessor may
				// contain any non-bracket characters.
				var propertyRe = /\.([\w-]+)(?:\[(.+)\])?/;
	
				var trackRe = new RegExp(''
					+ '^'
					+ directoryRe.source
					+ nodeRe.source
					+ objectRe.source
					+ propertyRe.source
					+ '$'
				);
	
				var supportedObjectNames = [ 'material', 'materials', 'bones' ];
	
				return function ( trackName ) {
	
						var matches = trackRe.exec( trackName );
	
						if ( ! matches ) {
	
							throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );
	
						}
	
						var results = {
							// directoryName: matches[ 1 ], // (tschw) currently unused
							nodeName: matches[ 2 ],
							objectName: matches[ 3 ],
							objectIndex: matches[ 4 ],
							propertyName: matches[ 5 ],     // required
							propertyIndex: matches[ 6 ]
						};
	
						var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );
	
						if ( lastDot !== undefined && lastDot !== -1 ) {
	
							var objectName = results.nodeName.substring( lastDot + 1 );
	
							// Object names must be checked against a whitelist. Otherwise, there
							// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
							// 'bar' could be the objectName, or part of a nodeName (which can
							// include '.' characters).
							if ( supportedObjectNames.indexOf( objectName ) !== -1 ) {
	
								results.nodeName = results.nodeName.substring( 0, lastDot );
								results.objectName = objectName;
	
							}
	
						}
	
						if ( results.propertyName === null || results.propertyName.length === 0 ) {
	
							throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );
	
						}
	
						return results;
	
					};
	
			}(),
	
			findNode: function ( root, nodeName ) {
	
				if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {
	
					return root;
	
				}
	
				// search into skeleton bones.
				if ( root.skeleton ) {
	
					var searchSkeleton = function ( skeleton ) {
	
						for ( var i = 0; i < skeleton.bones.length; i ++ ) {
	
							var bone = skeleton.bones[ i ];
	
							if ( bone.name === nodeName ) {
	
								return bone;
	
							}
	
						}
	
						return null;
	
					};
	
					var bone = searchSkeleton( root.skeleton );
	
					if ( bone ) {
	
						return bone;
	
					}
	
				}
	
				// search into node subtree.
				if ( root.children ) {
	
					var searchNodeSubtree = function ( children ) {
	
						for ( var i = 0; i < children.length; i ++ ) {
	
							var childNode = children[ i ];
	
							if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
	
								return childNode;
	
							}
	
							var result = searchNodeSubtree( childNode.children );
	
							if ( result ) return result;
	
						}
	
						return null;
	
					};
	
					var subTreeNode = searchNodeSubtree( root.children );
	
					if ( subTreeNode ) {
	
						return subTreeNode;
	
					}
	
				}
	
				return null;
	
			}
	
		} );
	
		Object.assign( PropertyBinding.prototype, { // prototype, continued
	
			// these are used to "bind" a nonexistent property
			_getValue_unavailable: function () {},
			_setValue_unavailable: function () {},
	
			BindingType: {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			},
	
			Versioning: {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			},
	
			GetterByBindingType: [
	
				function getValue_direct( buffer, offset ) {
	
					buffer[ offset ] = this.node[ this.propertyName ];
	
				},
	
				function getValue_array( buffer, offset ) {
	
					var source = this.resolvedProperty;
	
					for ( var i = 0, n = source.length; i !== n; ++ i ) {
	
						buffer[ offset ++ ] = source[ i ];
	
					}
	
				},
	
				function getValue_arrayElement( buffer, offset ) {
	
					buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
	
				},
	
				function getValue_toArray( buffer, offset ) {
	
					this.resolvedProperty.toArray( buffer, offset );
	
				}
	
			],
	
			SetterByBindingTypeAndVersioning: [
	
				[
					// Direct
	
					function setValue_direct( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
	
					},
	
					function setValue_direct_setNeedsUpdate( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// EntireArray
	
					function setValue_array( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
					},
	
					function setValue_array_setNeedsUpdate( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// ArrayElement
	
					function setValue_arrayElement( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
	
					},
	
					function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// HasToFromArray
	
					function setValue_fromArray( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
	
					},
	
					function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				]
	
			],
	
			getValue: function getValue_unbound( targetArray, offset ) {
	
				this.bind();
				this.getValue( targetArray, offset );
	
				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.
	
			},
	
			setValue: function getValue_unbound( sourceArray, offset ) {
	
				this.bind();
				this.setValue( sourceArray, offset );
	
			},
	
			// create getter / setter pair for a property in the scene graph
			bind: function () {
	
				var targetObject = this.node,
					parsedPath = this.parsedPath,
	
					objectName = parsedPath.objectName,
					propertyName = parsedPath.propertyName,
					propertyIndex = parsedPath.propertyIndex;
	
				if ( ! targetObject ) {
	
					targetObject = PropertyBinding.findNode(
							this.rootNode, parsedPath.nodeName ) || this.rootNode;
	
					this.node = targetObject;
	
				}
	
				// set fail state so we can just 'return' on error
				this.getValue = this._getValue_unavailable;
				this.setValue = this._setValue_unavailable;
	
				// ensure there is a value node
				if ( ! targetObject ) {
	
					console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
					return;
	
				}
	
				if ( objectName ) {
	
					var objectIndex = parsedPath.objectIndex;
	
					// special cases were we need to reach deeper into the hierarchy to get the face materials....
					switch ( objectName ) {
	
						case 'materials':
	
							if ( ! targetObject.material ) {
	
								console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
								return;
	
							}
	
							if ( ! targetObject.material.materials ) {
	
								console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
								return;
	
							}
	
							targetObject = targetObject.material.materials;
	
							break;
	
						case 'bones':
	
							if ( ! targetObject.skeleton ) {
	
								console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
								return;
	
							}
	
							// potential future optimization: skip this if propertyIndex is already an integer
							// and convert the integer string to a true integer.
	
							targetObject = targetObject.skeleton.bones;
	
							// support resolving morphTarget names into indices.
							for ( var i = 0; i < targetObject.length; i ++ ) {
	
								if ( targetObject[ i ].name === objectIndex ) {
	
									objectIndex = i;
									break;
	
								}
	
							}
	
							break;
	
						default:
	
							if ( targetObject[ objectName ] === undefined ) {
	
								console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
								return;
	
							}
	
							targetObject = targetObject[ objectName ];
	
					}
	
	
					if ( objectIndex !== undefined ) {
	
						if ( targetObject[ objectIndex ] === undefined ) {
	
							console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
							return;
	
						}
	
						targetObject = targetObject[ objectIndex ];
	
					}
	
				}
	
				// resolve property
				var nodeProperty = targetObject[ propertyName ];
	
				if ( nodeProperty === undefined ) {
	
					var nodeName = parsedPath.nodeName;
	
					console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
						'.' + propertyName + ' but it wasn\'t found.', targetObject );
					return;
	
				}
	
				// determine versioning scheme
				var versioning = this.Versioning.None;
	
				if ( targetObject.needsUpdate !== undefined ) { // material
	
					versioning = this.Versioning.NeedsUpdate;
					this.targetObject = targetObject;
	
				} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
	
					versioning = this.Versioning.MatrixWorldNeedsUpdate;
					this.targetObject = targetObject;
	
				}
	
				// determine how the property gets bound
				var bindingType = this.BindingType.Direct;
	
				if ( propertyIndex !== undefined ) {
	
					// access a sub element of the property array (only primitives are supported right now)
	
					if ( propertyName === "morphTargetInfluences" ) {
	
						// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
						// support resolving morphTarget names into indices.
						if ( ! targetObject.geometry ) {
	
							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
							return;
	
						}
	
						if ( targetObject.geometry.isBufferGeometry ) {
	
							if ( ! targetObject.geometry.morphAttributes ) {
	
								console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
								return;
	
							}
	
							for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {
	
								if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {
	
									propertyIndex = i;
									break;
	
								}
	
							}
	
	
						} else {
	
							if ( ! targetObject.geometry.morphTargets ) {
	
								console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
								return;
	
							}
	
							for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
	
								if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {
	
									propertyIndex = i;
									break;
	
								}
	
							}
	
						}
	
					}
	
					bindingType = this.BindingType.ArrayElement;
	
					this.resolvedProperty = nodeProperty;
					this.propertyIndex = propertyIndex;
	
				} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
	
					// must use copy for Object3D.Euler/Quaternion
	
					bindingType = this.BindingType.HasFromToArray;
	
					this.resolvedProperty = nodeProperty;
	
				} else if ( Array.isArray( nodeProperty ) ) {
	
					bindingType = this.BindingType.EntireArray;
	
					this.resolvedProperty = nodeProperty;
	
				} else {
	
					this.propertyName = propertyName;
	
				}
	
				// select getter / setter
				this.getValue = this.GetterByBindingType[ bindingType ];
				this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
	
			},
	
			unbind: function () {
	
				this.node = null;
	
				// back to the prototype version of getValue / setValue
				// note: avoiding to mutate the shape of 'this' via 'delete'
				this.getValue = this._getValue_unbound;
				this.setValue = this._setValue_unbound;
	
			}
	
		} );
	
		//!\ DECLARE ALIAS AFTER assign prototype !
		Object.assign( PropertyBinding.prototype, {
	
			// initial state of these methods that calls 'bind'
			_getValue_unbound: PropertyBinding.prototype.getValue,
			_setValue_unbound: PropertyBinding.prototype.setValue,
	
		} );
	
		/**
		 *
		 * A group of objects that receives a shared animation state.
		 *
		 * Usage:
		 *
		 * 	-	Add objects you would otherwise pass as 'root' to the
		 * 		constructor or the .clipAction method of AnimationMixer.
		 *
		 * 	-	Instead pass this object as 'root'.
		 *
		 * 	-	You can also add and remove objects later when the mixer
		 * 		is running.
		 *
		 * Note:
		 *
		 *  	Objects of this class appear as one object to the mixer,
		 *  	so cache control of the individual objects must be done
		 *  	on the group.
		 *
		 * Limitation:
		 *
		 * 	- 	The animated properties must be compatible among the
		 * 		all objects in the group.
		 *
		 *  -	A single property can either be controlled through a
		 *  	target group or directly, but not both.
		 *
		 * @author tschw
		 */
	
		function AnimationObjectGroup( var_args ) {
	
			this.uuid = _Math.generateUUID();
	
			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );
	
			this.nCachedObjects_ = 0;			// threshold
			// note: read by PropertyBinding.Composite
	
			var indices = {};
			this._indicesByUUID = indices;		// for bookkeeping
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				indices[ arguments[ i ].uuid ] = i;
	
			}
	
			this._paths = [];					// inside: string
			this._parsedPaths = [];				// inside: { we don't care, here }
			this._bindings = []; 				// inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays
	
			var scope = this;
	
			this.stats = {
	
				objects: {
					get total() { return scope._objects.length; },
					get inUse() { return this.total - scope.nCachedObjects_; }
				},
	
				get bindingsPerObject() { return scope._bindings.length; }
	
			};
	
		}
	
		Object.assign( AnimationObjectGroup.prototype, {
	
			isAnimationObjectGroup: true,
	
			add: function( var_args ) {
	
				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ],
						knownObject = undefined;
	
					if ( index === undefined ) {
	
						// unknown object -> add it to the ACTIVE region
	
						index = nObjects ++;
						indicesByUUID[ uuid ] = index;
						objects.push( object );
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							bindings[ j ].push(
									new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] ) );
	
						}
	
					} else if ( index < nCachedObjects ) {
	
						knownObject = objects[ index ];
	
						// move existing object to the ACTIVE region
	
						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ];
	
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;
	
						indicesByUUID[ uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = object;
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								binding = bindingsForPath[ index ];
	
							bindingsForPath[ index ] = lastCached;
	
							if ( binding === undefined ) {
	
								// since we do not bother to create new bindings
								// for objects that are cached, the binding may
								// or may not exist
	
								binding = new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] );
	
							}
	
							bindingsForPath[ firstActiveIndex ] = binding;
	
						}
	
					} else if ( objects[ index ] !== knownObject ) {
	
						console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
								'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );
	
					} // else the object is already where we want it to be
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			remove: function( var_args ) {
	
				var objects = this._objects,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];
	
					if ( index !== undefined && index >= nCachedObjects ) {
	
						// move existing object into the CACHED region
	
						var lastCachedIndex = nCachedObjects ++,
							firstActiveObject = objects[ lastCachedIndex ];
	
						indicesByUUID[ firstActiveObject.uuid ] = index;
						objects[ index ] = firstActiveObject;
	
						indicesByUUID[ uuid ] = lastCachedIndex;
						objects[ lastCachedIndex ] = object;
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								firstActive = bindingsForPath[ lastCachedIndex ],
								binding = bindingsForPath[ index ];
	
							bindingsForPath[ index ] = firstActive;
							bindingsForPath[ lastCachedIndex ] = binding;
	
						}
	
					}
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			// remove & forget
			uncache: function( var_args ) {
	
				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];
	
					if ( index !== undefined ) {
	
						delete indicesByUUID[ uuid ];
	
						if ( index < nCachedObjects ) {
	
							// object is cached, shrink the CACHED region
	
							var firstActiveIndex = -- nCachedObjects,
								lastCachedObject = objects[ firstActiveIndex ],
								lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];
	
							// last cached object takes this object's place
							indicesByUUID[ lastCachedObject.uuid ] = index;
							objects[ index ] = lastCachedObject;
	
							// last object goes to the activated slot and pop
							indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
							objects[ firstActiveIndex ] = lastObject;
							objects.pop();
	
							// accounting is done, now do the same for all bindings
	
							for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
								var bindingsForPath = bindings[ j ],
									lastCached = bindingsForPath[ firstActiveIndex ],
									last = bindingsForPath[ lastIndex ];
	
								bindingsForPath[ index ] = lastCached;
								bindingsForPath[ firstActiveIndex ] = last;
								bindingsForPath.pop();
	
							}
	
						} else {
	
							// object is active, just swap with the last and pop
	
							var lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];
	
							indicesByUUID[ lastObject.uuid ] = index;
							objects[ index ] = lastObject;
							objects.pop();
	
							// accounting is done, now do the same for all bindings
	
							for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
								var bindingsForPath = bindings[ j ];
	
								bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
								bindingsForPath.pop();
	
							}
	
						} // cached or active
	
					} // if object is known
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			// Internal interface used by befriended PropertyBinding.Composite:
	
			subscribe_: function ( path, parsedPath ) {
	
				// returns an array of bindings for the given path that is changed
				// according to the contained objects in the group
	
				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ],
					bindings = this._bindings;
	
				if ( index !== undefined ) return bindings[ index ];
	
				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array( nObjects );
	
				index = bindings.length;
	
				indicesByPath[ path ] = index;
	
				paths.push( path );
				parsedPaths.push( parsedPath );
				bindings.push( bindingsForPath );
	
				for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {
	
					var object = objects[ i ];
					bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );
	
				}
	
				return bindingsForPath;
	
			},
	
			unsubscribe_: function ( path ) {
	
				// tells the group to forget about a property path and no longer
				// update the array previously obtained with 'subscribe_'
	
				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ];
	
				if ( index !== undefined ) {
	
					var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[ lastBindingsIndex ],
						lastBindingsPath = path[ lastBindingsIndex ];
	
					indicesByPath[ lastBindingsPath ] = index;
	
					bindings[ index ] = lastBindings;
					bindings.pop();
	
					parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
					parsedPaths.pop();
	
					paths[ index ] = paths[ lastBindingsIndex ];
					paths.pop();
	
				}
	
			}
	
		} );
	
		/**
		 *
		 * Action provided by AnimationMixer for scheduling clip playback on specific
		 * objects.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 *
		 */
	
		function AnimationAction( mixer, clip, localRoot ) {
	
			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot || null;
	
			var tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );
	
			var interpolantSettings = {
					endingStart: 	ZeroCurvatureEnding,
					endingEnd:		ZeroCurvatureEnding
			};
	
			for ( var i = 0; i !== nTracks; ++ i ) {
	
				var interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;
	
			}
	
			this._interpolantSettings = interpolantSettings;
	
			this._interpolants = interpolants;	// bound by the mixer
	
			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );
	
			this._cacheIndex = null;			// for the memory manager
			this._byClipCacheIndex = null;		// for the memory manager
	
			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
	
			this.loop = LoopRepeat;
			this._loopCount = -1;
	
			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;
	
			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;
	
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
	
			this.weight = 1;
			this._effectiveWeight = 1;
	
			this.repetitions = Infinity; 		// no. of repetitions when looping
	
			this.paused = false;				// true -> zero effective time scale
			this.enabled = true;				// false -> zero effective weight
	
			this.clampWhenFinished 	= false;	// keep feeding the last frame?
	
			this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd		= true;		// clips for start, loop and end
	
		}
	
		Object.assign( AnimationAction.prototype, {
	
			// State & Scheduling
	
			play: function() {
	
				this._mixer._activateAction( this );
	
				return this;
	
			},
	
			stop: function() {
	
				this._mixer._deactivateAction( this );
	
				return this.reset();
	
			},
	
			reset: function() {
	
				this.paused = false;
				this.enabled = true;
	
				this.time = 0;			// restart clip
				this._loopCount = -1;	// forget previous loops
				this._startTime = null;	// forget scheduling
	
				return this.stopFading().stopWarping();
	
			},
	
			isRunning: function() {
	
				return this.enabled && ! this.paused && this.timeScale !== 0 &&
						this._startTime === null && this._mixer._isActiveAction( this );
	
			},
	
			// return true when play has been called
			isScheduled: function() {
	
				return this._mixer._isActiveAction( this );
	
			},
	
			startAt: function( time ) {
	
				this._startTime = time;
	
				return this;
	
			},
	
			setLoop: function( mode, repetitions ) {
	
				this.loop = mode;
				this.repetitions = repetitions;
	
				return this;
	
			},
	
			// Weight
	
			// set the weight stopping any scheduled fading
			// although .enabled = false yields an effective weight of zero, this
			// method does *not* change .enabled, because it would be confusing
			setEffectiveWeight: function( weight ) {
	
				this.weight = weight;
	
				// note: same logic as when updated at runtime
				this._effectiveWeight = this.enabled ? weight : 0;
	
				return this.stopFading();
	
			},
	
			// return the weight considering fading and .enabled
			getEffectiveWeight: function() {
	
				return this._effectiveWeight;
	
			},
	
			fadeIn: function( duration ) {
	
				return this._scheduleFading( duration, 0, 1 );
	
			},
	
			fadeOut: function( duration ) {
	
				return this._scheduleFading( duration, 1, 0 );
	
			},
	
			crossFadeFrom: function( fadeOutAction, duration, warp ) {
	
				fadeOutAction.fadeOut( duration );
				this.fadeIn( duration );
	
				if( warp ) {
	
					var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,
	
						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;
	
					fadeOutAction.warp( 1.0, startEndRatio, duration );
					this.warp( endStartRatio, 1.0, duration );
	
				}
	
				return this;
	
			},
	
			crossFadeTo: function( fadeInAction, duration, warp ) {
	
				return fadeInAction.crossFadeFrom( this, duration, warp );
	
			},
	
			stopFading: function() {
	
				var weightInterpolant = this._weightInterpolant;
	
				if ( weightInterpolant !== null ) {
	
					this._weightInterpolant = null;
					this._mixer._takeBackControlInterpolant( weightInterpolant );
	
				}
	
				return this;
	
			},
	
			// Time Scale Control
	
			// set the time scale stopping any scheduled warping
			// although .paused = true yields an effective time scale of zero, this
			// method does *not* change .paused, because it would be confusing
			setEffectiveTimeScale: function( timeScale ) {
	
				this.timeScale = timeScale;
				this._effectiveTimeScale = this.paused ? 0 :timeScale;
	
				return this.stopWarping();
	
			},
	
			// return the time scale considering warping and .paused
			getEffectiveTimeScale: function() {
	
				return this._effectiveTimeScale;
	
			},
	
			setDuration: function( duration ) {
	
				this.timeScale = this._clip.duration / duration;
	
				return this.stopWarping();
	
			},
	
			syncWith: function( action ) {
	
				this.time = action.time;
				this.timeScale = action.timeScale;
	
				return this.stopWarping();
	
			},
	
			halt: function( duration ) {
	
				return this.warp( this._effectiveTimeScale, 0, duration );
	
			},
	
			warp: function( startTimeScale, endTimeScale, duration ) {
	
				var mixer = this._mixer, now = mixer.time,
					interpolant = this._timeScaleInterpolant,
	
					timeScale = this.timeScale;
	
				if ( interpolant === null ) {
	
					interpolant = mixer._lendControlInterpolant();
					this._timeScaleInterpolant = interpolant;
	
				}
	
				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
	
				times[ 0 ] = now;
				times[ 1 ] = now + duration;
	
				values[ 0 ] = startTimeScale / timeScale;
				values[ 1 ] = endTimeScale / timeScale;
	
				return this;
	
			},
	
			stopWarping: function() {
	
				var timeScaleInterpolant = this._timeScaleInterpolant;
	
				if ( timeScaleInterpolant !== null ) {
	
					this._timeScaleInterpolant = null;
					this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
	
				}
	
				return this;
	
			},
	
			// Object Accessors
	
			getMixer: function() {
	
				return this._mixer;
	
			},
	
			getClip: function() {
	
				return this._clip;
	
			},
	
			getRoot: function() {
	
				return this._localRoot || this._mixer._root;
	
			},
	
			// Interna
	
			_update: function( time, deltaTime, timeDirection, accuIndex ) {
	
				// called by the mixer
	
				if ( ! this.enabled ) {
	
					// call ._updateWeight() to update ._effectiveWeight
	
					this._updateWeight( time );
					return;
	
				}
	
				var startTime = this._startTime;
	
				if ( startTime !== null ) {
	
					// check for scheduled start of action
	
					var timeRunning = ( time - startTime ) * timeDirection;
					if ( timeRunning < 0 || timeDirection === 0 ) {
	
						return; // yet to come / don't decide when delta = 0
	
					}
	
					// start
	
					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;
	
				}
	
				// apply time scale and advance time
	
				deltaTime *= this._updateTimeScale( time );
				var clipTime = this._updateTime( deltaTime );
	
				// note: _updateTime may disable the action resulting in
				// an effective weight of 0
	
				var weight = this._updateWeight( time );
	
				if ( weight > 0 ) {
	
					var interpolants = this._interpolants;
					var propertyMixers = this._propertyBindings;
	
					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
	
						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );
	
					}
	
				}
	
			},
	
			_updateWeight: function( time ) {
	
				var weight = 0;
	
				if ( this.enabled ) {
	
					weight = this.weight;
					var interpolant = this._weightInterpolant;
	
					if ( interpolant !== null ) {
	
						var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
						weight *= interpolantValue;
	
						if ( time > interpolant.parameterPositions[ 1 ] ) {
	
							this.stopFading();
	
							if ( interpolantValue === 0 ) {
	
								// faded out, disable
								this.enabled = false;
	
							}
	
						}
	
					}
	
				}
	
				this._effectiveWeight = weight;
				return weight;
	
			},
	
			_updateTimeScale: function( time ) {
	
				var timeScale = 0;
	
				if ( ! this.paused ) {
	
					timeScale = this.timeScale;
	
					var interpolant = this._timeScaleInterpolant;
	
					if ( interpolant !== null ) {
	
						var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
						timeScale *= interpolantValue;
	
						if ( time > interpolant.parameterPositions[ 1 ] ) {
	
							this.stopWarping();
	
							if ( timeScale === 0 ) {
	
								// motion has halted, pause
								this.paused = true;
	
							} else {
	
								// warp done - apply final time scale
								this.timeScale = timeScale;
	
							}
	
						}
	
					}
	
				}
	
				this._effectiveTimeScale = timeScale;
				return timeScale;
	
			},
	
			_updateTime: function( deltaTime ) {
	
				var time = this.time + deltaTime;
	
				if ( deltaTime === 0 ) return time;
	
				var duration = this._clip.duration,
	
					loop = this.loop,
					loopCount = this._loopCount;
	
				if ( loop === LoopOnce ) {
	
					if ( loopCount === -1 ) {
						// just started
	
						this._loopCount = 0;
						this._setEndings( true, true, false );
	
					}
	
					handle_stop: {
	
						if ( time >= duration ) {
	
							time = duration;
	
						} else if ( time < 0 ) {
	
							time = 0;
	
						} else break handle_stop;
	
						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;
	
						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime < 0 ? -1 : 1
						} );
	
					}
	
				} else { // repetitive Repeat or PingPong
	
					var pingPong = ( loop === LoopPingPong );
	
					if ( loopCount === -1 ) {
						// just started
	
						if ( deltaTime >= 0 ) {
	
							loopCount = 0;
	
							this._setEndings(
									true, this.repetitions === 0, pingPong );
	
						} else {
	
							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1
	
							this._setEndings(
									this.repetitions === 0, true, pingPong );
	
						}
	
					}
	
					if ( time >= duration || time < 0 ) {
						// wrap around
	
						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;
	
						loopCount += Math.abs( loopDelta );
	
						var pending = this.repetitions - loopCount;
	
						if ( pending < 0 ) {
							// have to stop (switch state, clamp time, fire event)
	
							if ( this.clampWhenFinished ) this.paused = true;
							else this.enabled = false;
	
							time = deltaTime > 0 ? duration : 0;
	
							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : -1
							} );
	
						} else {
							// keep running
	
							if ( pending === 0 ) {
								// entering the last round
	
								var atStart = deltaTime < 0;
								this._setEndings( atStart, ! atStart, pingPong );
	
							} else {
	
								this._setEndings( false, false, pingPong );
	
							}
	
							this._loopCount = loopCount;
	
							this._mixer.dispatchEvent( {
								type: 'loop', action: this, loopDelta: loopDelta
							} );
	
						}
	
					}
	
					if ( pingPong && ( loopCount & 1 ) === 1 ) {
						// invert time for the "pong round"
	
						this.time = time;
						return duration - time;
	
					}
	
				}
	
				this.time = time;
				return time;
	
			},
	
			_setEndings: function( atStart, atEnd, pingPong ) {
	
				var settings = this._interpolantSettings;
	
				if ( pingPong ) {
	
					settings.endingStart 	= ZeroSlopeEnding;
					settings.endingEnd		= ZeroSlopeEnding;
	
				} else {
	
					// assuming for LoopOnce atStart == atEnd == true
	
					if ( atStart ) {
	
						settings.endingStart = this.zeroSlopeAtStart ?
								ZeroSlopeEnding : ZeroCurvatureEnding;
	
					} else {
	
						settings.endingStart = WrapAroundEnding;
	
					}
	
					if ( atEnd ) {
	
						settings.endingEnd = this.zeroSlopeAtEnd ?
								ZeroSlopeEnding : ZeroCurvatureEnding;
	
					} else {
	
						settings.endingEnd 	 = WrapAroundEnding;
	
					}
	
				}
	
			},
	
			_scheduleFading: function( duration, weightNow, weightThen ) {
	
				var mixer = this._mixer, now = mixer.time,
					interpolant = this._weightInterpolant;
	
				if ( interpolant === null ) {
	
					interpolant = mixer._lendControlInterpolant();
					this._weightInterpolant = interpolant;
	
				}
	
				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
	
				times[ 0 ] = now; 				values[ 0 ] = weightNow;
				times[ 1 ] = now + duration;	values[ 1 ] = weightThen;
	
				return this;
	
			}
	
		} );
	
		/**
		 *
		 * Player for AnimationClips.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function AnimationMixer( root ) {
	
			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;
	
			this.time = 0;
	
			this.timeScale = 1.0;
	
		}
	
		Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {
	
			_bindAction: function ( action, prototypeAction ) {
	
				var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingsByName = bindingsByRoot[ rootUuid ];
	
				if ( bindingsByName === undefined ) {
	
					bindingsByName = {};
					bindingsByRoot[ rootUuid ] = bindingsByName;
	
				}
	
				for ( var i = 0; i !== nTracks; ++ i ) {
	
					var track = tracks[ i ],
						trackName = track.name,
						binding = bindingsByName[ trackName ];
	
					if ( binding !== undefined ) {
	
						bindings[ i ] = binding;
	
					} else {
	
						binding = bindings[ i ];
	
						if ( binding !== undefined ) {
	
							// existing binding, make sure the cache knows
	
							if ( binding._cacheIndex === null ) {
	
								++ binding.referenceCount;
								this._addInactiveBinding( binding, rootUuid, trackName );
	
							}
	
							continue;
	
						}
	
						var path = prototypeAction && prototypeAction.
								_propertyBindings[ i ].binding.parsedPath;
	
						binding = new PropertyMixer(
							PropertyBinding.create( root, trackName, path ),
							track.ValueTypeName, track.getValueSize() );
	
						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );
	
						bindings[ i ] = binding;
	
					}
	
					interpolants[ i ].resultBuffer = binding.buffer;
	
				}
	
			},
	
			_activateAction: function ( action ) {
	
				if ( ! this._isActiveAction( action ) ) {
	
					if ( action._cacheIndex === null ) {
	
						// this action has been forgotten by the cache, but the user
						// appears to be still using it -> rebind
	
						var rootUuid = ( action._localRoot || this._root ).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[ clipUuid ];
	
						this._bindAction( action,
							actionsForClip && actionsForClip.knownActions[ 0 ] );
	
						this._addInactiveAction( action, clipUuid, rootUuid );
	
					}
	
					var bindings = action._propertyBindings;
	
					// increment reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
						var binding = bindings[ i ];
	
						if ( binding.useCount ++ === 0 ) {
	
							this._lendBinding( binding );
							binding.saveOriginalState();
	
						}
	
					}
	
					this._lendAction( action );
	
				}
	
			},
	
			_deactivateAction: function ( action ) {
	
				if ( this._isActiveAction( action ) ) {
	
					var bindings = action._propertyBindings;
	
					// decrement reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
						var binding = bindings[ i ];
	
						if ( -- binding.useCount === 0 ) {
	
							binding.restoreOriginalState();
							this._takeBackBinding( binding );
	
						}
	
					}
	
					this._takeBackAction( action );
	
				}
	
			},
	
			// Memory manager
	
			_initMemoryManager: function () {
	
				this._actions = []; // 'nActiveActions' followed by inactive ones
				this._nActiveActions = 0;
	
				this._actionsByClip = {};
				// inside:
				// {
				// 		knownActions: Array< AnimationAction >	- used as prototypes
				// 		actionByRoot: AnimationAction			- lookup
				// }
	
	
				this._bindings = []; // 'nActiveBindings' followed by inactive ones
				this._nActiveBindings = 0;
	
				this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
	
	
				this._controlInterpolants = []; // same game as above
				this._nActiveControlInterpolants = 0;
	
				var scope = this;
	
				this.stats = {
	
					actions: {
						get total() { return scope._actions.length; },
						get inUse() { return scope._nActiveActions; }
					},
					bindings: {
						get total() { return scope._bindings.length; },
						get inUse() { return scope._nActiveBindings; }
					},
					controlInterpolants: {
						get total() { return scope._controlInterpolants.length; },
						get inUse() { return scope._nActiveControlInterpolants; }
					}
	
				};
	
			},
	
			// Memory management for AnimationAction objects
	
			_isActiveAction: function ( action ) {
	
				var index = action._cacheIndex;
				return index !== null && index < this._nActiveActions;
	
			},
	
			_addInactiveAction: function ( action, clipUuid, rootUuid ) {
	
				var actions = this._actions,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];
	
				if ( actionsForClip === undefined ) {
	
					actionsForClip = {
	
						knownActions: [ action ],
						actionByRoot: {}
	
					};
	
					action._byClipCacheIndex = 0;
	
					actionsByClip[ clipUuid ] = actionsForClip;
	
				} else {
	
					var knownActions = actionsForClip.knownActions;
	
					action._byClipCacheIndex = knownActions.length;
					knownActions.push( action );
	
				}
	
				action._cacheIndex = actions.length;
				actions.push( action );
	
				actionsForClip.actionByRoot[ rootUuid ] = action;
	
			},
	
			_removeInactiveAction: function ( action ) {
	
				var actions = this._actions,
					lastInactiveAction = actions[ actions.length - 1 ],
					cacheIndex = action._cacheIndex;
	
				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();
	
				action._cacheIndex = null;
	
	
				var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ],
					knownActionsForClip = actionsForClip.knownActions,
	
					lastKnownAction =
						knownActionsForClip[ knownActionsForClip.length - 1 ],
	
					byClipCacheIndex = action._byClipCacheIndex;
	
				lastKnownAction._byClipCacheIndex = byClipCacheIndex;
				knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
				knownActionsForClip.pop();
	
				action._byClipCacheIndex = null;
	
	
				var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = ( action._localRoot || this._root ).uuid;
	
				delete actionByRoot[ rootUuid ];
	
				if ( knownActionsForClip.length === 0 ) {
	
					delete actionsByClip[ clipUuid ];
	
				}
	
				this._removeInactiveBindingsForAction( action );
	
			},
	
			_removeInactiveBindingsForAction: function ( action ) {
	
				var bindings = action._propertyBindings;
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( -- binding.referenceCount === 0 ) {
	
						this._removeInactiveBinding( binding );
	
					}
	
				}
	
			},
	
			_lendAction: function ( action ) {
	
				// [ active actions |  inactive actions  ]
				// [  active actions >| inactive actions ]
				//                 s        a
				//                  <-swap->
				//                 a        s
	
				var actions = this._actions,
					prevIndex = action._cacheIndex,
	
					lastActiveIndex = this._nActiveActions ++,
	
					firstInactiveAction = actions[ lastActiveIndex ];
	
				action._cacheIndex = lastActiveIndex;
				actions[ lastActiveIndex ] = action;
	
				firstInactiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = firstInactiveAction;
	
			},
	
			_takeBackAction: function ( action ) {
	
				// [  active actions  | inactive actions ]
				// [ active actions |< inactive actions  ]
				//        a        s
				//         <-swap->
				//        s        a
	
				var actions = this._actions,
					prevIndex = action._cacheIndex,
	
					firstInactiveIndex = -- this._nActiveActions,
	
					lastActiveAction = actions[ firstInactiveIndex ];
	
				action._cacheIndex = firstInactiveIndex;
				actions[ firstInactiveIndex ] = action;
	
				lastActiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = lastActiveAction;
	
			},
	
			// Memory management for PropertyMixer objects
	
			_addInactiveBinding: function ( binding, rootUuid, trackName ) {
	
				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],
	
					bindings = this._bindings;
	
				if ( bindingByName === undefined ) {
	
					bindingByName = {};
					bindingsByRoot[ rootUuid ] = bindingByName;
	
				}
	
				bindingByName[ trackName ] = binding;
	
				binding._cacheIndex = bindings.length;
				bindings.push( binding );
	
			},
	
			_removeInactiveBinding: function ( binding ) {
	
				var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],
	
					lastInactiveBinding = bindings[ bindings.length - 1 ],
					cacheIndex = binding._cacheIndex;
	
				lastInactiveBinding._cacheIndex = cacheIndex;
				bindings[ cacheIndex ] = lastInactiveBinding;
				bindings.pop();
	
				delete bindingByName[ trackName ];
	
				remove_empty_map: {
	
					for ( var _ in bindingByName ) break remove_empty_map;
	
					delete bindingsByRoot[ rootUuid ];
	
				}
	
			},
	
			_lendBinding: function ( binding ) {
	
				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
	
					lastActiveIndex = this._nActiveBindings ++,
	
					firstInactiveBinding = bindings[ lastActiveIndex ];
	
				binding._cacheIndex = lastActiveIndex;
				bindings[ lastActiveIndex ] = binding;
	
				firstInactiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = firstInactiveBinding;
	
			},
	
			_takeBackBinding: function ( binding ) {
	
				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
	
					firstInactiveIndex = -- this._nActiveBindings,
	
					lastActiveBinding = bindings[ firstInactiveIndex ];
	
				binding._cacheIndex = firstInactiveIndex;
				bindings[ firstInactiveIndex ] = binding;
	
				lastActiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = lastActiveBinding;
	
			},
	
	
			// Memory management of Interpolants for weight and time scale
	
			_lendControlInterpolant: function () {
	
				var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants ++,
					interpolant = interpolants[ lastActiveIndex ];
	
				if ( interpolant === undefined ) {
	
					interpolant = new LinearInterpolant(
						new Float32Array( 2 ), new Float32Array( 2 ),
						1, this._controlInterpolantsResultBuffer );
	
					interpolant.__cacheIndex = lastActiveIndex;
					interpolants[ lastActiveIndex ] = interpolant;
	
				}
	
				return interpolant;
	
			},
	
			_takeBackControlInterpolant: function ( interpolant ) {
	
				var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,
	
					firstInactiveIndex = -- this._nActiveControlInterpolants,
	
					lastActiveInterpolant = interpolants[ firstInactiveIndex ];
	
				interpolant.__cacheIndex = firstInactiveIndex;
				interpolants[ firstInactiveIndex ] = interpolant;
	
				lastActiveInterpolant.__cacheIndex = prevIndex;
				interpolants[ prevIndex ] = lastActiveInterpolant;
	
			},
	
			_controlInterpolantsResultBuffer: new Float32Array( 1 ),
	
			// return an action for a clip optionally using a custom root target
			// object (this method allocates a lot of dynamic memory in case a
			// previously unknown clip/root combination is specified)
			clipAction: function ( clip, optionalRoot ) {
	
				var root = optionalRoot || this._root,
					rootUuid = root.uuid,
	
					clipObject = typeof clip === 'string' ?
						AnimationClip.findByName( root, clip ) : clip,
	
					clipUuid = clipObject !== null ? clipObject.uuid : clip,
	
					actionsForClip = this._actionsByClip[ clipUuid ],
					prototypeAction = null;
	
				if ( actionsForClip !== undefined ) {
	
					var existingAction =
							actionsForClip.actionByRoot[ rootUuid ];
	
					if ( existingAction !== undefined ) {
	
						return existingAction;
	
					}
	
					// we know the clip, so we don't have to parse all
					// the bindings again but can just copy
					prototypeAction = actionsForClip.knownActions[ 0 ];
	
					// also, take the clip from the prototype action
					if ( clipObject === null )
						clipObject = prototypeAction._clip;
	
				}
	
				// clip must be known when specified via string
				if ( clipObject === null ) return null;
	
				// allocate all resources required to run it
				var newAction = new AnimationAction( this, clipObject, optionalRoot );
	
				this._bindAction( newAction, prototypeAction );
	
				// and make the action known to the memory manager
				this._addInactiveAction( newAction, clipUuid, rootUuid );
	
				return newAction;
	
			},
	
			// get an existing action
			existingAction: function ( clip, optionalRoot ) {
	
				var root = optionalRoot || this._root,
					rootUuid = root.uuid,
	
					clipObject = typeof clip === 'string' ?
						AnimationClip.findByName( root, clip ) : clip,
	
					clipUuid = clipObject ? clipObject.uuid : clip,
	
					actionsForClip = this._actionsByClip[ clipUuid ];
	
				if ( actionsForClip !== undefined ) {
	
					return actionsForClip.actionByRoot[ rootUuid ] || null;
	
				}
	
				return null;
	
			},
	
			// deactivates all previously scheduled actions
			stopAllAction: function () {
	
				var actions = this._actions,
					nActions = this._nActiveActions,
					bindings = this._bindings,
					nBindings = this._nActiveBindings;
	
				this._nActiveActions = 0;
				this._nActiveBindings = 0;
	
				for ( var i = 0; i !== nActions; ++ i ) {
	
					actions[ i ].reset();
	
				}
	
				for ( var i = 0; i !== nBindings; ++ i ) {
	
					bindings[ i ].useCount = 0;
	
				}
	
				return this;
	
			},
	
			// advance the time and update apply the animation
			update: function ( deltaTime ) {
	
				deltaTime *= this.timeScale;
	
				var actions = this._actions,
					nActions = this._nActiveActions,
	
					time = this.time += deltaTime,
					timeDirection = Math.sign( deltaTime ),
	
					accuIndex = this._accuIndex ^= 1;
	
				// run active actions
	
				for ( var i = 0; i !== nActions; ++ i ) {
	
					var action = actions[ i ];
	
					action._update( time, deltaTime, timeDirection, accuIndex );
	
				}
	
				// update scene graph
	
				var bindings = this._bindings,
					nBindings = this._nActiveBindings;
	
				for ( var i = 0; i !== nBindings; ++ i ) {
	
					bindings[ i ].apply( accuIndex );
	
				}
	
				return this;
	
			},
	
			// return this mixer's root target object
			getRoot: function () {
	
				return this._root;
	
			},
	
			// free all resources specific to a particular clip
			uncacheClip: function ( clip ) {
	
				var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];
	
				if ( actionsForClip !== undefined ) {
	
					// note: just calling _removeInactiveAction would mess up the
					// iteration state and also require updating the state we can
					// just throw away
	
					var actionsToRemove = actionsForClip.knownActions;
	
					for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
	
						var action = actionsToRemove[ i ];
	
						this._deactivateAction( action );
	
						var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[ actions.length - 1 ];
	
						action._cacheIndex = null;
						action._byClipCacheIndex = null;
	
						lastInactiveAction._cacheIndex = cacheIndex;
						actions[ cacheIndex ] = lastInactiveAction;
						actions.pop();
	
						this._removeInactiveBindingsForAction( action );
	
					}
	
					delete actionsByClip[ clipUuid ];
	
				}
	
			},
	
			// free all resources specific to a particular root target object
			uncacheRoot: function ( root ) {
	
				var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;
	
				for ( var clipUuid in actionsByClip ) {
	
					var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
						action = actionByRoot[ rootUuid ];
	
					if ( action !== undefined ) {
	
						this._deactivateAction( action );
						this._removeInactiveAction( action );
	
					}
	
				}
	
				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ];
	
				if ( bindingByName !== undefined ) {
	
					for ( var trackName in bindingByName ) {
	
						var binding = bindingByName[ trackName ];
						binding.restoreOriginalState();
						this._removeInactiveBinding( binding );
	
					}
	
				}
	
			},
	
			// remove a targeted clip from the cache
			uncacheAction: function ( clip, optionalRoot ) {
	
				var action = this.existingAction( clip, optionalRoot );
	
				if ( action !== null ) {
	
					this._deactivateAction( action );
					this._removeInactiveAction( action );
	
				}
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Uniform( value ) {
	
			if ( typeof value === 'string' ) {
	
				console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
				value = arguments[ 1 ];
	
			}
	
			this.value = value;
	
		}
	
		Uniform.prototype.clone = function () {
	
			return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedBufferGeometry() {
	
			BufferGeometry.call( this );
	
			this.type = 'InstancedBufferGeometry';
			this.maxInstancedCount = undefined;
	
		}
	
		InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {
	
			constructor: InstancedBufferGeometry,
	
			isInstancedBufferGeometry: true,
	
			addGroup: function ( start, count, materialIndex ) {
	
				this.groups.push( {
	
					start: start,
					count: count,
					materialIndex: materialIndex
	
				} );
	
			},
	
			copy: function ( source ) {
	
				var index = source.index;
	
				if ( index !== null ) {
	
					this.setIndex( index.clone() );
	
				}
	
				var attributes = source.attributes;
	
				for ( var name in attributes ) {
	
					var attribute = attributes[ name ];
					this.addAttribute( name, attribute.clone() );
	
				}
	
				var groups = source.groups;
	
				for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
					var group = groups[ i ];
					this.addGroup( group.start, group.count, group.materialIndex );
	
				}
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {
	
			this.uuid = _Math.generateUUID();
	
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
	
			this.normalized = normalized === true;
	
		}
	
		Object.defineProperties( InterleavedBufferAttribute.prototype, {
	
			count: {
	
				get: function () {
	
					return this.data.count;
	
				}
	
			},
	
			array: {
	
				get: function () {
	
					return this.data.array;
	
				}
	
			}
	
		} );
	
		Object.assign( InterleavedBufferAttribute.prototype, {
	
			isInterleavedBufferAttribute: true,
	
			setX: function ( index, x ) {
	
				this.data.array[ index * this.data.stride + this.offset ] = x;
	
				return this;
	
			},
	
			setY: function ( index, y ) {
	
				this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
	
				return this;
	
			},
	
			setZ: function ( index, z ) {
	
				this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
	
				return this;
	
			},
	
			setW: function ( index, w ) {
	
				this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
	
				return this;
	
			},
	
			getX: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset ];
	
			},
	
			getY: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 1 ];
	
			},
	
			getZ: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 2 ];
	
			},
	
			getW: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 3 ];
	
			},
	
			setXY: function ( index, x, y ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
	
				return this;
	
			},
	
			setXYZ: function ( index, x, y, z ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
	
				return this;
	
			},
	
			setXYZW: function ( index, x, y, z, w ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
				this.data.array[ index + 3 ] = w;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InterleavedBuffer( array, stride ) {
	
			this.uuid = _Math.generateUUID();
	
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
	
			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };
	
			this.onUploadCallback = function () {};
	
			this.version = 0;
	
		}
	
		Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {
	
			set: function ( value ) {
	
				if ( value === true ) this.version ++;
	
			}
	
		} );
	
		Object.assign( InterleavedBuffer.prototype, {
	
			isInterleavedBuffer: true,
	
			setArray: function ( array ) {
	
				if ( Array.isArray( array ) ) {
	
					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
				}
	
				this.count = array !== undefined ? array.length / this.stride : 0;
				this.array = array;
	
			},
	
			setDynamic: function ( value ) {
	
				this.dynamic = value;
	
				return this;
	
			},
	
			copy: function ( source ) {
	
				this.array = new source.array.constructor( source.array );
				this.count = source.count;
				this.stride = source.stride;
				this.dynamic = source.dynamic;
	
				return this;
	
			},
	
			copyAt: function ( index1, attribute, index2 ) {
	
				index1 *= this.stride;
				index2 *= attribute.stride;
	
				for ( var i = 0, l = this.stride; i < l; i ++ ) {
	
					this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
				}
	
				return this;
	
			},
	
			set: function ( value, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.array.set( value, offset );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			onUpload: function ( callback ) {
	
				this.onUploadCallback = callback;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {
	
			InterleavedBuffer.call( this, array, stride );
	
			this.meshPerAttribute = meshPerAttribute || 1;
	
		}
	
		InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {
	
			constructor: InstancedInterleavedBuffer,
	
			isInstancedInterleavedBuffer: true,
	
			copy: function ( source ) {
	
				InterleavedBuffer.prototype.copy.call( this, source );
	
				this.meshPerAttribute = source.meshPerAttribute;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {
	
			BufferAttribute.call( this, array, itemSize );
	
			this.meshPerAttribute = meshPerAttribute || 1;
	
		}
	
		InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {
	
			constructor: InstancedBufferAttribute,
	
			isInstancedBufferAttribute: true,
	
			copy: function ( source ) {
	
				BufferAttribute.prototype.copy.call( this, source );
	
				this.meshPerAttribute = source.meshPerAttribute;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 * @author stephomi / http://stephaneginier.com/
		 */
	
		function Raycaster( origin, direction, near, far ) {
	
			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};
	
			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );
	
		}
	
		function ascSort( a, b ) {
	
			return a.distance - b.distance;
	
		}
	
		function intersectObject( object, raycaster, intersects, recursive ) {
	
			if ( object.visible === false ) return;
	
			object.raycast( raycaster, intersects );
	
			if ( recursive === true ) {
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					intersectObject( children[ i ], raycaster, intersects, true );
	
				}
	
			}
	
		}
	
		Object.assign( Raycaster.prototype, {
	
			linePrecision: 1,
	
			set: function ( origin, direction ) {
	
				// direction is assumed to be normalized (for accurate distance calculations)
	
				this.ray.set( origin, direction );
	
			},
	
			setFromCamera: function ( coords, camera ) {
	
				if ( ( camera && camera.isPerspectiveCamera ) ) {
	
					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
	
				} else if ( ( camera && camera.isOrthographicCamera ) ) {
	
					this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
				} else {
	
					console.error( 'THREE.Raycaster: Unsupported camera type.' );
	
				}
	
			},
	
			intersectObject: function ( object, recursive ) {
	
				var intersects = [];
	
				intersectObject( object, this, intersects, recursive );
	
				intersects.sort( ascSort );
	
				return intersects;
	
			},
	
			intersectObjects: function ( objects, recursive ) {
	
				var intersects = [];
	
				if ( Array.isArray( objects ) === false ) {
	
					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;
	
				}
	
				for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
					intersectObject( objects[ i ], this, intersects, recursive );
	
				}
	
				intersects.sort( ascSort );
	
				return intersects;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Clock( autoStart ) {
	
			this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
	
			this.running = false;
	
		}
	
		Object.assign( Clock.prototype, {
	
			start: function () {
	
				this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732
	
				this.oldTime = this.startTime;
				this.elapsedTime = 0;
				this.running = true;
	
			},
	
			stop: function () {
	
				this.getElapsedTime();
				this.running = false;
				this.autoStart = false;
	
			},
	
			getElapsedTime: function () {
	
				this.getDelta();
				return this.elapsedTime;
	
			},
	
			getDelta: function () {
	
				var diff = 0;
	
				if ( this.autoStart && ! this.running ) {
	
					this.start();
					return 0;
	
				}
	
				if ( this.running ) {
	
					var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();
	
					diff = ( newTime - this.oldTime ) / 1000;
					this.oldTime = newTime;
	
					this.elapsedTime += diff;
	
				}
	
				return diff;
	
			}
	
		} );
	
		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
		 *
		 * The poles (phi) are at the positive and negative y axis.
		 * The equator starts at positive z.
		 */
	
		function Spherical( radius, phi, theta ) {
	
			this.radius = ( radius !== undefined ) ? radius : 1.0;
			this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
			this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere
	
			return this;
	
		}
	
		Object.assign( Spherical.prototype, {
	
			set: function ( radius, phi, theta ) {
	
				this.radius = radius;
				this.phi = phi;
				this.theta = theta;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( other ) {
	
				this.radius = other.radius;
				this.phi = other.phi;
				this.theta = other.theta;
	
				return this;
	
			},
	
			// restrict phi to be betwee EPS and PI-EPS
			makeSafe: function() {
	
				var EPS = 0.000001;
				this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
	
				return this;
	
			},
	
			setFromVector3: function( vec3 ) {
	
				this.radius = vec3.length();
	
				if ( this.radius === 0 ) {
	
					this.theta = 0;
					this.phi = 0;
	
				} else {
	
					this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
					this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle
	
				}
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
		 *
		 */
	
		function Cylindrical( radius, theta, y ) {
	
			this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
			this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
			this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane
	
			return this;
	
		}
	
		Object.assign( Cylindrical.prototype, {
	
			set: function ( radius, theta, y ) {
	
				this.radius = radius;
				this.theta = theta;
				this.y = y;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( other ) {
	
				this.radius = other.radius;
				this.theta = other.theta;
				this.y = other.y;
	
				return this;
	
			},
	
			setFromVector3: function( vec3 ) {
	
				this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
				this.theta = Math.atan2( vec3.x, vec3.z );
				this.y = vec3.y;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function MorphBlendMesh( geometry, material ) {
	
			Mesh.call( this, geometry, material );
	
			this.animationsMap = {};
			this.animationsList = [];
	
			// prepare default animation
			// (all frames played together in 1 second)
	
			var numFrames = this.geometry.morphTargets.length;
	
			var name = "__default";
	
			var startFrame = 0;
			var endFrame = numFrames - 1;
	
			var fps = numFrames / 1;
	
			this.createAnimation( name, startFrame, endFrame, fps );
			this.setAnimationWeight( name, 1 );
	
		}
	
		MorphBlendMesh.prototype = Object.create( Mesh.prototype );
		MorphBlendMesh.prototype.constructor = MorphBlendMesh;
	
		MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
			var animation = {
	
				start: start,
				end: end,
	
				length: end - start + 1,
	
				fps: fps,
				duration: ( end - start ) / fps,
	
				lastFrame: 0,
				currentFrame: 0,
	
				active: false,
	
				time: 0,
				direction: 1,
				weight: 1,
	
				directionBackwards: false,
				mirroredLoop: false
	
			};
	
			this.animationsMap[ name ] = animation;
			this.animationsList.push( animation );
	
		};
	
		MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
			var pattern = /([a-z]+)_?(\d+)/i;
	
			var firstAnimation, frameRanges = {};
	
			var geometry = this.geometry;
	
			for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
				var morph = geometry.morphTargets[ i ];
				var chunks = morph.name.match( pattern );
	
				if ( chunks && chunks.length > 1 ) {
	
					var name = chunks[ 1 ];
	
					if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };
	
					var range = frameRanges[ name ];
	
					if ( i < range.start ) range.start = i;
					if ( i > range.end ) range.end = i;
	
					if ( ! firstAnimation ) firstAnimation = name;
	
				}
	
			}
	
			for ( var name in frameRanges ) {
	
				var range = frameRanges[ name ];
				this.createAnimation( name, range.start, range.end, fps );
	
			}
	
			this.firstAnimation = firstAnimation;
	
		};
	
		MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.direction = 1;
				animation.directionBackwards = false;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.direction = - 1;
				animation.directionBackwards = true;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.fps = fps;
				animation.duration = ( animation.end - animation.start ) / animation.fps;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.duration = duration;
				animation.fps = ( animation.end - animation.start ) / animation.duration;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.weight = weight;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.time = time;
	
			}
	
		};
	
		MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
			var time = 0;
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				time = animation.time;
	
			}
	
			return time;
	
		};
	
		MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
			var duration = - 1;
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				duration = animation.duration;
	
			}
	
			return duration;
	
		};
	
		MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.time = 0;
				animation.active = true;
	
			} else {
	
				console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );
	
			}
	
		};
	
		MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.active = false;
	
			}
	
		};
	
		MorphBlendMesh.prototype.update = function ( delta ) {
	
			for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
				var animation = this.animationsList[ i ];
	
				if ( ! animation.active ) continue;
	
				var frameTime = animation.duration / animation.length;
	
				animation.time += animation.direction * delta;
	
				if ( animation.mirroredLoop ) {
	
					if ( animation.time > animation.duration || animation.time < 0 ) {
	
						animation.direction *= - 1;
	
						if ( animation.time > animation.duration ) {
	
							animation.time = animation.duration;
							animation.directionBackwards = true;
	
						}
	
						if ( animation.time < 0 ) {
	
							animation.time = 0;
							animation.directionBackwards = false;
	
						}
	
					}
	
				} else {
	
					animation.time = animation.time % animation.duration;
	
					if ( animation.time < 0 ) animation.time += animation.duration;
	
				}
	
				var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
				var weight = animation.weight;
	
				if ( keyframe !== animation.currentFrame ) {
	
					this.morphTargetInfluences[ animation.lastFrame ] = 0;
					this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
					this.morphTargetInfluences[ keyframe ] = 0;
	
					animation.lastFrame = animation.currentFrame;
					animation.currentFrame = keyframe;
	
				}
	
				var mix = ( animation.time % frameTime ) / frameTime;
	
				if ( animation.directionBackwards ) mix = 1 - mix;
	
				if ( animation.currentFrame !== animation.lastFrame ) {
	
					this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
					this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
				} else {
	
					this.morphTargetInfluences[ animation.currentFrame ] = weight;
	
				}
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function ImmediateRenderObject( material ) {
	
			Object3D.call( this );
	
			this.material = material;
			this.render = function ( renderCallback ) {};
	
		}
	
		ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
		ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
	
		ImmediateRenderObject.prototype.isImmediateRenderObject = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function VertexNormalsHelper( object, size, hex, linewidth ) {
	
			this.object = object;
	
			this.size = ( size !== undefined ) ? size : 1;
	
			var color = ( hex !== undefined ) ? hex : 0xff0000;
	
			var width = ( linewidth !== undefined ) ? linewidth : 1;
	
			//
	
			var nNormals = 0;
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry && objGeometry.isGeometry ) {
	
				nNormals = objGeometry.faces.length * 3;
	
			} else if ( objGeometry && objGeometry.isBufferGeometry ) {
	
				nNormals = objGeometry.attributes.normal.count;
	
			}
	
			//
	
			var geometry = new BufferGeometry();
	
			var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	
			geometry.addAttribute( 'position', positions );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
			//
	
			this.matrixAutoUpdate = false;
	
			this.update();
	
		}
	
		VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
		VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
	
		VertexNormalsHelper.prototype.update = ( function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();
	
			return function update() {
	
				var keys = [ 'a', 'b', 'c' ];
	
				this.object.updateMatrixWorld( true );
	
				normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
				var matrixWorld = this.object.matrixWorld;
	
				var position = this.geometry.attributes.position;
	
				//
	
				var objGeometry = this.object.geometry;
	
				if ( objGeometry && objGeometry.isGeometry ) {
	
					var vertices = objGeometry.vertices;
	
					var faces = objGeometry.faces;
	
					var idx = 0;
	
					for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
						var face = faces[ i ];
	
						for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
							var vertex = vertices[ face[ keys[ j ] ] ];
	
							var normal = face.vertexNormals[ j ];
	
							v1.copy( vertex ).applyMatrix4( matrixWorld );
	
							v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
							position.setXYZ( idx, v1.x, v1.y, v1.z );
	
							idx = idx + 1;
	
							position.setXYZ( idx, v2.x, v2.y, v2.z );
	
							idx = idx + 1;
	
						}
	
					}
	
				} else if ( objGeometry && objGeometry.isBufferGeometry ) {
	
					var objPos = objGeometry.attributes.position;
	
					var objNorm = objGeometry.attributes.normal;
	
					var idx = 0;
	
					// for simplicity, ignore index and drawcalls, and render every normal
	
					for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
	
						v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
	
						v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
	
						v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
						position.setXYZ( idx, v1.x, v1.y, v1.z );
	
						idx = idx + 1;
	
						position.setXYZ( idx, v2.x, v2.y, v2.z );
	
						idx = idx + 1;
	
					}
	
				}
	
				position.needsUpdate = true;
	
			};
	
		}() );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function SpotLightHelper( light ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			var geometry = new BufferGeometry();
	
			var positions = [
				0, 0, 0,   0,   0,   1,
				0, 0, 0,   1,   0,   1,
				0, 0, 0, - 1,   0,   1,
				0, 0, 0,   0,   1,   1,
				0, 0, 0,   0, - 1,   1
			];
	
			for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {
	
				var p1 = ( i / l ) * Math.PI * 2;
				var p2 = ( j / l ) * Math.PI * 2;
	
				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);
	
			}
	
			geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	
			var material = new LineBasicMaterial( { fog: false } );
	
			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );
	
			this.update();
	
		}
	
		SpotLightHelper.prototype = Object.create( Object3D.prototype );
		SpotLightHelper.prototype.constructor = SpotLightHelper;
	
		SpotLightHelper.prototype.dispose = function () {
	
			this.cone.geometry.dispose();
			this.cone.material.dispose();
	
		};
	
		SpotLightHelper.prototype.update = function () {
	
			var vector = new Vector3();
			var vector2 = new Vector3();
	
			return function update() {
	
				this.light.updateMatrixWorld();
	
				var coneLength = this.light.distance ? this.light.distance : 1000;
				var coneWidth = coneLength * Math.tan( this.light.angle );
	
				this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
				vector.setFromMatrixPosition( this.light.matrixWorld );
				vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
				this.cone.lookAt( vector2.sub( vector ) );
	
				this.cone.material.color.copy( this.light.color );
	
			};
	
		}();
	
		/**
		 * @author Sean Griffin / http://twitter.com/sgrif
		 * @author Michael Guerrero / http://realitymeltdown.com
		 * @author mrdoob / http://mrdoob.com/
		 * @author ikerr / http://verold.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function getBoneList( object ) {
	
			var boneList = [];
	
			if ( object && object.isBone ) {
	
				boneList.push( object );
	
			}
	
			for ( var i = 0; i < object.children.length; i ++ ) {
	
				boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );
	
			}
	
			return boneList;
	
		}
	
		function SkeletonHelper( object ) {
	
			var bones = getBoneList( object );
	
			var geometry = new BufferGeometry();
	
			var vertices = [];
			var colors = [];
	
			var color1 = new Color( 0, 0, 1 );
			var color2 = new Color( 0, 1, 0 );
	
			for ( var i = 0; i < bones.length; i ++ ) {
	
				var bone = bones[ i ];
	
				if ( bone.parent && bone.parent.isBone ) {
	
					vertices.push( 0, 0, 0 );
					vertices.push( 0, 0, 0 );
					colors.push( color1.r, color1.g, color1.b );
					colors.push( color2.r, color2.g, color2.b );
	
				}
	
			}
	
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
			LineSegments.call( this, geometry, material );
	
			this.root = object;
			this.bones = bones;
	
			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;
	
			this.onBeforeRender();
	
		}
	
		SkeletonHelper.prototype = Object.create( LineSegments.prototype );
		SkeletonHelper.prototype.constructor = SkeletonHelper;
	
		SkeletonHelper.prototype.onBeforeRender = function () {
	
			var vector = new Vector3();
	
			var boneMatrix = new Matrix4();
			var matrixWorldInv = new Matrix4();
	
			return function onBeforeRender() {
	
				var bones = this.bones;
	
				var geometry = this.geometry;
				var position = geometry.getAttribute( 'position' );
	
				matrixWorldInv.getInverse( this.root.matrixWorld );
	
				for ( var i = 0, j = 0; i < bones.length; i ++ ) {
	
					var bone = bones[ i ];
	
					if ( bone.parent && bone.parent.isBone ) {
	
						boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
						vector.setFromMatrixPosition( boneMatrix );
						position.setXYZ( j, vector.x, vector.y, vector.z );
	
						boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
						vector.setFromMatrixPosition( boneMatrix );
						position.setXYZ( j + 1, vector.x, vector.y, vector.z );
	
						j += 2;
	
					}
	
				}
	
				geometry.getAttribute( 'position' ).needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function PointLightHelper( light, sphereSize ) {
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
			var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
			material.color.copy( this.light.color );
	
			Mesh.call( this, geometry, material );
	
			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			/*
			var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
			var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
			var d = light.distance;
	
			if ( d === 0.0 ) {
	
				this.lightDistance.visible = false;
	
			} else {
	
				this.lightDistance.scale.set( d, d, d );
	
			}
	
			this.add( this.lightDistance );
			*/
	
		}
	
		PointLightHelper.prototype = Object.create( Mesh.prototype );
		PointLightHelper.prototype.constructor = PointLightHelper;
	
		PointLightHelper.prototype.dispose = function () {
	
			this.geometry.dispose();
			this.material.dispose();
	
		};
	
		PointLightHelper.prototype.update = function () {
	
			this.material.color.copy( this.light.color );
	
			/*
			var d = this.light.distance;
	
			if ( d === 0.0 ) {
	
				this.lightDistance.visible = false;
	
			} else {
	
				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
	
			}
			*/
	
		};
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 * @author Mugen87 / http://github.com/Mugen87
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function RectAreaLightHelper( light ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			var material = new LineBasicMaterial( { color: light.color } );
	
			var geometry = new BufferGeometry();
	
			geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );
	
			this.add( new Line( geometry, material ) );
	
			this.update();
	
		}
	
		RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
		RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
	
		RectAreaLightHelper.prototype.dispose = function () {
	
			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();
	
		};
	
		RectAreaLightHelper.prototype.update = function () {
	
			var line = this.children[ 0 ];
	
			// update material
	
			line.material.color.copy( this.light.color );
	
			// calculate new dimensions of the helper
	
			var hx = this.light.width * 0.5;
			var hy = this.light.height * 0.5;
	
			var position = line.geometry.attributes.position;
			var array = position.array;
	
			// update vertices
	
			array[  0 ] =   hx; array[  1 ] = - hy; array[  2 ] = 0;
			array[  3 ] =   hx; array[  4 ] =   hy; array[  5 ] = 0;
			array[  6 ] = - hx; array[  7 ] =   hy; array[  8 ] = 0;
			array[  9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
			array[ 12 ] =   hx; array[ 13 ] = - hy; array[ 14 ] = 0;
	
			position.needsUpdate = true;
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function HemisphereLightHelper( light, size ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			var geometry = new OctahedronBufferGeometry( size );
			geometry.rotateY( Math.PI * 0.5 );
	
			var material = new MeshBasicMaterial( { vertexColors: VertexColors, wireframe: true } );
	
			var position = geometry.getAttribute( 'position' );
			var colors = new Float32Array( position.count * 3 );
	
			geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );
	
			this.add( new Mesh( geometry, material ) );
	
			this.update();
	
		}
	
		HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
		HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
	
		HemisphereLightHelper.prototype.dispose = function () {
	
			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();
	
		};
	
		HemisphereLightHelper.prototype.update = function () {
	
			var vector = new Vector3();
	
			var color1 = new Color();
			var color2 = new Color();
	
			return function update() {
	
				var mesh = this.children[ 0 ];
	
				var colors = mesh.geometry.getAttribute( 'color' );
	
				color1.copy( this.light.color );
				color2.copy( this.light.groundColor );
	
				for ( var i = 0, l = colors.count; i < l; i ++ ) {
	
					var color = ( i < ( l / 2 ) ) ? color1 : color2;
	
					colors.setXYZ( i, color.r, color.g, color.b );
	
				}
	
				mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
	
				colors.needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function GridHelper( size, divisions, color1, color2 ) {
	
			size = size || 10;
			divisions = divisions || 10;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	
			var center = divisions / 2;
			var step = size / divisions;
			var halfSize = size / 2;
	
			var vertices = [], colors = [];
	
			for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {
	
				vertices.push( - halfSize, 0, k, halfSize, 0, k );
				vertices.push( k, 0, - halfSize, k, 0, halfSize );
	
				var color = i === center ? color1 : color2;
	
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
	
			}
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		GridHelper.prototype = Object.create( LineSegments.prototype );
		GridHelper.prototype.constructor = GridHelper;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / http://github.com/Mugen87
		 * @author Hectate / http://www.github.com/Hectate
		 */
	
		function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {
	
			radius = radius || 10;
			radials = radials || 16;
			circles = circles || 8;
			divisions = divisions || 64;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	
			var vertices = [];
			var colors = [];
	
			var x, z;
			var v, i, j, r, color;
	
			// create the radials
	
			for ( i = 0; i <= radials; i ++ ) {
	
				v = ( i / radials ) * ( Math.PI * 2 );
	
				x = Math.sin( v ) * radius;
				z = Math.cos( v ) * radius;
	
				vertices.push( 0, 0, 0 );
				vertices.push( x, 0, z );
	
				color = ( i & 1 ) ? color1 : color2;
	
				colors.push( color.r, color.g, color.b );
				colors.push( color.r, color.g, color.b );
	
			}
	
			// create the circles
	
			for ( i = 0; i <= circles; i ++ ) {
	
				color = ( i & 1 ) ? color1 : color2;
	
				r = radius - ( radius / circles * i );
	
				for ( j = 0; j < divisions; j ++ ) {
	
					// first vertex
	
					v = ( j / divisions ) * ( Math.PI * 2 );
	
					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;
	
					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );
	
					// second vertex
	
					v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );
	
					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;
	
					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );
	
				}
	
			}
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		PolarGridHelper.prototype = Object.create( LineSegments.prototype );
		PolarGridHelper.prototype.constructor = PolarGridHelper;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function FaceNormalsHelper( object, size, hex, linewidth ) {
	
			// FaceNormalsHelper only supports THREE.Geometry
	
			this.object = object;
	
			this.size = ( size !== undefined ) ? size : 1;
	
			var color = ( hex !== undefined ) ? hex : 0xffff00;
	
			var width = ( linewidth !== undefined ) ? linewidth : 1;
	
			//
	
			var nNormals = 0;
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry && objGeometry.isGeometry ) {
	
				nNormals = objGeometry.faces.length;
	
			} else {
	
				console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	
			}
	
			//
	
			var geometry = new BufferGeometry();
	
			var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	
			geometry.addAttribute( 'position', positions );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
			//
	
			this.matrixAutoUpdate = false;
			this.update();
	
		}
	
		FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
		FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
	
		FaceNormalsHelper.prototype.update = ( function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();
	
			return function update() {
	
				this.object.updateMatrixWorld( true );
	
				normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
				var matrixWorld = this.object.matrixWorld;
	
				var position = this.geometry.attributes.position;
	
				//
	
				var objGeometry = this.object.geometry;
	
				var vertices = objGeometry.vertices;
	
				var faces = objGeometry.faces;
	
				var idx = 0;
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					var normal = face.normal;
	
					v1.copy( vertices[ face.a ] )
						.add( vertices[ face.b ] )
						.add( vertices[ face.c ] )
						.divideScalar( 3 )
						.applyMatrix4( matrixWorld );
	
					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
					position.setXYZ( idx, v1.x, v1.y, v1.z );
	
					idx = idx + 1;
	
					position.setXYZ( idx, v2.x, v2.y, v2.z );
	
					idx = idx + 1;
	
				}
	
				position.needsUpdate = true;
	
			};
	
		}() );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function DirectionalLightHelper( light, size ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			if ( size === undefined ) size = 1;
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( [
				- size,   size, 0,
				  size,   size, 0,
				  size, - size, 0,
				- size, - size, 0,
				- size,   size, 0
			], 3 ) );
	
			var material = new LineBasicMaterial( { fog: false } );
	
			this.add( new Line( geometry, material ) );
	
			geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );
	
			this.add( new Line( geometry, material ));
	
			this.update();
	
		}
	
		DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
		DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
	
		DirectionalLightHelper.prototype.dispose = function () {
	
			var lightPlane = this.children[ 0 ];
			var targetLine = this.children[ 1 ];
	
			lightPlane.geometry.dispose();
			lightPlane.material.dispose();
			targetLine.geometry.dispose();
			targetLine.material.dispose();
	
		};
	
		DirectionalLightHelper.prototype.update = function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var v3 = new Vector3();
	
			return function update() {
	
				v1.setFromMatrixPosition( this.light.matrixWorld );
				v2.setFromMatrixPosition( this.light.target.matrixWorld );
				v3.subVectors( v2, v1 );
	
				var lightPlane = this.children[ 0 ];
				var targetLine = this.children[ 1 ];
	
				lightPlane.lookAt( v3 );
				lightPlane.material.color.copy( this.light.color );
	
				targetLine.lookAt( v3 );
				targetLine.scale.z = v3.length();
	
			};
	
		}();
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 *	- shows frustum, line of sight and up of the camera
		 *	- suitable for fast updates
		 * 	- based on frustum visualization in lightgl.js shadowmap example
		 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
		 */
	
		function CameraHelper( camera ) {
	
			var geometry = new BufferGeometry();
			var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );
	
			var vertices = [];
			var colors = [];
	
			var pointMap = {};
	
			// colors
	
			var colorFrustum = new Color( 0xffaa00 );
			var colorCone = new Color( 0xff0000 );
			var colorUp = new Color( 0x00aaff );
			var colorTarget = new Color( 0xffffff );
			var colorCross = new Color( 0x333333 );
	
			// near
	
			addLine( "n1", "n2", colorFrustum );
			addLine( "n2", "n4", colorFrustum );
			addLine( "n4", "n3", colorFrustum );
			addLine( "n3", "n1", colorFrustum );
	
			// far
	
			addLine( "f1", "f2", colorFrustum );
			addLine( "f2", "f4", colorFrustum );
			addLine( "f4", "f3", colorFrustum );
			addLine( "f3", "f1", colorFrustum );
	
			// sides
	
			addLine( "n1", "f1", colorFrustum );
			addLine( "n2", "f2", colorFrustum );
			addLine( "n3", "f3", colorFrustum );
			addLine( "n4", "f4", colorFrustum );
	
			// cone
	
			addLine( "p", "n1", colorCone );
			addLine( "p", "n2", colorCone );
			addLine( "p", "n3", colorCone );
			addLine( "p", "n4", colorCone );
	
			// up
	
			addLine( "u1", "u2", colorUp );
			addLine( "u2", "u3", colorUp );
			addLine( "u3", "u1", colorUp );
	
			// target
	
			addLine( "c", "t", colorTarget );
			addLine( "p", "c", colorCross );
	
			// cross
	
			addLine( "cn1", "cn2", colorCross );
			addLine( "cn3", "cn4", colorCross );
	
			addLine( "cf1", "cf2", colorCross );
			addLine( "cf3", "cf4", colorCross );
	
			function addLine( a, b, color ) {
	
				addPoint( a, color );
				addPoint( b, color );
	
			}
	
			function addPoint( id, color ) {
	
				vertices.push( 0, 0, 0 );
				colors.push( color.r, color.g, color.b );
	
				if ( pointMap[ id ] === undefined ) {
	
					pointMap[ id ] = [];
	
				}
	
				pointMap[ id ].push( ( vertices.length / 3 ) - 1 );
	
			}
	
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			LineSegments.call( this, geometry, material );
	
			this.camera = camera;
			if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();
	
			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;
	
			this.pointMap = pointMap;
	
			this.update();
	
		}
	
		CameraHelper.prototype = Object.create( LineSegments.prototype );
		CameraHelper.prototype.constructor = CameraHelper;
	
		CameraHelper.prototype.update = function () {
	
			var geometry, pointMap;
	
			var vector = new Vector3();
			var camera = new Camera();
	
			function setPoint( point, x, y, z ) {
	
				vector.set( x, y, z ).unproject( camera );
	
				var points = pointMap[ point ];
	
				if ( points !== undefined ) {
	
					var position = geometry.getAttribute( 'position' );
	
					for ( var i = 0, l = points.length; i < l; i ++ ) {
	
						position.setXYZ( points[ i ], vector.x, vector.y, vector.z );
	
					}
	
				}
	
			}
	
			return function update() {
	
				geometry = this.geometry;
				pointMap = this.pointMap;
	
				var w = 1, h = 1;
	
				// we need just camera projection matrix
				// world matrix must be identity
	
				camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
				// center / target
	
				setPoint( "c", 0, 0, - 1 );
				setPoint( "t", 0, 0,  1 );
	
				// near
	
				setPoint( "n1", - w, - h, - 1 );
				setPoint( "n2",   w, - h, - 1 );
				setPoint( "n3", - w,   h, - 1 );
				setPoint( "n4",   w,   h, - 1 );
	
				// far
	
				setPoint( "f1", - w, - h, 1 );
				setPoint( "f2",   w, - h, 1 );
				setPoint( "f3", - w,   h, 1 );
				setPoint( "f4",   w,   h, 1 );
	
				// up
	
				setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
				setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
				setPoint( "u3",         0, h * 2,   - 1 );
	
				// cross
	
				setPoint( "cf1", - w,   0, 1 );
				setPoint( "cf2",   w,   0, 1 );
				setPoint( "cf3",   0, - h, 1 );
				setPoint( "cf4",   0,   h, 1 );
	
				setPoint( "cn1", - w,   0, - 1 );
				setPoint( "cn2",   w,   0, - 1 );
				setPoint( "cn3",   0, - h, - 1 );
				setPoint( "cn4",   0,   h, - 1 );
	
				geometry.getAttribute( 'position' ).needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / http://github.com/Mugen87
		 */
	
		function BoxHelper( object, color ) {
	
			this.object = object;
	
			if ( color === undefined ) color = 0xffff00;
	
			var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			var positions = new Float32Array( 8 * 3 );
	
			var geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	
			this.matrixAutoUpdate = false;
	
			this.update();
	
		}
	
		BoxHelper.prototype = Object.create( LineSegments.prototype );
		BoxHelper.prototype.constructor = BoxHelper;
	
		BoxHelper.prototype.update = ( function () {
	
			var box = new Box3();
	
			return function update( object ) {
	
				if ( object !== undefined ) {
	
					console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );
	
				}
	
				if ( this.object !== undefined ) {
	
					box.setFromObject( this.object );
	
				}
	
				if ( box.isEmpty() ) return;
	
				var min = box.min;
				var max = box.max;
	
				/*
				  5____4
				1/___0/|
				| 6__|_7
				2/___3/
	
				0: max.x, max.y, max.z
				1: min.x, max.y, max.z
				2: min.x, min.y, max.z
				3: max.x, min.y, max.z
				4: max.x, max.y, min.z
				5: min.x, max.y, min.z
				6: min.x, min.y, min.z
				7: max.x, min.y, min.z
				*/
	
				var position = this.geometry.attributes.position;
				var array = position.array;
	
				array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
				array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
				array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
				array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
				array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
				array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
				array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
				array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
	
				position.needsUpdate = true;
	
				this.geometry.computeBoundingSphere();
	
			};
	
		} )();
	
		BoxHelper.prototype.setFromObject = function ( object ) {
	
			this.object = object;
			this.update();
	
			return this;
	
		};
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author zz85 / http://github.com/zz85
		 * @author bhouston / http://clara.io
		 *
		 * Creates an arrow for visualizing directions
		 *
		 * Parameters:
		 *  dir - Vector3
		 *  origin - Vector3
		 *  length - Number
		 *  color - color in hex value
		 *  headLength - Number
		 *  headWidth - Number
		 */
	
		var lineGeometry;
		var coneGeometry;
	
		function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	
			// dir is assumed to be normalized
	
			Object3D.call( this );
	
			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			if ( lineGeometry === undefined ) {
	
				lineGeometry = new BufferGeometry();
				lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );
	
				coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
				coneGeometry.translate( 0, - 0.5, 0 );
	
			}
	
			this.position.copy( origin );
	
			this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
	
			this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );
	
			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );
	
		}
	
		ArrowHelper.prototype = Object.create( Object3D.prototype );
		ArrowHelper.prototype.constructor = ArrowHelper;
	
		ArrowHelper.prototype.setDirection = ( function () {
	
			var axis = new Vector3();
			var radians;
	
			return function setDirection( dir ) {
	
				// dir is assumed to be normalized
	
				if ( dir.y > 0.99999 ) {
	
					this.quaternion.set( 0, 0, 0, 1 );
	
				} else if ( dir.y < - 0.99999 ) {
	
					this.quaternion.set( 1, 0, 0, 0 );
	
				} else {
	
					axis.set( dir.z, 0, - dir.x ).normalize();
	
					radians = Math.acos( dir.y );
	
					this.quaternion.setFromAxisAngle( axis, radians );
	
				}
	
			};
	
		}() );
	
		ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
			this.line.updateMatrix();
	
			this.cone.scale.set( headWidth, headLength, headWidth );
			this.cone.position.y = length;
			this.cone.updateMatrix();
	
		};
	
		ArrowHelper.prototype.setColor = function ( color ) {
	
			this.line.material.color.copy( color );
			this.cone.material.color.copy( color );
	
		};
	
		/**
		 * @author sroucheray / http://sroucheray.org/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AxisHelper( size ) {
	
			size = size || 1;
	
			var vertices = [
				0, 0, 0,  size, 0, 0,
				0, 0, 0,  0, size, 0,
				0, 0, 0,  0, 0, size
			];
	
			var colors = [
				1, 0, 0,  1, 0.6, 0,
				0, 1, 0,  0.6, 1, 0,
				0, 0, 1,  0, 0.6, 1
			];
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		AxisHelper.prototype = Object.create( LineSegments.prototype );
		AxisHelper.prototype.constructor = AxisHelper;
	
		/**
		 * @author zz85 https://github.com/zz85
		 *
		 * Centripetal CatmullRom Curve - which is useful for avoiding
		 * cusps and self-intersections in non-uniform catmull rom curves.
		 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
		 *
		 * curve.type accepts centripetal(default), chordal and catmullrom
		 * curve.tension is used for catmullrom which defaults to 0.5
		 */
	
	
		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM
	
		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/
	
		function CubicPoly() {
	
			var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
	
			/*
			 * Compute coefficients for a cubic polynomial
			 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
			 * such that
			 *   p(0) = x0, p(1) = x1
			 *  and
			 *   p'(0) = t0, p'(1) = t1.
			 */
			function init( x0, x1, t0, t1 ) {
	
				c0 = x0;
				c1 = t0;
				c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
				c3 = 2 * x0 - 2 * x1 + t0 + t1;
	
			}
	
			return {
	
				initCatmullRom: function ( x0, x1, x2, x3, tension ) {
	
					init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
	
				},
	
				initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {
	
					// compute tangents when parameterized in [t1,t2]
					var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
					var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
	
					// rescale tangents for parametrization in [0,1]
					t1 *= dt1;
					t2 *= dt1;
	
					init( x1, x2, t1, t2 );
	
				},
	
				calc: function ( t ) {
	
					var t2 = t * t;
					var t3 = t2 * t;
					return c0 + c1 * t + c2 * t2 + c3 * t3;
	
				}
	
			};
	
		}
	
		//
	
		var tmp = new Vector3();
		var px = new CubicPoly();
		var py = new CubicPoly();
		var pz = new CubicPoly();
	
		function CatmullRomCurve3( points ) {
	
			Curve.call( this );
	
			if ( points.length < 2 ) console.warn( 'THREE.CatmullRomCurve3: Points array needs at least two entries.' );
	
			this.points = points || [];
			this.closed = false;
	
		}
	
		CatmullRomCurve3.prototype = Object.create( Curve.prototype );
		CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
	
		CatmullRomCurve3.prototype.getPoint = function ( t ) {
	
			var points = this.points;
			var l = points.length;
	
			var point = ( l - ( this.closed ? 0 : 1 ) ) * t;
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			if ( this.closed ) {
	
				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	
			} else if ( weight === 0 && intPoint === l - 1 ) {
	
				intPoint = l - 2;
				weight = 1;
	
			}
	
			var p0, p1, p2, p3; // 4 points
	
			if ( this.closed || intPoint > 0 ) {
	
				p0 = points[ ( intPoint - 1 ) % l ];
	
			} else {
	
				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;
	
			}
	
			p1 = points[ intPoint % l ];
			p2 = points[ ( intPoint + 1 ) % l ];
	
			if ( this.closed || intPoint + 2 < l ) {
	
				p3 = points[ ( intPoint + 2 ) % l ];
	
			} else {
	
				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;
	
			}
	
			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {
	
				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
	
				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;
	
				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	
			} else if ( this.type === 'catmullrom' ) {
	
				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );
	
			}
	
			return new Vector3( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );
	
		};
	
		function CubicBezierCurve3( v0, v1, v2, v3 ) {
	
			Curve.call( this );
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		}
	
		CubicBezierCurve3.prototype = Object.create( Curve.prototype );
		CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
	
		CubicBezierCurve3.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	
			return new Vector3(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
				CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
			);
	
		};
	
		function QuadraticBezierCurve3( v0, v1, v2 ) {
	
			Curve.call( this );
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
	
		QuadraticBezierCurve3.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	
			return new Vector3(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y ),
				QuadraticBezier( t, v0.z, v1.z, v2.z )
			);
	
		};
	
		function LineCurve3( v1, v2 ) {
	
			Curve.call( this );
	
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		LineCurve3.prototype = Object.create( Curve.prototype );
		LineCurve3.prototype.constructor = LineCurve3;
	
		LineCurve3.prototype.getPoint = function ( t ) {
	
			if ( t === 1 ) {
	
				return this.v2.clone();
	
			}
	
			var vector = new Vector3();
	
			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );
	
			return vector;
	
		};
	
		function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
			EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
		}
	
		ArcCurve.prototype = Object.create( EllipseCurve.prototype );
		ArcCurve.prototype.constructor = ArcCurve;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		var SceneUtils = {
	
			createMultiMaterialObject: function ( geometry, materials ) {
	
				var group = new Group();
	
				for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
					group.add( new Mesh( geometry, materials[ i ] ) );
	
				}
	
				return group;
	
			},
	
			detach: function ( child, parent, scene ) {
	
				child.applyMatrix( parent.matrixWorld );
				parent.remove( child );
				scene.add( child );
	
			},
	
			attach: function ( child, scene, parent ) {
	
				child.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );
	
				scene.remove( child );
				parent.add( child );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Face4( a, b, c, d, normal, color, materialIndex ) {
	
			console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new Face3( a, b, c, normal, color, materialIndex );
	
		}
	
		var LineStrip = 0;
	
		var LinePieces = 1;
	
		function MeshFaceMaterial( materials ) {
	
			console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
			return materials;
	
		}
	
		function MultiMaterial( materials ) {
	
			if ( materials === undefined ) materials = [];
	
			console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
			materials.isMultiMaterial = true;
			materials.materials = materials;
			materials.clone = function () {
	
				return materials.slice();
	
			};
			return materials;
	
		}
	
		function PointCloud( geometry, material ) {
	
			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new Points( geometry, material );
	
		}
	
		function Particle( material ) {
	
			console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
			return new Sprite( material );
	
		}
	
		function ParticleSystem( geometry, material ) {
	
			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new Points( geometry, material );
	
		}
	
		function PointCloudMaterial( parameters ) {
	
			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
	
		}
	
		function ParticleBasicMaterial( parameters ) {
	
			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
	
		}
	
		function ParticleSystemMaterial( parameters ) {
	
			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
	
		}
	
		function Vertex( x, y, z ) {
	
			console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new Vector3( x, y, z );
	
		}
	
		//
	
		function DynamicBufferAttribute( array, itemSize ) {
	
			console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
			return new BufferAttribute( array, itemSize ).setDynamic( true );
	
		}
	
		function Int8Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
			return new Int8BufferAttribute( array, itemSize );
	
		}
	
		function Uint8Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
			return new Uint8BufferAttribute( array, itemSize );
	
		}
	
		function Uint8ClampedAttribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
			return new Uint8ClampedBufferAttribute( array, itemSize );
	
		}
	
		function Int16Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
			return new Int16BufferAttribute( array, itemSize );
	
		}
	
		function Uint16Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
			return new Uint16BufferAttribute( array, itemSize );
	
		}
	
		function Int32Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
			return new Int32BufferAttribute( array, itemSize );
	
		}
	
		function Uint32Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
			return new Uint32BufferAttribute( array, itemSize );
	
		}
	
		function Float32Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
			return new Float32BufferAttribute( array, itemSize );
	
		}
	
		function Float64Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
			return new Float64BufferAttribute( array, itemSize );
	
		}
	
		//
	
		Curve.create = function ( construct, getPoint ) {
	
			console.log( 'THREE.Curve.create() has been deprecated' );
	
			construct.prototype = Object.create( Curve.prototype );
			construct.prototype.constructor = construct;
			construct.prototype.getPoint = getPoint;
	
			return construct;
	
		};
	
		//
	
		function ClosedSplineCurve3( points ) {
	
			console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
			this.closed = true;
	
		}
	
		ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
	
		//
	
		function SplineCurve3( points ) {
	
			console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
	
		}
	
		SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
	
		//
	
		function Spline( points ) {
	
			console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
	
		}
	
		Spline.prototype = Object.create( CatmullRomCurve3.prototype );
	
		Object.assign( Spline.prototype, {
	
			initFromArray: function ( a ) {
	
				console.error( 'THREE.Spline: .initFromArray() has been removed.' );
	
			},
			getControlPointsArray: function ( optionalTarget ) {
	
				console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );
	
			},
			reparametrizeByArcLength: function ( samplingCoef ) {
	
				console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );
	
			}
	
		} );
	
		//
		function BoundingBoxHelper( object, color ) {
	
			console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
			return new BoxHelper( object, color );
	
		}
	
		function EdgesHelper( object, hex ) {
	
			console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
			return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
	
		}
	
		GridHelper.prototype.setColors = function () {
	
			console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );
	
		};
	
		SkeletonHelper.prototype.update = function () {
	
			console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );
			
		};
	
		function WireframeHelper( object, hex ) {
	
			console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
			return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
	
		}
	
		//
	
		function XHRLoader( manager ) {
	
			console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
			return new FileLoader( manager );
	
		}
	
		function BinaryTextureLoader( manager ) {
	
			console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
			return new DataTextureLoader( manager );
	
		}
	
		//
	
		Object.assign( Box2.prototype, {
	
			center: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
	
			},
			empty: function () {
	
				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
	
			},
			isIntersectionBox: function ( box ) {
	
				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
	
			},
			size: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
	
			}
		} );
	
		Object.assign( Box3.prototype, {
	
			center: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
	
			},
			empty: function () {
	
				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
	
			},
			isIntersectionBox: function ( box ) {
	
				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
	
			},
			isIntersectionSphere: function ( sphere ) {
	
				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
	
			},
			size: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
	
			}
		} );
	
		Line3.prototype.center = function ( optionalTarget ) {
	
			console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );
	
		};
	
		_Math.random16 = function () {
	
			console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();
	
		};
	
		Object.assign( Matrix3.prototype, {
	
			flattenToArrayOffset: function ( array, offset ) {
	
				console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );
	
			},
			multiplyVector3: function ( vector ) {
	
				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );
	
			},
			multiplyVector3Array: function ( a ) {
	
				console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.'  );
	
			},
			applyToBuffer: function( buffer, offset, length ) {
	
				console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
				return this.applyToBufferAttribute( buffer );
	
			},
			applyToVector3Array: function( array, offset, length ) {
	
				console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );
	
			}
	
		} );
	
		Object.assign( Matrix4.prototype, {
	
			extractPosition: function ( m ) {
	
				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );
	
			},
			flattenToArrayOffset: function ( array, offset ) {
	
				console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );
	
			},
			getPosition: function () {
	
				var v1;
	
				return function getPosition() {
	
					if ( v1 === undefined ) v1 = new Vector3();
					console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
					return v1.setFromMatrixColumn( this, 3 );
	
				};
	
			}(),
			setRotationFromQuaternion: function ( q ) {
	
				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );
	
			},
			multiplyToArray: function () {
	
				console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );
	
			},
			multiplyVector3: function ( vector ) {
	
				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
	
			},
			multiplyVector4: function ( vector ) {
	
				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
	
			},
			multiplyVector3Array: function ( a ) {
	
				console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.'  );
	
			},
			rotateAxis: function ( v ) {
	
				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );
	
			},
			crossVector: function ( vector ) {
	
				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
	
			},
			translate: function () {
	
				console.error( 'THREE.Matrix4: .translate() has been removed.' );
	
			},
			rotateX: function () {
	
				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
	
			},
			rotateY: function () {
	
				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
	
			},
			rotateZ: function () {
	
				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
	
			},
			rotateByAxis: function () {
	
				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
	
			},
			applyToBuffer: function( buffer, offset, length ) {
	
				console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
				return this.applyToBufferAttribute( buffer );
	
			},
			applyToVector3Array: function( array, offset, length ) {
	
				console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );
	
			},
			makeFrustum: function( left, right, bottom, top, near, far ) {
	
				console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
				return this.makePerspective( left, right, top, bottom, near, far );
	
			}
	
		} );
	
		Plane.prototype.isIntersectionLine = function ( line ) {
	
			console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
			return this.intersectsLine( line );
	
		};
	
		Quaternion.prototype.multiplyVector3 = function ( vector ) {
	
			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
	
		};
	
		Object.assign( Ray.prototype, {
	
			isIntersectionBox: function ( box ) {
	
				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
	
			},
			isIntersectionPlane: function ( plane ) {
	
				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );
	
			},
			isIntersectionSphere: function ( sphere ) {
	
				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
	
			}
	
		} );
	
		Object.assign( Shape.prototype, {
	
			extrude: function ( options ) {
	
				console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
				return new ExtrudeGeometry( this, options );
	
			},
			makeGeometry: function ( options ) {
	
				console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
				return new ShapeGeometry( this, options );
	
			}
	
		} );
	
		Object.assign( Vector2.prototype, {
	
			fromAttribute: function ( attribute, index, offset ) {
	
				console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );
	
			}
	
		} );
	
		Object.assign( Vector3.prototype, {
	
			setEulerFromRotationMatrix: function () {
	
				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
	
			},
			setEulerFromQuaternion: function () {
	
				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
	
			},
			getPositionFromMatrix: function ( m ) {
	
				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );
	
			},
			getScaleFromMatrix: function ( m ) {
	
				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );
	
			},
			getColumnFromMatrix: function ( index, matrix ) {
	
				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( matrix, index );
	
			},
			applyProjection: function ( m ) {
	
				console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
				return this.applyMatrix4( m );
	
			},
			fromAttribute: function ( attribute, index, offset ) {
	
				console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );
	
			}
	
		} );
	
		Object.assign( Vector4.prototype, {
	
			fromAttribute: function ( attribute, index, offset ) {
	
				console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );
	
			}
	
		} );
	
		//
	
		Geometry.prototype.computeTangents = function () {
	
			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );
	
		};
	
		Object.assign( Object3D.prototype, {
	
			getChildByName: function ( name ) {
	
				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );
	
			},
			renderDepth: function () {
	
				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
	
			},
			translate: function ( distance, axis ) {
	
				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );
	
			}
	
		} );
	
		Object.defineProperties( Object3D.prototype, {
	
			eulerOrder: {
				get: function () {
	
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					return this.rotation.order;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					this.rotation.order = value;
	
				}
			},
			useQuaternion: {
				get: function () {
	
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
				},
				set: function () {
	
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
				}
			}
	
		} );
	
		Object.defineProperties( LOD.prototype, {
	
			objects: {
				get: function () {
	
					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;
	
				}
			}
	
		} );
	
		Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {
	
			get: function () {
	
				console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
	
			},
			set: function () {
	
				console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
	
			}
	
		} );
	
		Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {
	
			get: function () {
	
				console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
				return this.arcLengthDivisions;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
				this.arcLengthDivisions = value;
	
			}
	
		} );
	
		//
	
		PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {
	
			console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
					"Use .setFocalLength and .filmGauge for a photographic setup." );
	
			if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
			this.setFocalLength( focalLength );
	
		};
	
		//
	
		Object.defineProperties( Light.prototype, {
			onlyShadow: {
				set: function () {
	
					console.warn( 'THREE.Light: .onlyShadow has been removed.' );
	
				}
			},
			shadowCameraFov: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
					this.shadow.camera.fov = value;
	
				}
			},
			shadowCameraLeft: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
					this.shadow.camera.left = value;
	
				}
			},
			shadowCameraRight: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
					this.shadow.camera.right = value;
	
				}
			},
			shadowCameraTop: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
					this.shadow.camera.top = value;
	
				}
			},
			shadowCameraBottom: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
					this.shadow.camera.bottom = value;
	
				}
			},
			shadowCameraNear: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
					this.shadow.camera.near = value;
	
				}
			},
			shadowCameraFar: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
					this.shadow.camera.far = value;
	
				}
			},
			shadowCameraVisible: {
				set: function () {
	
					console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
	
				}
			},
			shadowBias: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
					this.shadow.bias = value;
	
				}
			},
			shadowDarkness: {
				set: function () {
	
					console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
	
				}
			},
			shadowMapWidth: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
					this.shadow.mapSize.width = value;
	
				}
			},
			shadowMapHeight: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
					this.shadow.mapSize.height = value;
	
				}
			}
		} );
	
		//
	
		Object.defineProperties( BufferAttribute.prototype, {
	
			length: {
				get: function () {
	
					console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
					return this.array.length;
	
				}
			}
	
		} );
	
		Object.assign( BufferGeometry.prototype, {
	
			addIndex: function ( index ) {
	
				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );
	
			},
			addDrawCall: function ( start, count, indexOffset ) {
	
				if ( indexOffset !== undefined ) {
	
					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
	
				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );
	
			},
			clearDrawCalls: function () {
	
				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();
	
			},
			computeTangents: function () {
	
				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
	
			},
			computeOffsets: function () {
	
				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
	
			}
	
		} );
	
		Object.defineProperties( BufferGeometry.prototype, {
	
			drawcalls: {
				get: function () {
	
					console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
					return this.groups;
	
				}
			},
			offsets: {
				get: function () {
	
					console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
					return this.groups;
	
				}
			}
	
		} );
	
		//
	
		Object.defineProperties( Uniform.prototype, {
	
			dynamic: {
				set: function () {
	
					console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
	
				}
			},
			onUpdate: {
				value: function () {
	
					console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
					return this;
	
				}
			}
	
		} );
	
		//
	
		Object.defineProperties( Material.prototype, {
	
			wrapAround: {
				get: function () {
	
					console.warn( 'THREE.Material: .wrapAround has been removed.' );
	
				},
				set: function () {
	
					console.warn( 'THREE.Material: .wrapAround has been removed.' );
	
				}
			},
			wrapRGB: {
				get: function () {
	
					console.warn( 'THREE.Material: .wrapRGB has been removed.' );
					return new Color();
	
				}
			}
	
		} );
	
		Object.defineProperties( MeshPhongMaterial.prototype, {
	
			metal: {
				get: function () {
	
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
					return false;
	
				},
				set: function () {
	
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
	
				}
			}
	
		} );
	
		Object.defineProperties( ShaderMaterial.prototype, {
	
			derivatives: {
				get: function () {
	
					console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					return this.extensions.derivatives;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					this.extensions.derivatives = value;
	
				}
			}
	
		} );
	
		//
	
		Object.assign( WebGLRenderer.prototype, {
	
			getCurrentRenderTarget: function () {
	
				console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
				return this.getRenderTarget();
	
			},
	
			supportsFloatTextures: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );
	
			},
			supportsHalfFloatTextures: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );
	
			},
			supportsStandardDerivatives: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );
	
			},
			supportsCompressedTextureS3TC: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
			},
			supportsCompressedTexturePVRTC: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
			},
			supportsBlendMinMax: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );
	
			},
			supportsVertexTextures: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
				return this.capabilities.vertexTextures;
	
			},
			supportsInstancedArrays: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );
	
			},
			enableScissorTest: function ( boolean ) {
	
				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );
	
			},
			initMaterial: function () {
	
				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
	
			},
			addPrePlugin: function () {
	
				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
	
			},
			addPostPlugin: function () {
	
				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
	
			},
			updateShadowMap: function () {
	
				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
	
			}
	
		} );
	
		Object.defineProperties( WebGLRenderer.prototype, {
	
			shadowMapEnabled: {
				get: function () {
	
					return this.shadowMap.enabled;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					this.shadowMap.enabled = value;
	
				}
			},
			shadowMapType: {
				get: function () {
	
					return this.shadowMap.type;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					this.shadowMap.type = value;
	
				}
			},
			shadowMapCullFace: {
				get: function () {
	
					return this.shadowMap.cullFace;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					this.shadowMap.cullFace = value;
	
				}
			}
		} );
	
		Object.defineProperties( WebGLShadowMap.prototype, {
	
			cullFace: {
				get: function () {
	
					return this.renderReverseSided ? CullFaceFront : CullFaceBack;
	
				},
				set: function ( cullFace ) {
	
					var value = ( cullFace !== CullFaceBack );
					console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
					this.renderReverseSided = value;
	
				}
			}
	
		} );
	
		//
	
		Object.defineProperties( WebGLRenderTarget.prototype, {
	
			wrapS: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					return this.texture.wrapS;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					this.texture.wrapS = value;
	
				}
			},
			wrapT: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					return this.texture.wrapT;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					this.texture.wrapT = value;
	
				}
			},
			magFilter: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					return this.texture.magFilter;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					this.texture.magFilter = value;
	
				}
			},
			minFilter: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					return this.texture.minFilter;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					this.texture.minFilter = value;
	
				}
			},
			anisotropy: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					return this.texture.anisotropy;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					this.texture.anisotropy = value;
	
				}
			},
			offset: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					return this.texture.offset;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					this.texture.offset = value;
	
				}
			},
			repeat: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					return this.texture.repeat;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					this.texture.repeat = value;
	
				}
			},
			format: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					return this.texture.format;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					this.texture.format = value;
	
				}
			},
			type: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					return this.texture.type;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					this.texture.type = value;
	
				}
			},
			generateMipmaps: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					return this.texture.generateMipmaps;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					this.texture.generateMipmaps = value;
	
				}
			}
	
		} );
	
		//
	
		Audio.prototype.load = function ( file ) {
	
			console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
			var scope = this;
			var audioLoader = new AudioLoader();
			audioLoader.load( file, function ( buffer ) {
	
				scope.setBuffer( buffer );
	
			} );
			return this;
	
		};
	
		AudioAnalyser.prototype.getData = function () {
	
			console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
			return this.getFrequencyData();
	
		};
	
		//
	
		var GeometryUtils = {
	
			merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
				console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
				var matrix;
	
				if ( geometry2.isMesh ) {
	
					geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
					matrix = geometry2.matrix;
					geometry2 = geometry2.geometry;
	
				}
	
				geometry1.merge( geometry2, matrix, materialIndexOffset );
	
			},
	
			center: function ( geometry ) {
	
				console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
				return geometry.center();
	
			}
	
		};
	
		var ImageUtils = {
	
			crossOrigin: undefined,
	
			loadTexture: function ( url, mapping, onLoad, onError ) {
	
				console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
	
				var loader = new TextureLoader();
				loader.setCrossOrigin( this.crossOrigin );
	
				var texture = loader.load( url, onLoad, undefined, onError );
	
				if ( mapping ) texture.mapping = mapping;
	
				return texture;
	
			},
	
			loadTextureCube: function ( urls, mapping, onLoad, onError ) {
	
				console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
	
				var loader = new CubeTextureLoader();
				loader.setCrossOrigin( this.crossOrigin );
	
				var texture = loader.load( urls, onLoad, undefined, onError );
	
				if ( mapping ) texture.mapping = mapping;
	
				return texture;
	
			},
	
			loadCompressedTexture: function () {
	
				console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
	
			},
	
			loadCompressedTextureCube: function () {
	
				console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
	
			}
	
		};
	
		//
	
		function Projector() {
	
			console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
			this.projectVector = function ( vector, camera ) {
	
				console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
				vector.project( camera );
	
			};
	
			this.unprojectVector = function ( vector, camera ) {
	
				console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
				vector.unproject( camera );
	
			};
	
			this.pickingRay = function () {
	
				console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
			};
	
		}
	
		//
	
		function CanvasRenderer() {
	
			console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
	
			this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			this.clear = function () {};
			this.render = function () {};
			this.setClearColor = function () {};
			this.setSize = function () {};
	
		}
	
		exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
		exports.WebGLRenderTarget = WebGLRenderTarget;
		exports.WebGLRenderer = WebGLRenderer;
		exports.ShaderLib = ShaderLib;
		exports.UniformsLib = UniformsLib;
		exports.UniformsUtils = UniformsUtils;
		exports.ShaderChunk = ShaderChunk;
		exports.FogExp2 = FogExp2;
		exports.Fog = Fog;
		exports.Scene = Scene;
		exports.LensFlare = LensFlare;
		exports.Sprite = Sprite;
		exports.LOD = LOD;
		exports.SkinnedMesh = SkinnedMesh;
		exports.Skeleton = Skeleton;
		exports.Bone = Bone;
		exports.Mesh = Mesh;
		exports.LineSegments = LineSegments;
		exports.LineLoop = LineLoop;
		exports.Line = Line;
		exports.Points = Points;
		exports.Group = Group;
		exports.VideoTexture = VideoTexture;
		exports.DataTexture = DataTexture;
		exports.CompressedTexture = CompressedTexture;
		exports.CubeTexture = CubeTexture;
		exports.CanvasTexture = CanvasTexture;
		exports.DepthTexture = DepthTexture;
		exports.Texture = Texture;
		exports.CompressedTextureLoader = CompressedTextureLoader;
		exports.DataTextureLoader = DataTextureLoader;
		exports.CubeTextureLoader = CubeTextureLoader;
		exports.TextureLoader = TextureLoader;
		exports.ObjectLoader = ObjectLoader;
		exports.MaterialLoader = MaterialLoader;
		exports.BufferGeometryLoader = BufferGeometryLoader;
		exports.DefaultLoadingManager = DefaultLoadingManager;
		exports.LoadingManager = LoadingManager;
		exports.JSONLoader = JSONLoader;
		exports.ImageLoader = ImageLoader;
		exports.FontLoader = FontLoader;
		exports.FileLoader = FileLoader;
		exports.Loader = Loader;
		exports.Cache = Cache;
		exports.AudioLoader = AudioLoader;
		exports.SpotLightShadow = SpotLightShadow;
		exports.SpotLight = SpotLight;
		exports.PointLight = PointLight;
		exports.RectAreaLight = RectAreaLight;
		exports.HemisphereLight = HemisphereLight;
		exports.DirectionalLightShadow = DirectionalLightShadow;
		exports.DirectionalLight = DirectionalLight;
		exports.AmbientLight = AmbientLight;
		exports.LightShadow = LightShadow;
		exports.Light = Light;
		exports.StereoCamera = StereoCamera;
		exports.PerspectiveCamera = PerspectiveCamera;
		exports.OrthographicCamera = OrthographicCamera;
		exports.CubeCamera = CubeCamera;
		exports.ArrayCamera = ArrayCamera;
		exports.Camera = Camera;
		exports.AudioListener = AudioListener;
		exports.PositionalAudio = PositionalAudio;
		exports.AudioContext = AudioContext;
		exports.AudioAnalyser = AudioAnalyser;
		exports.Audio = Audio;
		exports.VectorKeyframeTrack = VectorKeyframeTrack;
		exports.StringKeyframeTrack = StringKeyframeTrack;
		exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
		exports.NumberKeyframeTrack = NumberKeyframeTrack;
		exports.ColorKeyframeTrack = ColorKeyframeTrack;
		exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
		exports.PropertyMixer = PropertyMixer;
		exports.PropertyBinding = PropertyBinding;
		exports.KeyframeTrack = KeyframeTrack;
		exports.AnimationUtils = AnimationUtils;
		exports.AnimationObjectGroup = AnimationObjectGroup;
		exports.AnimationMixer = AnimationMixer;
		exports.AnimationClip = AnimationClip;
		exports.Uniform = Uniform;
		exports.InstancedBufferGeometry = InstancedBufferGeometry;
		exports.BufferGeometry = BufferGeometry;
		exports.GeometryIdCount = GeometryIdCount;
		exports.Geometry = Geometry;
		exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
		exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
		exports.InterleavedBuffer = InterleavedBuffer;
		exports.InstancedBufferAttribute = InstancedBufferAttribute;
		exports.Face3 = Face3;
		exports.Object3D = Object3D;
		exports.Raycaster = Raycaster;
		exports.Layers = Layers;
		exports.EventDispatcher = EventDispatcher;
		exports.Clock = Clock;
		exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
		exports.LinearInterpolant = LinearInterpolant;
		exports.DiscreteInterpolant = DiscreteInterpolant;
		exports.CubicInterpolant = CubicInterpolant;
		exports.Interpolant = Interpolant;
		exports.Triangle = Triangle;
		exports.Math = _Math;
		exports.Spherical = Spherical;
		exports.Cylindrical = Cylindrical;
		exports.Plane = Plane;
		exports.Frustum = Frustum;
		exports.Sphere = Sphere;
		exports.Ray = Ray;
		exports.Matrix4 = Matrix4;
		exports.Matrix3 = Matrix3;
		exports.Box3 = Box3;
		exports.Box2 = Box2;
		exports.Line3 = Line3;
		exports.Euler = Euler;
		exports.Vector4 = Vector4;
		exports.Vector3 = Vector3;
		exports.Vector2 = Vector2;
		exports.Quaternion = Quaternion;
		exports.Color = Color;
		exports.MorphBlendMesh = MorphBlendMesh;
		exports.ImmediateRenderObject = ImmediateRenderObject;
		exports.VertexNormalsHelper = VertexNormalsHelper;
		exports.SpotLightHelper = SpotLightHelper;
		exports.SkeletonHelper = SkeletonHelper;
		exports.PointLightHelper = PointLightHelper;
		exports.RectAreaLightHelper = RectAreaLightHelper;
		exports.HemisphereLightHelper = HemisphereLightHelper;
		exports.GridHelper = GridHelper;
		exports.PolarGridHelper = PolarGridHelper;
		exports.FaceNormalsHelper = FaceNormalsHelper;
		exports.DirectionalLightHelper = DirectionalLightHelper;
		exports.CameraHelper = CameraHelper;
		exports.BoxHelper = BoxHelper;
		exports.ArrowHelper = ArrowHelper;
		exports.AxisHelper = AxisHelper;
		exports.CatmullRomCurve3 = CatmullRomCurve3;
		exports.CubicBezierCurve3 = CubicBezierCurve3;
		exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
		exports.LineCurve3 = LineCurve3;
		exports.ArcCurve = ArcCurve;
		exports.EllipseCurve = EllipseCurve;
		exports.SplineCurve = SplineCurve;
		exports.CubicBezierCurve = CubicBezierCurve;
		exports.QuadraticBezierCurve = QuadraticBezierCurve;
		exports.LineCurve = LineCurve;
		exports.Shape = Shape;
		exports.Path = Path;
		exports.ShapePath = ShapePath;
		exports.Font = Font;
		exports.CurvePath = CurvePath;
		exports.Curve = Curve;
		exports.ShapeUtils = ShapeUtils;
		exports.SceneUtils = SceneUtils;
		exports.WireframeGeometry = WireframeGeometry;
		exports.ParametricGeometry = ParametricGeometry;
		exports.ParametricBufferGeometry = ParametricBufferGeometry;
		exports.TetrahedronGeometry = TetrahedronGeometry;
		exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
		exports.OctahedronGeometry = OctahedronGeometry;
		exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
		exports.IcosahedronGeometry = IcosahedronGeometry;
		exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
		exports.DodecahedronGeometry = DodecahedronGeometry;
		exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
		exports.PolyhedronGeometry = PolyhedronGeometry;
		exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
		exports.TubeGeometry = TubeGeometry;
		exports.TubeBufferGeometry = TubeBufferGeometry;
		exports.TorusKnotGeometry = TorusKnotGeometry;
		exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
		exports.TorusGeometry = TorusGeometry;
		exports.TorusBufferGeometry = TorusBufferGeometry;
		exports.TextGeometry = TextGeometry;
		exports.TextBufferGeometry = TextBufferGeometry;
		exports.SphereGeometry = SphereGeometry;
		exports.SphereBufferGeometry = SphereBufferGeometry;
		exports.RingGeometry = RingGeometry;
		exports.RingBufferGeometry = RingBufferGeometry;
		exports.PlaneGeometry = PlaneGeometry;
		exports.PlaneBufferGeometry = PlaneBufferGeometry;
		exports.LatheGeometry = LatheGeometry;
		exports.LatheBufferGeometry = LatheBufferGeometry;
		exports.ShapeGeometry = ShapeGeometry;
		exports.ShapeBufferGeometry = ShapeBufferGeometry;
		exports.ExtrudeGeometry = ExtrudeGeometry;
		exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
		exports.EdgesGeometry = EdgesGeometry;
		exports.ConeGeometry = ConeGeometry;
		exports.ConeBufferGeometry = ConeBufferGeometry;
		exports.CylinderGeometry = CylinderGeometry;
		exports.CylinderBufferGeometry = CylinderBufferGeometry;
		exports.CircleGeometry = CircleGeometry;
		exports.CircleBufferGeometry = CircleBufferGeometry;
		exports.BoxGeometry = BoxGeometry;
		exports.BoxBufferGeometry = BoxBufferGeometry;
		exports.ShadowMaterial = ShadowMaterial;
		exports.SpriteMaterial = SpriteMaterial;
		exports.RawShaderMaterial = RawShaderMaterial;
		exports.ShaderMaterial = ShaderMaterial;
		exports.PointsMaterial = PointsMaterial;
		exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
		exports.MeshStandardMaterial = MeshStandardMaterial;
		exports.MeshPhongMaterial = MeshPhongMaterial;
		exports.MeshToonMaterial = MeshToonMaterial;
		exports.MeshNormalMaterial = MeshNormalMaterial;
		exports.MeshLambertMaterial = MeshLambertMaterial;
		exports.MeshDepthMaterial = MeshDepthMaterial;
		exports.MeshBasicMaterial = MeshBasicMaterial;
		exports.LineDashedMaterial = LineDashedMaterial;
		exports.LineBasicMaterial = LineBasicMaterial;
		exports.Material = Material;
		exports.Float64BufferAttribute = Float64BufferAttribute;
		exports.Float32BufferAttribute = Float32BufferAttribute;
		exports.Uint32BufferAttribute = Uint32BufferAttribute;
		exports.Int32BufferAttribute = Int32BufferAttribute;
		exports.Uint16BufferAttribute = Uint16BufferAttribute;
		exports.Int16BufferAttribute = Int16BufferAttribute;
		exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
		exports.Uint8BufferAttribute = Uint8BufferAttribute;
		exports.Int8BufferAttribute = Int8BufferAttribute;
		exports.BufferAttribute = BufferAttribute;
		exports.REVISION = REVISION;
		exports.MOUSE = MOUSE;
		exports.CullFaceNone = CullFaceNone;
		exports.CullFaceBack = CullFaceBack;
		exports.CullFaceFront = CullFaceFront;
		exports.CullFaceFrontBack = CullFaceFrontBack;
		exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
		exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
		exports.BasicShadowMap = BasicShadowMap;
		exports.PCFShadowMap = PCFShadowMap;
		exports.PCFSoftShadowMap = PCFSoftShadowMap;
		exports.FrontSide = FrontSide;
		exports.BackSide = BackSide;
		exports.DoubleSide = DoubleSide;
		exports.FlatShading = FlatShading;
		exports.SmoothShading = SmoothShading;
		exports.NoColors = NoColors;
		exports.FaceColors = FaceColors;
		exports.VertexColors = VertexColors;
		exports.NoBlending = NoBlending;
		exports.NormalBlending = NormalBlending;
		exports.AdditiveBlending = AdditiveBlending;
		exports.SubtractiveBlending = SubtractiveBlending;
		exports.MultiplyBlending = MultiplyBlending;
		exports.CustomBlending = CustomBlending;
		exports.AddEquation = AddEquation;
		exports.SubtractEquation = SubtractEquation;
		exports.ReverseSubtractEquation = ReverseSubtractEquation;
		exports.MinEquation = MinEquation;
		exports.MaxEquation = MaxEquation;
		exports.ZeroFactor = ZeroFactor;
		exports.OneFactor = OneFactor;
		exports.SrcColorFactor = SrcColorFactor;
		exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
		exports.SrcAlphaFactor = SrcAlphaFactor;
		exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
		exports.DstAlphaFactor = DstAlphaFactor;
		exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
		exports.DstColorFactor = DstColorFactor;
		exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
		exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
		exports.NeverDepth = NeverDepth;
		exports.AlwaysDepth = AlwaysDepth;
		exports.LessDepth = LessDepth;
		exports.LessEqualDepth = LessEqualDepth;
		exports.EqualDepth = EqualDepth;
		exports.GreaterEqualDepth = GreaterEqualDepth;
		exports.GreaterDepth = GreaterDepth;
		exports.NotEqualDepth = NotEqualDepth;
		exports.MultiplyOperation = MultiplyOperation;
		exports.MixOperation = MixOperation;
		exports.AddOperation = AddOperation;
		exports.NoToneMapping = NoToneMapping;
		exports.LinearToneMapping = LinearToneMapping;
		exports.ReinhardToneMapping = ReinhardToneMapping;
		exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
		exports.CineonToneMapping = CineonToneMapping;
		exports.UVMapping = UVMapping;
		exports.CubeReflectionMapping = CubeReflectionMapping;
		exports.CubeRefractionMapping = CubeRefractionMapping;
		exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
		exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
		exports.SphericalReflectionMapping = SphericalReflectionMapping;
		exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
		exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
		exports.RepeatWrapping = RepeatWrapping;
		exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
		exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
		exports.NearestFilter = NearestFilter;
		exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
		exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
		exports.LinearFilter = LinearFilter;
		exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
		exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
		exports.UnsignedByteType = UnsignedByteType;
		exports.ByteType = ByteType;
		exports.ShortType = ShortType;
		exports.UnsignedShortType = UnsignedShortType;
		exports.IntType = IntType;
		exports.UnsignedIntType = UnsignedIntType;
		exports.FloatType = FloatType;
		exports.HalfFloatType = HalfFloatType;
		exports.UnsignedShort4444Type = UnsignedShort4444Type;
		exports.UnsignedShort5551Type = UnsignedShort5551Type;
		exports.UnsignedShort565Type = UnsignedShort565Type;
		exports.UnsignedInt248Type = UnsignedInt248Type;
		exports.AlphaFormat = AlphaFormat;
		exports.RGBFormat = RGBFormat;
		exports.RGBAFormat = RGBAFormat;
		exports.LuminanceFormat = LuminanceFormat;
		exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
		exports.RGBEFormat = RGBEFormat;
		exports.DepthFormat = DepthFormat;
		exports.DepthStencilFormat = DepthStencilFormat;
		exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
		exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
		exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
		exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
		exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
		exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
		exports.RGB_ETC1_Format = RGB_ETC1_Format;
		exports.LoopOnce = LoopOnce;
		exports.LoopRepeat = LoopRepeat;
		exports.LoopPingPong = LoopPingPong;
		exports.InterpolateDiscrete = InterpolateDiscrete;
		exports.InterpolateLinear = InterpolateLinear;
		exports.InterpolateSmooth = InterpolateSmooth;
		exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
		exports.ZeroSlopeEnding = ZeroSlopeEnding;
		exports.WrapAroundEnding = WrapAroundEnding;
		exports.TrianglesDrawMode = TrianglesDrawMode;
		exports.TriangleStripDrawMode = TriangleStripDrawMode;
		exports.TriangleFanDrawMode = TriangleFanDrawMode;
		exports.LinearEncoding = LinearEncoding;
		exports.sRGBEncoding = sRGBEncoding;
		exports.GammaEncoding = GammaEncoding;
		exports.RGBEEncoding = RGBEEncoding;
		exports.LogLuvEncoding = LogLuvEncoding;
		exports.RGBM7Encoding = RGBM7Encoding;
		exports.RGBM16Encoding = RGBM16Encoding;
		exports.RGBDEncoding = RGBDEncoding;
		exports.BasicDepthPacking = BasicDepthPacking;
		exports.RGBADepthPacking = RGBADepthPacking;
		exports.CubeGeometry = BoxGeometry;
		exports.Face4 = Face4;
		exports.LineStrip = LineStrip;
		exports.LinePieces = LinePieces;
		exports.MeshFaceMaterial = MeshFaceMaterial;
		exports.MultiMaterial = MultiMaterial;
		exports.PointCloud = PointCloud;
		exports.Particle = Particle;
		exports.ParticleSystem = ParticleSystem;
		exports.PointCloudMaterial = PointCloudMaterial;
		exports.ParticleBasicMaterial = ParticleBasicMaterial;
		exports.ParticleSystemMaterial = ParticleSystemMaterial;
		exports.Vertex = Vertex;
		exports.DynamicBufferAttribute = DynamicBufferAttribute;
		exports.Int8Attribute = Int8Attribute;
		exports.Uint8Attribute = Uint8Attribute;
		exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
		exports.Int16Attribute = Int16Attribute;
		exports.Uint16Attribute = Uint16Attribute;
		exports.Int32Attribute = Int32Attribute;
		exports.Uint32Attribute = Uint32Attribute;
		exports.Float32Attribute = Float32Attribute;
		exports.Float64Attribute = Float64Attribute;
		exports.ClosedSplineCurve3 = ClosedSplineCurve3;
		exports.SplineCurve3 = SplineCurve3;
		exports.Spline = Spline;
		exports.BoundingBoxHelper = BoundingBoxHelper;
		exports.EdgesHelper = EdgesHelper;
		exports.WireframeHelper = WireframeHelper;
		exports.XHRLoader = XHRLoader;
		exports.BinaryTextureLoader = BinaryTextureLoader;
		exports.GeometryUtils = GeometryUtils;
		exports.ImageUtils = ImageUtils;
		exports.Projector = Projector;
		exports.CanvasRenderer = CanvasRenderer;
	
		Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ }),
/* 78 */
/***/ (function(module, exports) {

	/**
	 * @author aleeper / http://adamleeper.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author gero3 / https://github.com/gero3
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.
	 *
	 * Supports both binary and ASCII encoded files, with automatic detection of type.
	 *
	 * The loader returns a non-indexed buffer geometry.
	 *
	 * Limitations:
	 *  Binary decoding supports "Magics" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).
	 *  There is perhaps some question as to how valid it is to always assume little-endian-ness.
	 *  ASCII decoding assumes file is UTF-8.
	 *
	 * Usage:
	 *  var loader = new THREE.STLLoader();
	 *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {
	 *    scene.add( new THREE.Mesh( geometry ) );
	 *  });
	 *
	 * For binary STLs geometry might contain colors for vertices. To use it:
	 *  // use the same code to load STL as above
	 *  if (geometry.hasColors) {
	 *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });
	 *  } else { .... }
	 *  var mesh = new THREE.Mesh( geometry, material );
	 */
	
	 module.exports = function (THREE) {
	
	   var STLLoader = function ( manager ) {
	
	   	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	   };
	
	   STLLoader.prototype = {
	
	   	constructor: THREE.STLLoader,
	
	   	load: function ( url, onLoad, onProgress, onError ) {
	
	   		var scope = this;
	
	   		var loader = new THREE.FileLoader( scope.manager );
	   		loader.setResponseType( 'arraybuffer' );
	   		loader.load( url, function ( text ) {
	
	   			onLoad( scope.parse( text ) );
	
	   		}, onProgress, onError );
	
	   	},
	
	   	parse: function ( data ) {
	
	   		var isBinary = function () {
	
	   			var expect, face_size, n_faces, reader;
	   			reader = new DataView( binData );
	   			face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );
	   			n_faces = reader.getUint32( 80, true );
	   			expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );
	
	   			if ( expect === reader.byteLength ) {
	
	   				return true;
	
	   			}
	
	   			// An ASCII STL data must begin with 'solid ' as the first six bytes.
	   			// However, ASCII STLs lacking the SPACE after the 'd' are known to be
	   			// plentiful.  So, check the first 5 bytes for 'solid'.
	
	   			// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'
	   			var solid = [ 115, 111, 108, 105, 100 ];
	
	   			for ( var i = 0; i < 5; i ++ ) {
	
	   				// If solid[ i ] does not match the i-th byte, then it is not an
	   				// ASCII STL; hence, it is binary and return true.
	
	   				if ( solid[ i ] != reader.getUint8( i, false ) ) return true;
	
	    			}
	
	   			// First 5 bytes read "solid"; declare it to be an ASCII STL
	   			return false;
	
	   		};
	
	   		var binData = this.ensureBinary( data );
	
	   		return isBinary() ? this.parseBinary( binData ) : this.parseASCII( this.ensureString( data ) );
	
	   	},
	
	   	parseBinary: function ( data ) {
	
	   		var reader = new DataView( data );
	   		var faces = reader.getUint32( 80, true );
	
	   		var r, g, b, hasColors = false, colors;
	   		var defaultR, defaultG, defaultB, alpha;
	
	   		// process STL header
	   		// check for default color in header ("COLOR=rgba" sequence).
	
	   		for ( var index = 0; index < 80 - 10; index ++ ) {
	
	   			if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&
	   				( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&
	   				( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {
	
	   				hasColors = true;
	   				colors = [];
	
	   				defaultR = reader.getUint8( index + 6 ) / 255;
	   				defaultG = reader.getUint8( index + 7 ) / 255;
	   				defaultB = reader.getUint8( index + 8 ) / 255;
	   				alpha = reader.getUint8( index + 9 ) / 255;
	
	   			}
	
	   		}
	
	   		var dataOffset = 84;
	   		var faceLength = 12 * 4 + 2;
	
	   		var geometry = new THREE.BufferGeometry();
	
	   		var vertices = [];
	   		var normals = [];
	
	   		for ( var face = 0; face < faces; face ++ ) {
	
	   			var start = dataOffset + face * faceLength;
	   			var normalX = reader.getFloat32( start, true );
	   			var normalY = reader.getFloat32( start + 4, true );
	   			var normalZ = reader.getFloat32( start + 8, true );
	
	   			if ( hasColors ) {
	
	   				var packedColor = reader.getUint16( start + 48, true );
	
	   				if ( ( packedColor & 0x8000 ) === 0 ) {
	
	   					// facet has its own unique color
	
	   					r = ( packedColor & 0x1F ) / 31;
	   					g = ( ( packedColor >> 5 ) & 0x1F ) / 31;
	   					b = ( ( packedColor >> 10 ) & 0x1F ) / 31;
	
	   				} else {
	
	   					r = defaultR;
	   					g = defaultG;
	   					b = defaultB;
	
	   				}
	
	   			}
	
	   			for ( var i = 1; i <= 3; i ++ ) {
	
	   				var vertexstart = start + i * 12;
	
	   				vertices.push( reader.getFloat32( vertexstart, true ) );
	   				vertices.push( reader.getFloat32( vertexstart + 4, true ) );
	   				vertices.push( reader.getFloat32( vertexstart + 8, true ) );
	
	   				normals.push( normalX, normalY, normalZ );
	
	   				if ( hasColors ) {
	
	   					colors.push( r, g, b );
	
	   				}
	
	   			}
	
	   		}
	
	   		geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( vertices ), 3 ) );
	   		geometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( normals ), 3 ) );
	
	   		if ( hasColors ) {
	
	   			geometry.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( colors ), 3 ) );
	   			geometry.hasColors = true;
	   			geometry.alpha = alpha;
	
	   		}
	
	   		return geometry;
	
	   	},
	
	   	parseASCII: function ( data ) {
	
	   		var geometry, length, patternFace, patternNormal, patternVertex, result, text;
	   		geometry = new THREE.BufferGeometry();
	   		patternFace = /facet([\s\S]*?)endfacet/g;
	
	   		var vertices = [];
	   		var normals = [];
	
	   		var normal = new THREE.Vector3();
	
	   		while ( ( result = patternFace.exec( data ) ) !== null ) {
	
	   			text = result[ 0 ];
	   			patternNormal = /normal[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;
	
	   			while ( ( result = patternNormal.exec( text ) ) !== null ) {
	
	   				normal.x = parseFloat( result[ 1 ] );
	   				normal.y = parseFloat( result[ 3 ] );
	   				normal.z = parseFloat( result[ 5 ] );
	
	   			}
	
	   			patternVertex = /vertex[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;
	
	   			while ( ( result = patternVertex.exec( text ) ) !== null ) {
	
	   				vertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) );
	   				normals.push( normal.x, normal.y, normal.z );
	
	   			}
	
	   		}
	
	   		geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( vertices ), 3 ) );
	   		geometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( normals ), 3 ) );
	
	   		return geometry;
	
	   	},
	
	   	ensureString: function ( buf ) {
	
	   		if ( typeof buf !== "string" ) {
	
	   			var array_buffer = new Uint8Array( buf );
	   			var strArray = [];
	   			for ( var i = 0; i < buf.byteLength; i ++ ) {
	
	   				strArray.push(String.fromCharCode( array_buffer[ i ] )); // implicitly assumes little-endian
	
	   			}
	   			return strArray.join('');
	
	   		} else {
	
	   			return buf;
	
	   		}
	
	   	},
	
	   	ensureBinary: function ( buf ) {
	
	   		if ( typeof buf === "string" ) {
	
	   			var array_buffer = new Uint8Array( buf.length );
	   			for ( var i = 0; i < buf.length; i ++ ) {
	
	   				array_buffer[ i ] = buf.charCodeAt( i ) & 0xff; // implicitly assumes little-endian
	
	   			}
	   			return array_buffer.buffer || array_buffer;
	
	   		} else {
	
	   			return buf;
	
	   		}
	
	   	}
	
	   }
	
	   return STLLoader
	 }


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var es6_promise_1 = __webpack_require__(80);
	es6_promise_1.polyfill();
	var SponsorList = (function (_super) {
	    __extends(SponsorList, _super);
	    function SponsorList(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            year: props.year || 2018,
	            sponsors: [],
	        };
	        _this.getSponsors(_this.state.year);
	        return _this;
	    }
	    SponsorList.prototype.componentWillReceiveProps = function (nextProps) {
	        var nextYear = nextProps.year || 2018;
	        var year = this.props.year || this.state.year;
	        if (nextYear != year) {
	            year = nextYear;
	            this.getSponsors(year);
	        }
	    };
	    SponsorList.prototype.getSponsors = function (year) {
	        var _this = this;
	        fetch("/api/v1/sponsors/" + year).then(function (r) { return r.json(); }).then(function (r) {
	            _this.setState({
	                year: year,
	                sponsors: r,
	            });
	        });
	    };
	    SponsorList.prototype.render = function () {
	        var sponsors = this.state.sponsors.map(function (sponsor, i) {
	            return (React.createElement("div", { key: i, className: "sponsor" },
	                React.createElement("a", { href: sponsor.link, className: "sponsor-adblock-link" },
	                    React.createElement("img", { src: sponsor.logo, title: sponsor.name }),
	                    sponsor.logo_dark ? React.createElement("img", { src: sponsor.logo_dark, title: sponsor.name }) : null),
	                React.createElement("div", { className: "sponsor-adblock-text" }, sponsor.short_text)));
	        });
	        return (React.createElement("div", { className: "sponsors" }, sponsors));
	    };
	    return SponsorList;
	}(React.Component));
	exports.SponsorList = SponsorList;
	exports.default = SponsorList;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.1.1
	 */
	
	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.ES6Promise = factory());
	}(this, (function () { 'use strict';
	
	function objectOrFunction(x) {
	  var type = typeof x;
	  return x !== null && (type === 'object' || type === 'function');
	}
	
	function isFunction(x) {
	  return typeof x === 'function';
	}
	
	var _isArray = undefined;
	if (Array.isArray) {
	  _isArray = Array.isArray;
	} else {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	}
	
	var isArray = _isArray;
	
	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;
	
	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};
	
	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}
	
	function setAsap(asapFn) {
	  asap = asapFn;
	}
	
	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';
	
	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}
	
	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }
	
	  return useSetTimeout();
	}
	
	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });
	
	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}
	
	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}
	
	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}
	
	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];
	
	    callback(arg);
	
	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }
	
	  len = 0;
	}
	
	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(81);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}
	
	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}
	
	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;
	
	  var parent = this;
	
	  var child = new this.constructor(noop);
	
	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }
	
	  var _state = parent._state;
	
	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }
	
	  return child;
	}
	
	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.resolve(1);
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve$1(object) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }
	
	  var promise = new Constructor(noop);
	  resolve(promise, object);
	  return promise;
	}
	
	var PROMISE_ID = Math.random().toString(36).substring(16);
	
	function noop() {}
	
	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	
	var GET_THEN_ERROR = new ErrorObject();
	
	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}
	
	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}
	
	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}
	
	function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then$$1.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}
	
	function handleForeignThenable(promise, thenable, then$$1) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then$$1, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	
	      reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	    if (!sealed && error) {
	      sealed = true;
	      reject(promise, error);
	    }
	  }, promise);
	}
	
	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return resolve(promise, value);
	    }, function (reason) {
	      return reject(promise, reason);
	    });
	  }
	}
	
	function handleMaybeThenable(promise, maybeThenable, then$$1) {
	  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$1 === GET_THEN_ERROR) {
	      reject(promise, GET_THEN_ERROR.error);
	      GET_THEN_ERROR.error = null;
	    } else if (then$$1 === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$1)) {
	      handleForeignThenable(promise, maybeThenable, then$$1);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}
	
	function resolve(promise, value) {
	  if (promise === value) {
	    reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}
	
	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }
	
	  publish(promise);
	}
	
	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	
	  promise._result = value;
	  promise._state = FULFILLED;
	
	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}
	
	function reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;
	
	  asap(publishRejection, promise);
	}
	
	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;
	
	  parent._onerror = null;
	
	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;
	
	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}
	
	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;
	
	  if (subscribers.length === 0) {
	    return;
	  }
	
	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;
	
	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];
	
	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }
	
	  promise._subscribers.length = 0;
	}
	
	function ErrorObject() {
	  this.error = null;
	}
	
	var TRY_CATCH_ERROR = new ErrorObject();
	
	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}
	
	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;
	
	  if (hasCallback) {
	    value = tryCatch(callback, detail);
	
	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value.error = null;
	    } else {
	      succeeded = true;
	    }
	
	    if (promise === value) {
	      reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }
	
	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      resolve(promise, value);
	    } else if (failed) {
	      reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      reject(promise, value);
	    }
	}
	
	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      resolve(promise, value);
	    }, function rejectPromise(reason) {
	      reject(promise, reason);
	    });
	  } catch (e) {
	    reject(promise, e);
	  }
	}
	
	var id = 0;
	function nextId() {
	  return id++;
	}
	
	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}
	
	function Enumerator$1(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);
	
	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }
	
	  if (isArray(input)) {
	    this.length = input.length;
	    this._remaining = input.length;
	
	    this._result = new Array(this.length);
	
	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate(input);
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    reject(this.promise, validationError());
	  }
	}
	
	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	}
	
	Enumerator$1.prototype._enumerate = function (input) {
	  for (var i = 0; this._state === PENDING && i < input.length; i++) {
	    this._eachEntry(input[i], i);
	  }
	};
	
	Enumerator$1.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$1 = c.resolve;
	
	  if (resolve$$1 === resolve$1) {
	    var _then = getThen(entry);
	
	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise$2) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$1) {
	        return resolve$$1(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$1(entry), i);
	  }
	};
	
	Enumerator$1.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;
	
	  if (promise._state === PENDING) {
	    this._remaining--;
	
	    if (state === REJECTED) {
	      reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }
	
	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};
	
	Enumerator$1.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;
	
	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};
	
	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```
	
	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```
	
	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all$1(entries) {
	  return new Enumerator$1(this, entries).promise;
	}
	
	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.
	
	  Example:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```
	
	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```
	
	  An example real-world use case is implementing timeouts:
	
	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```
	
	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race$1(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}
	
	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject$1(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  reject(promise, reason);
	  return promise;
	}
	
	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}
	
	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}
	
	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.
	
	  Terminology
	  -----------
	
	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.
	
	  A promise can be in one of three states: pending, fulfilled, or rejected.
	
	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.
	
	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.
	
	
	  Basic Usage:
	  ------------
	
	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);
	
	    // on failure
	    reject(reason);
	  });
	
	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Advanced Usage:
	  ---------------
	
	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.
	
	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();
	
	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();
	
	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }
	
	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Unlike callbacks, promises are great composable primitives.
	
	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON
	
	    return values;
	  });
	  ```
	
	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise$2(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];
	
	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();
	  }
	}
	
	Promise$2.all = all$1;
	Promise$2.race = race$1;
	Promise$2.resolve = resolve$1;
	Promise$2.reject = reject$1;
	Promise$2._setScheduler = setScheduler;
	Promise$2._setAsap = setAsap;
	Promise$2._asap = asap;
	
	Promise$2.prototype = {
	  constructor: Promise$2,
	
	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,
	
	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};
	
	/*global self*/
	function polyfill$1() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }
	
	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }
	
	    local.Promise = Promise$2;
	}
	
	// Strange compat..
	Promise$2.polyfill = polyfill$1;
	Promise$2.Promise = Promise$2;
	
	return Promise$2;

	})));

	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), (function() { return this; }())))

/***/ }),
/* 81 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var react_router_1 = __webpack_require__(5);
	var commonmark_1 = __webpack_require__(83);
	var Katex = __webpack_require__(104);
	var es6_promise_1 = __webpack_require__(80);
	es6_promise_1.polyfill();
	var PageLayout_1 = __webpack_require__(72);
	var breadcrumb_1 = __webpack_require__(129);
	var blogArticle_1 = __webpack_require__(130);
	var BlogPage = (function (_super) {
	    __extends(BlogPage, _super);
	    function BlogPage(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            searchValue: 'e',
	            tagValues: [],
	            posts: [],
	            viewMode: 'big',
	        };
	        _this.parser = new commonmark_1.Parser();
	        _this.renderer = new commonmark_1.HtmlRenderer();
	        _this.showAllPosts = true;
	        _this.renderedTex = false;
	        if (_this.props.params && _this.props.params.post) {
	        }
	        else {
	            if (_this.props.params && _this.props.params.tags)
	                _this.state.tagValues = _this.props.params.tags.split(',');
	            _this.fetchPosts('/api/v1/posts/all');
	        }
	        return _this;
	    }
	    BlogPage.prototype.componentDidUpdate = function (prevProp, prevState) {
	        this.renderTex();
	    };
	    BlogPage.prototype.renderTex = function () {
	        if (!this.renderedTex) {
	            var refs = this.refs;
	            for (var i = 0; i < this.state.posts.length; i++) {
	                this.renderedTex = true;
	                var ref = refs["post-" + i];
	                if (ref) {
	                    for (var _i = 0, _a = ref.children; _i < _a.length; _i++) {
	                        var child = _a[_i];
	                        if (child.tagName === 'TEX')
	                            Katex.render(child.innerText, child);
	                        else {
	                            for (var _b = 0, _c = child.children; _b < _c.length; _b++) {
	                                var subchild = _c[_b];
	                                if (subchild.tagName === 'TEX')
	                                    Katex.render(subchild.innerText, subchild);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    };
	    BlogPage.prototype.fetchPosts = function (url) {
	        var _this = this;
	        fetch(url)
	            .then(function (r) { return r.json(); })
	            .then(function (r) {
	            r = r.map(function (p) {
	                p.attributes['dateFormatted'] = _this.formatDate(p.attributes.date, 'dag DD/MM/YY');
	                p.attributes['categoriesList'] = p.attributes.categories.split(" ");
	                p['parsedBody'] = _this.parser.parse(p.body);
	                p['renderedFirstChild'] = _this.renderer.render(p.parsedBody._firstChild);
	                p['renderedBody'] = _this.renderer.render(p.parsedBody);
	                p['renderedBodySearch'] = p['renderedBody'];
	                return p;
	            });
	            _this.setState({
	                posts: r.sort(function (a, b) { return a.file > b.file ? -1 : 1; })
	            });
	        })
	            .catch(function (err) { return console.error('Could not fetch file from: ' + url); });
	    };
	    BlogPage.prototype.componentWillReceiveProps = function (nextProps) {
	        if (this.props.params !== nextProps.params && nextProps.params.tags) {
	            this.state.tagValues = nextProps.params.tags.split(',');
	        }
	    };
	    BlogPage.prototype.addTagToFilterHandler = function (evt) {
	        var tag = evt.target.innerText;
	        var tags = this.state.tagValues;
	        var index = tags.indexOf(tag);
	        if (index === -1)
	            tags.push(tag);
	        else
	            tags.splice(index, 1);
	        this.setState({
	            tagValues: tags
	        });
	    };
	    BlogPage.prototype.filterByTags = function (filter, el) {
	        if (filter.length) {
	            for (var _i = 0, filter_1 = filter; _i < filter_1.length; _i++) {
	                var val = filter_1[_i];
	                if (el.attributes.categoriesList.indexOf(val) !== -1)
	                    return true;
	            }
	            return false;
	        }
	        return true;
	    };
	    BlogPage.prototype.filterBySearch = function (filter, el, keys) {
	        var prop;
	        if (filter.length < 2) {
	            for (var key in keys) {
	                prop = keys[key];
	                if (el.hasOwnProperty(prop)) {
	                    el[prop] = el[prop].replace(/<\/?found>/g, '');
	                }
	                else if (el.attributes.hasOwnProperty(prop)) {
	                    el.attributes[prop] = el.attributes[prop].replace(/<\/?found>/g, '');
	                }
	            }
	            return true;
	        }
	        var re = new RegExp(filter, 'i');
	        var rer = new RegExp("(.)(" + filter + ")(.{0,2})", 'ig');
	        var hasFound = false;
	        for (var key in keys) {
	            prop = keys[key];
	            if (el.hasOwnProperty(prop)) {
	                el[prop] = el[prop].replace(/<\/?found>/g, '');
	                if (re.test(el[prop])) {
	                    el[prop] = el[prop].replace(rer, '$1<found>$2</found>$3');
	                    hasFound = true;
	                }
	            }
	            else if (el.attributes.hasOwnProperty(prop)) {
	                el.attributes[prop] = el.attributes[prop].replace(/<\/?found>/g, '');
	                if (re.test(el.attributes[prop])) {
	                    el.attributes[prop] = el.attributes[prop].replace(rer, '$1<found>$2</found>$3');
	                    hasFound = true;
	                }
	            }
	        }
	        return hasFound;
	    };
	    BlogPage.prototype.search = function (evt) {
	        var value = evt.target.value;
	        value = value.replace(/^[^a-z0-9 \-]|[^a-z0-9 \-*]+/gi, '');
	        value = value.replace(/^\*+/gi, '');
	        value = value.replace(/\*/gi, '[a-z0-9 \-]');
	        this.setState({
	            searchValue: value
	        });
	    };
	    BlogPage.prototype.reload = function () {
	        if (this.props.params && this.props.params.post) {
	        }
	        else {
	            this.fetchPosts('/api/v1/posts/all');
	        }
	    };
	    BlogPage.prototype.digits = function (value, places) {
	        places = (typeof places === 'number' ? places : 2);
	        return (Array(places).join('0') + value).slice(-(places));
	    };
	    BlogPage.prototype.formatDate = function (date, format) {
	        if (!date.length)
	            return '';
	        if (typeof date === 'string') {
	            format = (typeof format === 'string' ? format : 'dag DD.MM.YYYY (HH:mm:SS)');
	            var dager = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	            var d = new Date(date.replace(/-/g, '/').replace(/T/g, ' ').slice(0, 19));
	            var formatted = format.replace(new RegExp('da[gy]', 'ig'), dager[d.getDay()]);
	            for (var i = 5; i > 0; i--) {
	                formatted = formatted
	                    .replace(new RegExp("(^|\\W)Y{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getFullYear(), i) + "$2")
	                    .replace(new RegExp("(^|\\W)M{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getMonth() + 1, i) + "$2")
	                    .replace(new RegExp("(^|\\W)D{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getDate(), i) + "$2")
	                    .replace(new RegExp("(^|\\W)H{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getHours(), i) + "$2")
	                    .replace(new RegExp("(^|\\W)m{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getMinutes(), i) + "$2")
	                    .replace(new RegExp("(^|\\W)S{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getSeconds(), i) + "$2");
	            }
	            return formatted;
	        }
	        return '';
	    };
	    BlogPage.prototype.changeView = function (type) {
	        this.setState({
	            viewMode: type
	        });
	        try {
	            localStorage['viewMode'] = type;
	        }
	        catch (ex) { }
	    };
	    BlogPage.prototype.changeViewToSmallHandler = function (evt) {
	        this.changeView('small');
	    };
	    BlogPage.prototype.changeViewToBigHandler = function (evt) {
	        this.changeView('big');
	    };
	    BlogPage.prototype.render = function () {
	        var _this = this;
	        if (this.showAllPosts && !this.props.params.post) {
	            this.reload();
	            this.showAllPosts = false;
	        }
	        else if (!this.showAllPosts && this.props.params.post) {
	            this.reload();
	            this.showAllPosts = true;
	        }
	        if (this.props.params && this.props.params.post) {
	            return (React.createElement("div", { className: "page page-blog" },
	                React.createElement(breadcrumb_1.Breadcrumb, { routes: ['blog', this.props.params.post] }),
	                React.createElement(blogArticle_1.BlogArticle, { post: this.props.params.post })));
	        }
	        else {
	            var links = this.state.posts
	                .filter(function (post) { return _this.filterByTags(_this.state.tagValues, post); })
	                .filter(function (post) { return _this.filterBySearch(_this.state.searchValue, post, ['title', 'dateFormatted', 'author', 'renderedBody']); })
	                .map(function (post, i) {
	                var categories = post.attributes.categoriesList.map(function (cat, k) {
	                    var className = 'category' + (_this.state.tagValues.indexOf(cat) === -1 ? '' : ' selected');
	                    var tags = _this.state.tagValues.slice();
	                    var index = tags.indexOf(cat);
	                    if (index === -1)
	                        tags.push(cat);
	                    else {
	                        var newTags = [];
	                        for (var _i = 0, tags_1 = tags; _i < tags_1.length; _i++) {
	                            var tag = tags_1[_i];
	                            if (tag !== cat)
	                                newTags.push(tag);
	                        }
	                        tags = newTags;
	                    }
	                    return (React.createElement(react_router_1.Link, { to: "/blog/tags/" + tags.join(','), className: className, key: k, onClick: _this.addTagToFilterHandler.bind(_this) }, cat));
	                });
	                return (React.createElement("div", { className: "page-blog-list-link", key: i },
	                    React.createElement(react_router_1.Link, { className: "blog-list-link", onClick: _this.reload, to: '/blog/' + post.link, dangerouslySetInnerHTML: { __html: post.attributes.title } }),
	                    React.createElement("div", { className: "blog-list-details" },
	                        React.createElement("div", { className: "blog-list-author", dangerouslySetInnerHTML: { __html: post.attributes.author } }),
	                        React.createElement("div", { className: "blog-list-date", dangerouslySetInnerHTML: { __html: post.attributes.dateFormatted } })),
	                    React.createElement("div", { className: "blog-list-preview" },
	                        React.createElement("div", { ref: "post-" + i, dangerouslySetInnerHTML: { __html: _this.state.viewMode && _this.state.viewMode == 'small' ? post.renderedFirstChild : post.renderedBody } })),
	                    React.createElement("div", { className: "blog-list-categories" }, categories)));
	            });
	            return (React.createElement("div", { className: "page page-blog" },
	                React.createElement(breadcrumb_1.Breadcrumb, { routes: ['blog'] }),
	                React.createElement(PageLayout_1.Section, { titleText: "Our blog" },
	                    React.createElement("input", { onChange: this.search.bind(this), placeholder: "Search in articles...", title: "Use * as wildcard" }),
	                    React.createElement(PageLayout_1.SubSection, { className: "page-blog-list" }, links))));
	        }
	    };
	    return BlogPage;
	}(React.Component));
	exports.BlogPage = BlogPage;
	exports.default = BlogPage;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	// commonmark.js - CommomMark in JavaScript
	// Copyright (C) 2014 John MacFarlane
	// License: BSD3.
	
	// Basic usage:
	//
	// var commonmark = require('commonmark');
	// var parser = new commonmark.Parser();
	// var renderer = new commonmark.HtmlRenderer();
	// console.log(renderer.render(parser.parse('Hello *world*')));
	
	module.exports.version = '0.26.0';
	module.exports.Node = __webpack_require__(84);
	module.exports.Parser = __webpack_require__(85);
	// module.exports.HtmlRenderer = require('./html');
	module.exports.HtmlRenderer = __webpack_require__(101);
	module.exports.XmlRenderer = __webpack_require__(103);


/***/ }),
/* 84 */
/***/ (function(module, exports) {

	"use strict";
	
	function isContainer(node) {
	    switch (node._type) {
	    case 'document':
	    case 'block_quote':
	    case 'list':
	    case 'item':
	    case 'paragraph':
	    case 'heading':
	    case 'emph':
	    case 'strong':
	    case 'link':
	    case 'image':
	    case 'custom_inline':
	    case 'custom_block':
	        return true;
	    default:
	        return false;
	    }
	}
	
	var resumeAt = function(node, entering) {
	    this.current = node;
	    this.entering = (entering === true);
	};
	
	var next = function(){
	    var cur = this.current;
	    var entering = this.entering;
	
	    if (cur === null) {
	        return null;
	    }
	
	    var container = isContainer(cur);
	
	    if (entering && container) {
	        if (cur._firstChild) {
	            this.current = cur._firstChild;
	            this.entering = true;
	        } else {
	            // stay on node but exit
	            this.entering = false;
	        }
	
	    } else if (cur === this.root) {
	        this.current = null;
	
	    } else if (cur._next === null) {
	        this.current = cur._parent;
	        this.entering = false;
	
	    } else {
	        this.current = cur._next;
	        this.entering = true;
	    }
	
	    return {entering: entering, node: cur};
	};
	
	var NodeWalker = function(root) {
	    return { current: root,
	             root: root,
	             entering: true,
	             next: next,
	             resumeAt: resumeAt };
	};
	
	var Node = function(nodeType, sourcepos) {
	    this._type = nodeType;
	    this._parent = null;
	    this._firstChild = null;
	    this._lastChild = null;
	    this._prev = null;
	    this._next = null;
	    this._sourcepos = sourcepos;
	    this._lastLineBlank = false;
	    this._open = true;
	    this._string_content = null;
	    this._literal = null;
	    this._listData = {};
	    this._info = null;
	    this._destination = null;
	    this._title = null;
	    this._isFenced = false;
	    this._fenceChar = null;
	    this._fenceLength = 0;
	    this._fenceOffset = null;
	    this._level = null;
	    this._onEnter = null;
	    this._onExit = null;
	};
	
	var proto = Node.prototype;
	
	Object.defineProperty(proto, 'isContainer', {
	    get: function () { return isContainer(this); }
	});
	
	Object.defineProperty(proto, 'type', {
	    get: function() { return this._type; }
	});
	
	Object.defineProperty(proto, 'firstChild', {
	    get: function() { return this._firstChild; }
	});
	
	Object.defineProperty(proto, 'lastChild', {
	    get: function() { return this._lastChild; }
	});
	
	Object.defineProperty(proto, 'next', {
	    get: function() { return this._next; }
	});
	
	Object.defineProperty(proto, 'prev', {
	    get: function() { return this._prev; }
	});
	
	Object.defineProperty(proto, 'parent', {
	    get: function() { return this._parent; }
	});
	
	Object.defineProperty(proto, 'sourcepos', {
	    get: function() { return this._sourcepos; }
	});
	
	Object.defineProperty(proto, 'literal', {
	    get: function() { return this._literal; },
	    set: function(s) { this._literal = s; }
	});
	
	Object.defineProperty(proto, 'destination', {
	    get: function() { return this._destination; },
	    set: function(s) { this._destination = s; }
	});
	
	Object.defineProperty(proto, 'title', {
	    get: function() { return this._title; },
	    set: function(s) { this._title = s; }
	});
	
	Object.defineProperty(proto, 'info', {
	    get: function() { return this._info; },
	    set: function(s) { this._info = s; }
	});
	
	Object.defineProperty(proto, 'level', {
	    get: function() { return this._level; },
	    set: function(s) { this._level = s; }
	});
	
	Object.defineProperty(proto, 'listType', {
	    get: function() { return this._listData.type; },
	    set: function(t) { this._listData.type = t; }
	});
	
	Object.defineProperty(proto, 'listTight', {
	    get: function() { return this._listData.tight; },
	    set: function(t) { this._listData.tight = t; }
	});
	
	Object.defineProperty(proto, 'listStart', {
	    get: function() { return this._listData.start; },
	    set: function(n) { this._listData.start = n; }
	});
	
	Object.defineProperty(proto, 'listDelimiter', {
	    get: function() { return this._listData.delimiter; },
	    set: function(delim) { this._listData.delimiter = delim; }
	});
	
	Object.defineProperty(proto, 'onEnter', {
	    get: function() { return this._onEnter; },
	    set: function(s) { this._onEnter = s; }
	});
	
	Object.defineProperty(proto, 'onExit', {
	    get: function() { return this._onExit; },
	    set: function(s) { this._onExit = s; }
	});
	
	Node.prototype.appendChild = function(child) {
	    child.unlink();
	    child._parent = this;
	    if (this._lastChild) {
	        this._lastChild._next = child;
	        child._prev = this._lastChild;
	        this._lastChild = child;
	    } else {
	        this._firstChild = child;
	        this._lastChild = child;
	    }
	};
	
	Node.prototype.prependChild = function(child) {
	    child.unlink();
	    child._parent = this;
	    if (this._firstChild) {
	        this._firstChild._prev = child;
	        child._next = this._firstChild;
	        this._firstChild = child;
	    } else {
	        this._firstChild = child;
	        this._lastChild = child;
	    }
	};
	
	Node.prototype.unlink = function() {
	    if (this._prev) {
	        this._prev._next = this._next;
	    } else if (this._parent) {
	        this._parent._firstChild = this._next;
	    }
	    if (this._next) {
	        this._next._prev = this._prev;
	    } else if (this._parent) {
	        this._parent._lastChild = this._prev;
	    }
	    this._parent = null;
	    this._next = null;
	    this._prev = null;
	};
	
	Node.prototype.insertAfter = function(sibling) {
	    sibling.unlink();
	    sibling._next = this._next;
	    if (sibling._next) {
	        sibling._next._prev = sibling;
	    }
	    sibling._prev = this;
	    this._next = sibling;
	    sibling._parent = this._parent;
	    if (!sibling._next) {
	        sibling._parent._lastChild = sibling;
	    }
	};
	
	Node.prototype.insertBefore = function(sibling) {
	    sibling.unlink();
	    sibling._prev = this._prev;
	    if (sibling._prev) {
	        sibling._prev._next = sibling;
	    }
	    sibling._next = this;
	    this._prev = sibling;
	    sibling._parent = this._parent;
	    if (!sibling._prev) {
	        sibling._parent._firstChild = sibling;
	    }
	};
	
	Node.prototype.walker = function() {
	    var walker = new NodeWalker(this);
	    return walker;
	};
	
	module.exports = Node;
	
	
	/* Example of use of walker:
	
	 var walker = w.walker();
	 var event;
	
	 while (event = walker.next()) {
	 console.log(event.entering, event.node.type);
	 }
	
	 */


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var Node = __webpack_require__(84);
	var unescapeString = __webpack_require__(86).unescapeString;
	var OPENTAG = __webpack_require__(86).OPENTAG;
	var CLOSETAG = __webpack_require__(86).CLOSETAG;
	
	var CODE_INDENT = 4;
	
	var C_TAB = 9;
	var C_NEWLINE = 10;
	var C_GREATERTHAN = 62;
	var C_LESSTHAN = 60;
	var C_SPACE = 32;
	var C_OPEN_BRACKET = 91;
	
	var InlineParser = __webpack_require__(97);
	
	var reHtmlBlockOpen = [
	   /./, // dummy for 0
	   /^<(?:script|pre|style)(?:\s|>|$)/i,
	   /^<!--/,
	   /^<[?]/,
	   /^<![A-Z]/,
	   /^<!\[CDATA\[/,
	   /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|title|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
	    new RegExp('^(?:' + OPENTAG + '|' + CLOSETAG + ')\\s*$', 'i')
	];
	
	var reHtmlBlockClose = [
	   /./, // dummy for 0
	   /<\/(?:script|pre|style)>/i,
	   /-->/,
	   /\?>/,
	   />/,
	   /\]\]>/
	];
	
	var reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/;
	
	var reMaybeSpecial = /^[#`~*+_=<>0-9-]/;
	
	var reNonSpace = /[^ \t\f\v\r\n]/;
	
	var reBulletListMarker = /^[*+-]/;
	
	var reOrderedListMarker = /^(\d{1,9})([.)])/;
	
	var reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/;
	
	var reCodeFence = /^`{3,}(?!.*`)|^~{3,}(?!.*~)/;
	
	var reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;
	
	var reSetextHeadingLine = /^(?:=+|-+) *$/;
	
	var reLineEnding = /\r\n|\n|\r/;
	
	// Returns true if string contains only space characters.
	var isBlank = function(s) {
	    return !(reNonSpace.test(s));
	};
	
	var isSpaceOrTab = function(c) {
	    return c === C_SPACE || c === C_TAB;
	};
	
	var peek = function(ln, pos) {
	    if (pos < ln.length) {
	        return ln.charCodeAt(pos);
	    } else {
	        return -1;
	    }
	};
	
	// DOC PARSER
	
	// These are methods of a Parser object, defined below.
	
	// Returns true if block ends with a blank line, descending if needed
	// into lists and sublists.
	var endsWithBlankLine = function(block) {
	    while (block) {
	        if (block._lastLineBlank) {
	            return true;
	        }
	        var t = block.type;
	        if (t === 'list' || t === 'item') {
	            block = block._lastChild;
	        } else {
	            break;
	        }
	    }
	    return false;
	};
	
	// Add a line to the block at the tip.  We assume the tip
	// can accept lines -- that check should be done before calling this.
	var addLine = function() {
	    if (this.partiallyConsumedTab) {
	      this.offset += 1; // skip over tab
	      // add space characters:
	      var charsToTab = 4 - (this.column % 4);
	      this.tip._string_content += (' '.repeat(charsToTab));
	    }
	    this.tip._string_content += this.currentLine.slice(this.offset) + '\n';
	};
	
	// Add block of type tag as a child of the tip.  If the tip can't
	// accept children, close and finalize it and try its parent,
	// and so on til we find a block that can accept children.
	var addChild = function(tag, offset) {
	    while (!this.blocks[this.tip.type].canContain(tag)) {
	        this.finalize(this.tip, this.lineNumber - 1);
	    }
	
	    var column_number = offset + 1; // offset 0 = column 1
	    var newBlock = new Node(tag, [[this.lineNumber, column_number], [0, 0]]);
	    newBlock._string_content = '';
	    this.tip.appendChild(newBlock);
	    this.tip = newBlock;
	    return newBlock;
	};
	
	// Parse a list marker and return data on the marker (type,
	// start, delimiter, bullet character, padding) or null.
	var parseListMarker = function(parser, container) {
	    var rest = parser.currentLine.slice(parser.nextNonspace);
	    var match;
	    var nextc;
	    var spacesStartCol;
	    var spacesStartOffset;
	    var data = { type: null,
	                 tight: true,  // lists are tight by default
	                 bulletChar: null,
	                 start: null,
	                 delimiter: null,
	                 padding: null,
	                 markerOffset: parser.indent };
	    if ((match = rest.match(reBulletListMarker))) {
	        data.type = 'bullet';
	        data.bulletChar = match[0][0];
	
	    } else if ((match = rest.match(reOrderedListMarker)) &&
	                (container.type !== 'paragraph' ||
	                 match[1] === '1')) {
	        data.type = 'ordered';
	        data.start = parseInt(match[1]);
	        data.delimiter = match[2];
	    } else {
	        return null;
	    }
	    // make sure we have spaces after
	    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);
	    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {
	        return null;
	    }
	
	    // if it interrupts paragraph, make sure first line isn't blank
	    if (container.type === 'paragraph' && !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {
	        return null;
	    }
	
	    // we've got a match! advance offset and calculate padding
	    parser.advanceNextNonspace(); // to start of marker
	    parser.advanceOffset(match[0].length, true); // to end of marker
	    spacesStartCol = parser.column;
	    spacesStartOffset = parser.offset;
	    do {
	        parser.advanceOffset(1, true);
	        nextc = peek(parser.currentLine, parser.offset);
	    } while (parser.column - spacesStartCol < 5 &&
	           isSpaceOrTab(nextc));
	    var blank_item = peek(parser.currentLine, parser.offset) === -1;
	    var spaces_after_marker = parser.column - spacesStartCol;
	    if (spaces_after_marker >= 5 ||
	        spaces_after_marker < 1 ||
	        blank_item) {
	        data.padding = match[0].length + 1;
	        parser.column = spacesStartCol;
	        parser.offset = spacesStartOffset;
	        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
	            parser.advanceOffset(1, true);
	        }
	    } else {
	        data.padding = match[0].length + spaces_after_marker;
	    }
	    return data;
	};
	
	// Returns true if the two list items are of the same type,
	// with the same delimiter and bullet character.  This is used
	// in agglomerating list items into lists.
	var listsMatch = function(list_data, item_data) {
	    return (list_data.type === item_data.type &&
	            list_data.delimiter === item_data.delimiter &&
	            list_data.bulletChar === item_data.bulletChar);
	};
	
	// Finalize and close any unmatched blocks.
	var closeUnmatchedBlocks = function() {
	    if (!this.allClosed) {
	        // finalize any blocks not matched
	        while (this.oldtip !== this.lastMatchedContainer) {
	            var parent = this.oldtip._parent;
	            this.finalize(this.oldtip, this.lineNumber - 1);
	            this.oldtip = parent;
	        }
	        this.allClosed = true;
	    }
	};
	
	// 'finalize' is run when the block is closed.
	// 'continue' is run to check whether the block is continuing
	// at a certain line and offset (e.g. whether a block quote
	// contains a `>`.  It returns 0 for matched, 1 for not matched,
	// and 2 for "we've dealt with this line completely, go to next."
	var blocks = {
	    document: {
	        continue: function() { return 0; },
	        finalize: function() { return; },
	        canContain: function(t) { return (t !== 'item'); },
	        acceptsLines: false
	    },
	    list: {
	        continue: function() { return 0; },
	        finalize: function(parser, block) {
	            var item = block._firstChild;
	            while (item) {
	                // check for non-final list item ending with blank line:
	                if (endsWithBlankLine(item) && item._next) {
	                    block._listData.tight = false;
	                    break;
	                }
	                // recurse into children of list item, to see if there are
	                // spaces between any of them:
	                var subitem = item._firstChild;
	                while (subitem) {
	                    if (endsWithBlankLine(subitem) &&
	                        (item._next || subitem._next)) {
	                        block._listData.tight = false;
	                        break;
	                    }
	                    subitem = subitem._next;
	                }
	                item = item._next;
	            }
	        },
	        canContain: function(t) { return (t === 'item'); },
	        acceptsLines: false
	    },
	    block_quote: {
	        continue: function(parser) {
	            var ln = parser.currentLine;
	            if (!parser.indented &&
	                peek(ln, parser.nextNonspace) === C_GREATERTHAN) {
	                parser.advanceNextNonspace();
	                parser.advanceOffset(1, false);
	                if (isSpaceOrTab(peek(ln, parser.offset))) {
	                    parser.advanceOffset(1, true);
	                }
	            } else {
	                return 1;
	            }
	            return 0;
	        },
	        finalize: function() { return; },
	        canContain: function(t) { return (t !== 'item'); },
	        acceptsLines: false
	    },
	    item: {
	        continue: function(parser, container) {
	            if (parser.blank) {
	                if (container._firstChild == null) {
	                    // Blank line after empty list item
	                    return 1;
	                } else {
	                    parser.advanceNextNonspace();
	                }
	            } else if (parser.indent >=
	                       container._listData.markerOffset +
	                       container._listData.padding) {
	                parser.advanceOffset(container._listData.markerOffset +
	                    container._listData.padding, true);
	            } else {
	                return 1;
	            }
	            return 0;
	        },
	        finalize: function() { return; },
	        canContain: function(t) { return (t !== 'item'); },
	        acceptsLines: false
	    },
	    heading: {
	        continue: function() {
	            // a heading can never container > 1 line, so fail to match:
	            return 1;
	        },
	        finalize: function() { return; },
	        canContain: function() { return false; },
	        acceptsLines: false
	    },
	    thematic_break: {
	        continue: function() {
	            // a thematic break can never container > 1 line, so fail to match:
	            return 1;
	        },
	        finalize: function() { return; },
	        canContain: function() { return false; },
	        acceptsLines: false
	    },
	    code_block: {
	        continue: function(parser, container) {
	            var ln = parser.currentLine;
	            var indent = parser.indent;
	            if (container._isFenced) { // fenced
	                var match = (indent <= 3 &&
	                    ln.charAt(parser.nextNonspace) === container._fenceChar &&
	                    ln.slice(parser.nextNonspace).match(reClosingCodeFence));
	                if (match && match[0].length >= container._fenceLength) {
	                    // closing fence - we're at end of line, so we can return
	                    parser.finalize(container, parser.lineNumber);
	                    return 2;
	                } else {
	                    // skip optional spaces of fence offset
	                    var i = container._fenceOffset;
	                    while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {
	                        parser.advanceOffset(1, true);
	                        i--;
	                    }
	                }
	            } else { // indented
	                if (indent >= CODE_INDENT) {
	                    parser.advanceOffset(CODE_INDENT, true);
	                } else if (parser.blank) {
	                    parser.advanceNextNonspace();
	                } else {
	                    return 1;
	                }
	            }
	            return 0;
	        },
	        finalize: function(parser, block) {
	            if (block._isFenced) { // fenced
	                // first line becomes info string
	                var content = block._string_content;
	                var newlinePos = content.indexOf('\n');
	                var firstLine = content.slice(0, newlinePos);
	                var rest = content.slice(newlinePos + 1);
	                block.info = unescapeString(firstLine.trim());
	                block._literal = rest;
	            } else { // indented
	                block._literal = block._string_content.replace(/(\n *)+$/, '\n');
	            }
	            block._string_content = null; // allow GC
	        },
	        canContain: function() { return false; },
	        acceptsLines: true
	    },
	    html_block: {
	        continue: function(parser, container) {
	            return ((parser.blank &&
	                     (container._htmlBlockType === 6 ||
	                      container._htmlBlockType === 7)) ? 1 : 0);
	        },
	        finalize: function(parser, block) {
	            block._literal = block._string_content.replace(/(\n *)+$/, '');
	            block._string_content = null; // allow GC
	        },
	        canContain: function() { return false; },
	        acceptsLines: true
	    },
	    paragraph: {
	        continue: function(parser) {
	            return (parser.blank ? 1 : 0);
	        },
	        finalize: function(parser, block) {
	            var pos;
	            var hasReferenceDefs = false;
	
	            // try parsing the beginning as link reference definitions:
	            while (peek(block._string_content, 0) === C_OPEN_BRACKET &&
	                   (pos =
	                    parser.inlineParser.parseReference(block._string_content,
	                                                       parser.refmap))) {
	                block._string_content = block._string_content.slice(pos);
	                hasReferenceDefs = true;
	            }
	            if (hasReferenceDefs && isBlank(block._string_content)) {
	                block.unlink();
	            }
	        },
	        canContain: function() { return false; },
	        acceptsLines: true
	    }
	};
	
	// block start functions.  Return values:
	// 0 = no match
	// 1 = matched container, keep going
	// 2 = matched leaf, no more block starts
	var blockStarts = [
	    // block quote
	    function(parser) {
	        if (!parser.indented &&
	            peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {
	            parser.advanceNextNonspace();
	            parser.advanceOffset(1, false);
	            // optional following space
	            if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
	                parser.advanceOffset(1, true);
	            }
	            parser.closeUnmatchedBlocks();
	            parser.addChild('block_quote', parser.nextNonspace);
	            return 1;
	        } else {
	            return 0;
	        }
	    },
	
	    // ATX heading
	    function(parser) {
	        var match;
	        if (!parser.indented &&
	            (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {
	            parser.advanceNextNonspace();
	            parser.advanceOffset(match[0].length, false);
	            parser.closeUnmatchedBlocks();
	            var container = parser.addChild('heading', parser.nextNonspace);
	            container.level = match[0].trim().length; // number of #s
	            // remove trailing ###s:
	            container._string_content =
	                parser.currentLine.slice(parser.offset).replace(/^ *#+ *$/, '').replace(/ +#+ *$/, '');
	            parser.advanceOffset(parser.currentLine.length - parser.offset);
	            return 2;
	        } else {
	            return 0;
	        }
	    },
	
	    // Fenced code block
	    function(parser) {
	        var match;
	        if (!parser.indented &&
	            (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {
	            var fenceLength = match[0].length;
	            parser.closeUnmatchedBlocks();
	            var container = parser.addChild('code_block', parser.nextNonspace);
	            container._isFenced = true;
	            container._fenceLength = fenceLength;
	            container._fenceChar = match[0][0];
	            container._fenceOffset = parser.indent;
	            parser.advanceNextNonspace();
	            parser.advanceOffset(fenceLength, false);
	            return 2;
	        } else {
	            return 0;
	        }
	    },
	
	    // HTML block
	    function(parser, container) {
	        if (!parser.indented &&
	            peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {
	            var s = parser.currentLine.slice(parser.nextNonspace);
	            var blockType;
	
	            for (blockType = 1; blockType <= 7; blockType++) {
	                if (reHtmlBlockOpen[blockType].test(s) &&
	                    (blockType < 7 ||
	                     container.type !== 'paragraph')) {
	                    parser.closeUnmatchedBlocks();
	                    // We don't adjust parser.offset;
	                    // spaces are part of the HTML block:
	                    var b = parser.addChild('html_block',
	                                            parser.offset);
	                    b._htmlBlockType = blockType;
	                    return 2;
	                }
	            }
	        }
	
	        return 0;
	
	    },
	
	    // Setext heading
	    function(parser, container) {
	        var match;
	        if (!parser.indented &&
	            container.type === 'paragraph' &&
	                   ((match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine)))) {
	            parser.closeUnmatchedBlocks();
	            var heading = new Node('heading', container.sourcepos);
	            heading.level = match[0][0] === '=' ? 1 : 2;
	            heading._string_content = container._string_content;
	            container.insertAfter(heading);
	            container.unlink();
	            parser.tip = heading;
	            parser.advanceOffset(parser.currentLine.length - parser.offset, false);
	            return 2;
	        } else {
	            return 0;
	        }
	    },
	
	    // thematic break
	    function(parser) {
	        if (!parser.indented &&
	            reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {
	            parser.closeUnmatchedBlocks();
	            parser.addChild('thematic_break', parser.nextNonspace);
	            parser.advanceOffset(parser.currentLine.length - parser.offset, false);
	            return 2;
	        } else {
	            return 0;
	        }
	    },
	
	    // list item
	    function(parser, container) {
	        var data;
	
	        if ((!parser.indented || container.type === 'list')
	                && (data = parseListMarker(parser, container))) {
	            parser.closeUnmatchedBlocks();
	
	            // add the list if needed
	            if (parser.tip.type !== 'list' ||
	                !(listsMatch(container._listData, data))) {
	                container = parser.addChild('list', parser.nextNonspace);
	                container._listData = data;
	            }
	
	            // add the list item
	            container = parser.addChild('item', parser.nextNonspace);
	            container._listData = data;
	            return 1;
	        } else {
	            return 0;
	        }
	    },
	
	    // indented code block
	    function(parser) {
	        if (parser.indented &&
	            parser.tip.type !== 'paragraph' &&
	            !parser.blank) {
	            // indented code
	            parser.advanceOffset(CODE_INDENT, true);
	            parser.closeUnmatchedBlocks();
	            parser.addChild('code_block', parser.offset);
	            return 2;
	        } else {
	            return 0;
	        }
	     }
	
	];
	
	var advanceOffset = function(count, columns) {
	    var currentLine = this.currentLine;
	    var charsToTab, charsToAdvance;
	    var c;
	    while (count > 0 && (c = currentLine[this.offset])) {
	        if (c === '\t') {
	            charsToTab = 4 - (this.column % 4);
	            if (columns) {
	                this.partiallyConsumedTab = charsToTab > count;
	                charsToAdvance = charsToTab > count ? count : charsToTab;
	                this.column += charsToAdvance;
	                this.offset += this.partiallyConsumedTab ? 0 : 1;
	                count -= charsToAdvance;
	            } else {
	                this.partiallyConsumedTab = false;
	                this.column += charsToTab;
	                this.offset += 1;
	                count -= 1;
	            }
	        } else {
	            this.partiallyConsumedTab = false;
	            this.offset += 1;
	            this.column += 1; // assume ascii; block starts are ascii
	            count -= 1;
	        }
	    }
	};
	
	var advanceNextNonspace = function() {
	    this.offset = this.nextNonspace;
	    this.column = this.nextNonspaceColumn;
	    this.partiallyConsumedTab = false;
	};
	
	var findNextNonspace = function() {
	    var currentLine = this.currentLine;
	    var i = this.offset;
	    var cols = this.column;
	    var c;
	
	    while ((c = currentLine.charAt(i)) !== '') {
	        if (c === ' ') {
	            i++;
	            cols++;
	        } else if (c === '\t') {
	            i++;
	            cols += (4 - (cols % 4));
	        } else {
	            break;
	        }
	    }
	    this.blank = (c === '\n' || c === '\r' || c === '');
	    this.nextNonspace = i;
	    this.nextNonspaceColumn = cols;
	    this.indent = this.nextNonspaceColumn - this.column;
	    this.indented = this.indent >= CODE_INDENT;
	};
	
	// Analyze a line of text and update the document appropriately.
	// We parse markdown text by calling this on each line of input,
	// then finalizing the document.
	var incorporateLine = function(ln) {
	    var all_matched = true;
	    var t;
	
	    var container = this.doc;
	    this.oldtip = this.tip;
	    this.offset = 0;
	    this.column = 0;
	    this.blank = false;
	    this.partiallyConsumedTab = false;
	    this.lineNumber += 1;
	
	    // replace NUL characters for security
	    if (ln.indexOf('\u0000') !== -1) {
	        ln = ln.replace(/\0/g, '\uFFFD');
	    }
	
	    this.currentLine = ln;
	
	    // For each containing block, try to parse the associated line start.
	    // Bail out on failure: container will point to the last matching block.
	    // Set all_matched to false if not all containers match.
	    var lastChild;
	    while ((lastChild = container._lastChild) && lastChild._open) {
	        container = lastChild;
	
	        this.findNextNonspace();
	
	        switch (this.blocks[container.type].continue(this, container)) {
	        case 0: // we've matched, keep going
	            break;
	        case 1: // we've failed to match a block
	            all_matched = false;
	            break;
	        case 2: // we've hit end of line for fenced code close and can return
	            this.lastLineLength = ln.length;
	            return;
	        default:
	            throw 'continue returned illegal value, must be 0, 1, or 2';
	        }
	        if (!all_matched) {
	            container = container._parent; // back up to last matching block
	            break;
	        }
	    }
	
	    this.allClosed = (container === this.oldtip);
	    this.lastMatchedContainer = container;
	
	    var matchedLeaf = container.type !== 'paragraph' &&
	            blocks[container.type].acceptsLines;
	    var starts = this.blockStarts;
	    var startsLen = starts.length;
	    // Unless last matched container is a code block, try new container starts,
	    // adding children to the last matched container:
	    while (!matchedLeaf) {
	
	        this.findNextNonspace();
	
	        // this is a little performance optimization:
	        if (!this.indented &&
	            !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {
	            this.advanceNextNonspace();
	            break;
	        }
	
	        var i = 0;
	        while (i < startsLen) {
	            var res = starts[i](this, container);
	            if (res === 1) {
	                container = this.tip;
	                break;
	            } else if (res === 2) {
	                container = this.tip;
	                matchedLeaf = true;
	                break;
	            } else {
	                i++;
	            }
	        }
	
	        if (i === startsLen) { // nothing matched
	            this.advanceNextNonspace();
	            break;
	        }
	    }
	
	    // What remains at the offset is a text line.  Add the text to the
	    // appropriate container.
	
	   // First check for a lazy paragraph continuation:
	    if (!this.allClosed && !this.blank &&
	        this.tip.type === 'paragraph') {
	        // lazy paragraph continuation
	        this.addLine();
	
	    } else { // not a lazy continuation
	
	        // finalize any blocks not matched
	        this.closeUnmatchedBlocks();
	        if (this.blank && container.lastChild) {
	            container.lastChild._lastLineBlank = true;
	        }
	
	        t = container.type;
	
	        // Block quote lines are never blank as they start with >
	        // and we don't count blanks in fenced code for purposes of tight/loose
	        // lists or breaking out of lists.  We also don't set _lastLineBlank
	        // on an empty list item, or if we just closed a fenced block.
	        var lastLineBlank = this.blank &&
	            !(t === 'block_quote' ||
	              (t === 'code_block' && container._isFenced) ||
	              (t === 'item' &&
	               !container._firstChild &&
	               container.sourcepos[0][0] === this.lineNumber));
	
	        // propagate lastLineBlank up through parents:
	        var cont = container;
	        while (cont) {
	            cont._lastLineBlank = lastLineBlank;
	            cont = cont._parent;
	        }
	
	        if (this.blocks[t].acceptsLines) {
	            this.addLine();
	            // if HtmlBlock, check for end condition
	            if (t === 'html_block' &&
	                container._htmlBlockType >= 1 &&
	                container._htmlBlockType <= 5 &&
	                reHtmlBlockClose[container._htmlBlockType].test(this.currentLine.slice(this.offset))) {
	                this.finalize(container, this.lineNumber);
	            }
	
	        } else if (this.offset < ln.length && !this.blank) {
	            // create paragraph container for line
	            container = this.addChild('paragraph', this.offset);
	            this.advanceNextNonspace();
	            this.addLine();
	        }
	    }
	    this.lastLineLength = ln.length;
	};
	
	// Finalize a block.  Close it and do any necessary postprocessing,
	// e.g. creating string_content from strings, setting the 'tight'
	// or 'loose' status of a list, and parsing the beginnings
	// of paragraphs for reference definitions.  Reset the tip to the
	// parent of the closed block.
	var finalize = function(block, lineNumber) {
	    var above = block._parent;
	    block._open = false;
	    block.sourcepos[1] = [lineNumber, this.lastLineLength];
	
	    this.blocks[block.type].finalize(this, block);
	
	    this.tip = above;
	};
	
	// Walk through a block & children recursively, parsing string content
	// into inline content where appropriate.
	var processInlines = function(block) {
	    var node, event, t;
	    var walker = block.walker();
	    this.inlineParser.refmap = this.refmap;
	    this.inlineParser.options = this.options;
	    while ((event = walker.next())) {
	        node = event.node;
	        t = node.type;
	        if (!event.entering && (t === 'paragraph' || t === 'heading')) {
	            this.inlineParser.parse(node);
	        }
	    }
	};
	
	var Document = function() {
	    var doc = new Node('document', [[1, 1], [0, 0]]);
	    return doc;
	};
	
	// The main parsing function.  Returns a parsed document AST.
	var parse = function(input) {
	    this.doc = new Document();
	    this.tip = this.doc;
	    this.refmap = {};
	    this.lineNumber = 0;
	    this.lastLineLength = 0;
	    this.offset = 0;
	    this.column = 0;
	    this.lastMatchedContainer = this.doc;
	    this.currentLine = "";
	    if (this.options.time) { console.time("preparing input"); }
	    var lines = input.split(reLineEnding);
	    var len = lines.length;
	    if (input.charCodeAt(input.length - 1) === C_NEWLINE) {
	        // ignore last blank line created by final newline
	        len -= 1;
	    }
	    if (this.options.time) { console.timeEnd("preparing input"); }
	    if (this.options.time) { console.time("block parsing"); }
	    for (var i = 0; i < len; i++) {
	        this.incorporateLine(lines[i]);
	    }
	    while (this.tip) {
	        this.finalize(this.tip, len);
	    }
	    if (this.options.time) { console.timeEnd("block parsing"); }
	    if (this.options.time) { console.time("inline parsing"); }
	    this.processInlines(this.doc);
	    if (this.options.time) { console.timeEnd("inline parsing"); }
	    return this.doc;
	};
	
	
	// The Parser object.
	function Parser(options){
	    return {
	        doc: new Document(),
	        blocks: blocks,
	        blockStarts: blockStarts,
	        tip: this.doc,
	        oldtip: this.doc,
	        currentLine: "",
	        lineNumber: 0,
	        offset: 0,
	        column: 0,
	        nextNonspace: 0,
	        nextNonspaceColumn: 0,
	        indent: 0,
	        indented: false,
	        blank: false,
	        partiallyConsumedTab: false,
	        allClosed: true,
	        lastMatchedContainer: this.doc,
	        refmap: {},
	        lastLineLength: 0,
	        inlineParser: new InlineParser(options),
	        findNextNonspace: findNextNonspace,
	        advanceOffset: advanceOffset,
	        advanceNextNonspace: advanceNextNonspace,
	        addLine: addLine,
	        addChild: addChild,
	        incorporateLine: incorporateLine,
	        finalize: finalize,
	        processInlines: processInlines,
	        closeUnmatchedBlocks: closeUnmatchedBlocks,
	        parse: parse,
	        options: options || {}
	    };
	}
	
	module.exports = Parser;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var encode = __webpack_require__(87);
	var decode = __webpack_require__(88);
	
	var C_BACKSLASH = 92;
	
	var decodeHTML = __webpack_require__(89).decodeHTML;
	
	var ENTITY = "&(?:#x[a-f0-9]{1,8}|#[0-9]{1,8}|[a-z][a-z0-9]{1,31});";
	
	var TAGNAME = '[A-Za-z][A-Za-z0-9-]*';
	var ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
	var UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+";
	var SINGLEQUOTEDVALUE = "'[^']*'";
	var DOUBLEQUOTEDVALUE = '"[^"]*"';
	var ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")";
	var ATTRIBUTEVALUESPEC = "(?:" + "\\s*=" + "\\s*" + ATTRIBUTEVALUE + ")";
	var ATTRIBUTE = "(?:" + "\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)";
	var OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*" + "\\s*/?>";
	var CLOSETAG = "</" + TAGNAME + "\\s*[>]";
	var HTMLCOMMENT = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
	var PROCESSINGINSTRUCTION = "[<][?].*?[?][>]";
	var DECLARATION = "<![A-Z]+" + "\\s+[^>]*>";
	var CDATA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
	var HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" +
	        PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")";
	var reHtmlTag = new RegExp('^' + HTMLTAG, 'i');
	
	var reBackslashOrAmp = /[\\&]/;
	
	var ESCAPABLE = '[!"#$%&\'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]';
	
	var reEntityOrEscapedChar = new RegExp('\\\\' + ESCAPABLE + '|' + ENTITY, 'gi');
	
	var XMLSPECIAL = '[&<>"]';
	
	var reXmlSpecial = new RegExp(XMLSPECIAL, 'g');
	
	var reXmlSpecialOrEntity = new RegExp(ENTITY + '|' + XMLSPECIAL, 'gi');
	
	var unescapeChar = function(s) {
	    if (s.charCodeAt(0) === C_BACKSLASH) {
	        return s.charAt(1);
	    } else {
	        return decodeHTML(s);
	    }
	};
	
	// Replace entities and backslash escapes with literal characters.
	var unescapeString = function(s) {
	    if (reBackslashOrAmp.test(s)) {
	        return s.replace(reEntityOrEscapedChar, unescapeChar);
	    } else {
	        return s;
	    }
	};
	
	var normalizeURI = function(uri) {
	    try {
	        return encode(decode(uri));
	    }
	    catch(err) {
	        return uri;
	    }
	};
	
	var replaceUnsafeChar = function(s) {
	    switch (s) {
	    case '&':
	        return '&amp;';
	    case '<':
	        return '&lt;';
	    case '>':
	        return '&gt;';
	    case '"':
	        return '&quot;';
	    default:
	        return s;
	    }
	};
	
	var escapeXml = function(s, preserve_entities) {
	    if (reXmlSpecial.test(s)) {
	        if (preserve_entities) {
	            return s.replace(reXmlSpecialOrEntity, replaceUnsafeChar);
	        } else {
	            return s.replace(reXmlSpecial, replaceUnsafeChar);
	        }
	    } else {
	        return s;
	    }
	};
	
	module.exports = { unescapeString: unescapeString,
	                   normalizeURI: normalizeURI,
	                   escapeXml: escapeXml,
	                   reHtmlTag: reHtmlTag,
	                   OPENTAG: OPENTAG,
	                   CLOSETAG: CLOSETAG,
	                   ENTITY: ENTITY,
	                   ESCAPABLE: ESCAPABLE
	                 };


/***/ }),
/* 87 */
/***/ (function(module, exports) {

	
	'use strict';
	
	
	var encodeCache = {};
	
	
	// Create a lookup array where anything but characters in `chars` string
	// and alphanumeric chars is percent-encoded.
	//
	function getEncodeCache(exclude) {
	  var i, ch, cache = encodeCache[exclude];
	  if (cache) { return cache; }
	
	  cache = encodeCache[exclude] = [];
	
	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);
	
	    if (/^[0-9a-z]$/i.test(ch)) {
	      // always allow unencoded alphanumeric characters
	      cache.push(ch);
	    } else {
	      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
	    }
	  }
	
	  for (i = 0; i < exclude.length; i++) {
	    cache[exclude.charCodeAt(i)] = exclude[i];
	  }
	
	  return cache;
	}
	
	
	// Encode unsafe characters with percent-encoding, skipping already
	// encoded sequences.
	//
	//  - string       - string to encode
	//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
	//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
	//
	function encode(string, exclude, keepEscaped) {
	  var i, l, code, nextCode, cache,
	      result = '';
	
	  if (typeof exclude !== 'string') {
	    // encode(string, keepEscaped)
	    keepEscaped  = exclude;
	    exclude = encode.defaultChars;
	  }
	
	  if (typeof keepEscaped === 'undefined') {
	    keepEscaped = true;
	  }
	
	  cache = getEncodeCache(exclude);
	
	  for (i = 0, l = string.length; i < l; i++) {
	    code = string.charCodeAt(i);
	
	    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
	      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
	        result += string.slice(i, i + 3);
	        i += 2;
	        continue;
	      }
	    }
	
	    if (code < 128) {
	      result += cache[code];
	      continue;
	    }
	
	    if (code >= 0xD800 && code <= 0xDFFF) {
	      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
	        nextCode = string.charCodeAt(i + 1);
	        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
	          result += encodeURIComponent(string[i] + string[i + 1]);
	          i++;
	          continue;
	        }
	      }
	      result += '%EF%BF%BD';
	      continue;
	    }
	
	    result += encodeURIComponent(string[i]);
	  }
	
	  return result;
	}
	
	encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
	encode.componentChars = "-_.!~*'()";
	
	
	module.exports = encode;


/***/ }),
/* 88 */
/***/ (function(module, exports) {

	
	'use strict';
	
	
	/* eslint-disable no-bitwise */
	
	var decodeCache = {};
	
	function getDecodeCache(exclude) {
	  var i, ch, cache = decodeCache[exclude];
	  if (cache) { return cache; }
	
	  cache = decodeCache[exclude] = [];
	
	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);
	    cache.push(ch);
	  }
	
	  for (i = 0; i < exclude.length; i++) {
	    ch = exclude.charCodeAt(i);
	    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
	  }
	
	  return cache;
	}
	
	
	// Decode percent-encoded string.
	//
	function decode(string, exclude) {
	  var cache;
	
	  if (typeof exclude !== 'string') {
	    exclude = decode.defaultChars;
	  }
	
	  cache = getDecodeCache(exclude);
	
	  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
	    var i, l, b1, b2, b3, b4, chr,
	        result = '';
	
	    for (i = 0, l = seq.length; i < l; i += 3) {
	      b1 = parseInt(seq.slice(i + 1, i + 3), 16);
	
	      if (b1 < 0x80) {
	        result += cache[b1];
	        continue;
	      }
	
	      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
	        // 110xxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	
	        if ((b2 & 0xC0) === 0x80) {
	          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);
	
	          if (chr < 0x80) {
	            result += '\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }
	
	          i += 3;
	          continue;
	        }
	      }
	
	      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
	        // 1110xxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
	
	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
	          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);
	
	          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
	            result += '\ufffd\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }
	
	          i += 6;
	          continue;
	        }
	      }
	
	      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
	        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
	        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
	
	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
	          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);
	
	          if (chr < 0x10000 || chr > 0x10FFFF) {
	            result += '\ufffd\ufffd\ufffd\ufffd';
	          } else {
	            chr -= 0x10000;
	            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
	          }
	
	          i += 9;
	          continue;
	        }
	      }
	
	      result += '\ufffd';
	    }
	
	    return result;
	  });
	}
	
	
	decode.defaultChars   = ';/?:@&=+$,#';
	decode.componentChars = '';
	
	
	module.exports = decode;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	var encode = __webpack_require__(90),
	    decode = __webpack_require__(93);
	
	exports.decode = function(data, level){
		return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
	};
	
	exports.decodeStrict = function(data, level){
		return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
	};
	
	exports.encode = function(data, level){
		return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
	};
	
	exports.encodeXML = encode.XML;
	
	exports.encodeHTML4 =
	exports.encodeHTML5 =
	exports.encodeHTML  = encode.HTML;
	
	exports.decodeXML =
	exports.decodeXMLStrict = decode.XML;
	
	exports.decodeHTML4 =
	exports.decodeHTML5 =
	exports.decodeHTML = decode.HTML;
	
	exports.decodeHTML4Strict =
	exports.decodeHTML5Strict =
	exports.decodeHTMLStrict = decode.HTMLStrict;
	
	exports.escape = encode.escape;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	var inverseXML = getInverseObj(__webpack_require__(91)),
	    xmlReplacer = getInverseReplacer(inverseXML);
	
	exports.XML = getInverse(inverseXML, xmlReplacer);
	
	var inverseHTML = getInverseObj(__webpack_require__(92)),
	    htmlReplacer = getInverseReplacer(inverseHTML);
	
	exports.HTML = getInverse(inverseHTML, htmlReplacer);
	
	function getInverseObj(obj){
		return Object.keys(obj).sort().reduce(function(inverse, name){
			inverse[obj[name]] = "&" + name + ";";
			return inverse;
		}, {});
	}
	
	function getInverseReplacer(inverse){
		var single = [],
		    multiple = [];
	
		Object.keys(inverse).forEach(function(k){
			if(k.length === 1){
				single.push("\\" + k);
			} else {
				multiple.push(k);
			}
		});
	
		//TODO add ranges
		multiple.unshift("[" + single.join("") + "]");
	
		return new RegExp(multiple.join("|"), "g");
	}
	
	var re_nonASCII = /[^\0-\x7F]/g,
	    re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	
	function singleCharReplacer(c){
		return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
	}
	
	function astralReplacer(c){
		// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
		var high = c.charCodeAt(0);
		var low  = c.charCodeAt(1);
		var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
		return "&#x" + codePoint.toString(16).toUpperCase() + ";";
	}
	
	function getInverse(inverse, re){
		function func(name){
			return inverse[name];
		}
	
		return function(data){
			return data
					.replace(re, func)
					.replace(re_astralSymbols, astralReplacer)
					.replace(re_nonASCII, singleCharReplacer);
		};
	}
	
	var re_xmlChars = getInverseReplacer(inverseXML);
	
	function escapeXML(data){
		return data
				.replace(re_xmlChars, singleCharReplacer)
				.replace(re_astralSymbols, astralReplacer)
				.replace(re_nonASCII, singleCharReplacer);
	}
	
	exports.escape = escapeXML;


/***/ }),
/* 91 */
/***/ (function(module, exports) {

	module.exports = {"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

/***/ }),
/* 92 */
/***/ (function(module, exports) {

	module.exports = {"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\"","QUOT":"\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""}

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	var entityMap = __webpack_require__(92),
	    legacyMap = __webpack_require__(94),
	    xmlMap    = __webpack_require__(91),
	    decodeCodePoint = __webpack_require__(95);
	
	var decodeXMLStrict  = getStrictDecoder(xmlMap),
	    decodeHTMLStrict = getStrictDecoder(entityMap);
	
	function getStrictDecoder(map){
		var keys = Object.keys(map).join("|"),
		    replace = getReplacer(map);
	
		keys += "|#[xX][\\da-fA-F]+|#\\d+";
	
		var re = new RegExp("&(?:" + keys + ");", "g");
	
		return function(str){
			return String(str).replace(re, replace);
		};
	}
	
	var decodeHTML = (function(){
		var legacy = Object.keys(legacyMap)
			.sort(sorter);
	
		var keys = Object.keys(entityMap)
			.sort(sorter);
	
		for(var i = 0, j = 0; i < keys.length; i++){
			if(legacy[j] === keys[i]){
				keys[i] += ";?";
				j++;
			} else {
				keys[i] += ";";
			}
		}
	
		var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
		    replace = getReplacer(entityMap);
	
		function replacer(str){
			if(str.substr(-1) !== ";") str += ";";
			return replace(str);
		}
	
		//TODO consider creating a merged map
		return function(str){
			return String(str).replace(re, replacer);
		};
	}());
	
	function sorter(a, b){
		return a < b ? 1 : -1;
	}
	
	function getReplacer(map){
		return function replace(str){
			if(str.charAt(1) === "#"){
				if(str.charAt(2) === "X" || str.charAt(2) === "x"){
					return decodeCodePoint(parseInt(str.substr(3), 16));
				}
				return decodeCodePoint(parseInt(str.substr(2), 10));
			}
			return map[str.slice(1, -1)];
		};
	}
	
	module.exports = {
		XML: decodeXMLStrict,
		HTML: decodeHTML,
		HTMLStrict: decodeHTMLStrict
	};

/***/ }),
/* 94 */
/***/ (function(module, exports) {

	module.exports = {"Aacute":"","aacute":"","Acirc":"","acirc":"","acute":"","AElig":"","aelig":"","Agrave":"","agrave":"","amp":"&","AMP":"&","Aring":"","aring":"","Atilde":"","atilde":"","Auml":"","auml":"","brvbar":"","Ccedil":"","ccedil":"","cedil":"","cent":"","copy":"","COPY":"","curren":"","deg":"","divide":"","Eacute":"","eacute":"","Ecirc":"","ecirc":"","Egrave":"","egrave":"","ETH":"","eth":"","Euml":"","euml":"","frac12":"","frac14":"","frac34":"","gt":">","GT":">","Iacute":"","iacute":"","Icirc":"","icirc":"","iexcl":"","Igrave":"","igrave":"","iquest":"","Iuml":"","iuml":"","laquo":"","lt":"<","LT":"<","macr":"","micro":"","middot":"","nbsp":"","not":"","Ntilde":"","ntilde":"","Oacute":"","oacute":"","Ocirc":"","ocirc":"","Ograve":"","ograve":"","ordf":"","ordm":"","Oslash":"","oslash":"","Otilde":"","otilde":"","Ouml":"","ouml":"","para":"","plusmn":"","pound":"","quot":"\"","QUOT":"\"","raquo":"","reg":"","REG":"","sect":"","shy":"","sup1":"","sup2":"","sup3":"","szlig":"","THORN":"","thorn":"","times":"","Uacute":"","uacute":"","Ucirc":"","ucirc":"","Ugrave":"","ugrave":"","uml":"","Uuml":"","uuml":"","Yacute":"","yacute":"","yen":"","yuml":""}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	var decodeMap = __webpack_require__(96);
	
	module.exports = decodeCodePoint;
	
	// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
	function decodeCodePoint(codePoint){
	
		if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
			return "\uFFFD";
		}
	
		if(codePoint in decodeMap){
			codePoint = decodeMap[codePoint];
		}
	
		var output = "";
	
		if(codePoint > 0xFFFF){
			codePoint -= 0x10000;
			output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
			codePoint = 0xDC00 | codePoint & 0x3FF;
		}
	
		output += String.fromCharCode(codePoint);
		return output;
	}


/***/ }),
/* 96 */
/***/ (function(module, exports) {

	module.exports = {"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var Node = __webpack_require__(84);
	var common = __webpack_require__(86);
	var normalizeReference = __webpack_require__(98);
	
	var normalizeURI = common.normalizeURI;
	var unescapeString = common.unescapeString;
	var fromCodePoint = __webpack_require__(99);
	var decodeHTML = __webpack_require__(89).decodeHTML;
	__webpack_require__(100); // Polyfill for String.prototype.repeat
	
	// Constants for character codes:
	
	var C_NEWLINE = 10;
	var C_ASTERISK = 42;
	var C_UNDERSCORE = 95;
	var C_BACKTICK = 96;
	var C_OPEN_BRACKET = 91;
	var C_CLOSE_BRACKET = 93;
	var C_LESSTHAN = 60;
	var C_BANG = 33;
	var C_BACKSLASH = 92;
	var C_AMPERSAND = 38;
	var C_OPEN_PAREN = 40;
	var C_CLOSE_PAREN = 41;
	var C_COLON = 58;
	var C_SINGLEQUOTE = 39;
	var C_DOUBLEQUOTE = 34;
	
	// Some regexps used in inline parser:
	
	var ESCAPABLE = common.ESCAPABLE;
	var ESCAPED_CHAR = '\\\\' + ESCAPABLE;
	var REG_CHAR = '[^\\\\()\\x00-\\x20]';
	var IN_PARENS_NOSP = '\\((' + REG_CHAR + '|' + ESCAPED_CHAR + '|\\\\)*\\)';
	
	var ENTITY = common.ENTITY;
	var reHtmlTag = common.reHtmlTag;
	
	var rePunctuation = new RegExp(/^[\u2000-\u206F\u2E00-\u2E7F\\'!"#\$%&\(\)\*\+,\-\.\/:;<=>\?@\[\]\^_`\{\|\}~]/);
	
	var reLinkTitle = new RegExp(
	    '^(?:"(' + ESCAPED_CHAR + '|[^"\\x00])*"' +
	        '|' +
	        '\'(' + ESCAPED_CHAR + '|[^\'\\x00])*\'' +
	        '|' +
	        '\\((' + ESCAPED_CHAR + '|[^)\\x00])*\\))');
	
	var reLinkDestinationBraces = new RegExp(
	    '^(?:[<](?:[^ <>\\t\\n\\\\\\x00]' + '|' + ESCAPED_CHAR + '|' + '\\\\)*[>])');
	
	var reLinkDestination = new RegExp(
	    '^(?:' + REG_CHAR + '+|' + ESCAPED_CHAR + '|\\\\|' + IN_PARENS_NOSP + ')*');
	
	var reEscapable = new RegExp('^' + ESCAPABLE);
	
	var reEntityHere = new RegExp('^' + ENTITY, 'i');
	
	var reTicks = /`+/;
	
	var reTicksHere = /^`+/;
	
	var reEllipses = /\.\.\./g;
	
	var reDash = /--+/g;
	
	var reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
	
	var reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i;
	
	var reSpnl = /^ *(?:\n *)?/;
	
	var reWhitespaceChar = /^\s/;
	
	var reWhitespace = /\s+/g;
	
	var reFinalSpace = / *$/;
	
	var reInitialSpace = /^ */;
	
	var reSpaceAtEndOfLine = /^ *(?:\n|$)/;
	
	var reLinkLabel = new RegExp('^\\[(?:[^\\\\\\[\\]]|' + ESCAPED_CHAR +
	  '|\\\\){0,1000}\\]');
	
	// Matches a string of non-special characters.
	var reMain = /^[^\n`\[\]\\!<&*_'"]+/m;
	
	var text = function(s) {
	    var node = new Node('text');
	    node._literal = s;
	    return node;
	};
	
	// INLINE PARSER
	
	// These are methods of an InlineParser object, defined below.
	// An InlineParser keeps track of a subject (a string to be
	// parsed) and a position in that subject.
	
	// If re matches at current position in the subject, advance
	// position in subject and return the match; otherwise return null.
	var match = function(re) {
	    var m = re.exec(this.subject.slice(this.pos));
	    if (m === null) {
	        return null;
	    } else {
	        this.pos += m.index + m[0].length;
	        return m[0];
	    }
	};
	
	// Returns the code for the character at the current subject position, or -1
	// there are no more characters.
	var peek = function() {
	    if (this.pos < this.subject.length) {
	        return this.subject.charCodeAt(this.pos);
	    } else {
	        return -1;
	    }
	};
	
	// Parse zero or more space characters, including at most one newline
	var spnl = function() {
	    this.match(reSpnl);
	    return true;
	};
	
	// All of the parsers below try to match something at the current position
	// in the subject.  If they succeed in matching anything, they
	// return the inline matched, advancing the subject.
	
	// Attempt to parse backticks, adding either a backtick code span or a
	// literal sequence of backticks.
	var parseBackticks = function(block) {
	    var ticks = this.match(reTicksHere);
	    if (ticks === null) {
	        return false;
	    }
	    var afterOpenTicks = this.pos;
	    var matched;
	    var node;
	    while ((matched = this.match(reTicks)) !== null) {
	        if (matched === ticks) {
	            node = new Node('code');
	            node._literal = this.subject.slice(afterOpenTicks,
	                                        this.pos - ticks.length)
	                          .trim().replace(reWhitespace, ' ');
	            block.appendChild(node);
	            return true;
	        }
	    }
	    // If we got here, we didn't match a closing backtick sequence.
	    this.pos = afterOpenTicks;
	    block.appendChild(text(ticks));
	    return true;
	};
	
	// Parse a backslash-escaped special character, adding either the escaped
	// character, a hard line break (if the backslash is followed by a newline),
	// or a literal backslash to the block's children.  Assumes current character
	// is a backslash.
	var parseBackslash = function(block) {
	    var subj = this.subject;
	    var node;
	    this.pos += 1;
	    if (this.peek() === C_NEWLINE) {
	        this.pos += 1;
	        node = new Node('linebreak');
	        block.appendChild(node);
	    } else if (reEscapable.test(subj.charAt(this.pos))) {
	        block.appendChild(text(subj.charAt(this.pos)));
	        this.pos += 1;
	    } else {
	        block.appendChild(text('\\'));
	    }
	    return true;
	};
	
	// Attempt to parse an autolink (URL or email in pointy brackets).
	var parseAutolink = function(block) {
	    var m;
	    var dest;
	    var node;
	    if ((m = this.match(reEmailAutolink))) {
	        dest = m.slice(1, m.length - 1);
	        node = new Node('link');
	        node._destination = normalizeURI('mailto:' + dest);
	        node._title = '';
	        node.appendChild(text(dest));
	        block.appendChild(node);
	        return true;
	    } else if ((m = this.match(reAutolink))) {
	        dest = m.slice(1, m.length - 1);
	        node = new Node('link');
	        node._destination = normalizeURI(dest);
	        node._title = '';
	        node.appendChild(text(dest));
	        block.appendChild(node);
	        return true;
	    } else {
	        return false;
	    }
	};
	
	// Attempt to parse a raw HTML tag.
	var parseHtmlTag = function(block) {
	    var m = this.match(reHtmlTag);
	    if (m === null) {
	        return false;
	    } else {
	        var node = new Node('html_inline');
	        node._literal = m;
	        block.appendChild(node);
	        return true;
	    }
	};
	
	// Scan a sequence of characters with code cc, and return information about
	// the number of delimiters and whether they are positioned such that
	// they can open and/or close emphasis or strong emphasis.  A utility
	// function for strong/emph parsing.
	var scanDelims = function(cc) {
	    var numdelims = 0;
	    var char_before, char_after, cc_after;
	    var startpos = this.pos;
	    var left_flanking, right_flanking, can_open, can_close;
	    var after_is_whitespace, after_is_punctuation, before_is_whitespace, before_is_punctuation;
	
	    if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
	        numdelims++;
	        this.pos++;
	    } else {
	        while (this.peek() === cc) {
	            numdelims++;
	            this.pos++;
	        }
	    }
	
	    if (numdelims === 0) {
	        return null;
	    }
	
	    char_before = startpos === 0 ? '\n' : this.subject.charAt(startpos - 1);
	
	    cc_after = this.peek();
	    if (cc_after === -1) {
	        char_after = '\n';
	    } else {
	        char_after = fromCodePoint(cc_after);
	    }
	
	    after_is_whitespace = reWhitespaceChar.test(char_after);
	    after_is_punctuation = rePunctuation.test(char_after);
	    before_is_whitespace = reWhitespaceChar.test(char_before);
	    before_is_punctuation = rePunctuation.test(char_before);
	
	    left_flanking = !after_is_whitespace &&
	            !(after_is_punctuation && !before_is_whitespace && !before_is_punctuation);
	    right_flanking = !before_is_whitespace &&
	            !(before_is_punctuation && !after_is_whitespace && !after_is_punctuation);
	    if (cc === C_UNDERSCORE) {
	        can_open = left_flanking &&
	            (!right_flanking || before_is_punctuation);
	        can_close = right_flanking &&
	            (!left_flanking || after_is_punctuation);
	    } else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
	        can_open = left_flanking && !right_flanking;
	        can_close = right_flanking;
	    } else {
	        can_open = left_flanking;
	        can_close = right_flanking;
	    }
	    this.pos = startpos;
	    return { numdelims: numdelims,
	             can_open: can_open,
	             can_close: can_close };
	};
	
	// Handle a delimiter marker for emphasis or a quote.
	var handleDelim = function(cc, block) {
	    var res = this.scanDelims(cc);
	    if (!res) {
	        return false;
	    }
	    var numdelims = res.numdelims;
	    var startpos = this.pos;
	    var contents;
	
	    this.pos += numdelims;
	    if (cc === C_SINGLEQUOTE) {
	        contents = "\u2019";
	    } else if (cc === C_DOUBLEQUOTE) {
	        contents = "\u201C";
	    } else {
	        contents = this.subject.slice(startpos, this.pos);
	    }
	    var node = text(contents);
	    block.appendChild(node);
	
	    // Add entry to stack for this opener
	    this.delimiters = { cc: cc,
	                        numdelims: numdelims,
	                        node: node,
	                        previous: this.delimiters,
	                        next: null,
	                        can_open: res.can_open,
	                        can_close: res.can_close };
	    if (this.delimiters.previous !== null) {
	        this.delimiters.previous.next = this.delimiters;
	    }
	
	    return true;
	
	};
	
	var removeDelimiter = function(delim) {
	    if (delim.previous !== null) {
	        delim.previous.next = delim.next;
	    }
	    if (delim.next === null) {
	        // top of stack
	        this.delimiters = delim.previous;
	    } else {
	        delim.next.previous = delim.previous;
	    }
	};
	
	var removeDelimitersBetween = function(bottom, top) {
	    if (bottom.next !== top) {
	        bottom.next = top;
	        top.previous = bottom;
	    }
	};
	
	var processEmphasis = function(stack_bottom) {
	    var opener, closer, old_closer;
	    var opener_inl, closer_inl;
	    var tempstack;
	    var use_delims;
	    var tmp, next;
	    var opener_found;
	    var openers_bottom = [];
	    var odd_match = false;
	
	    openers_bottom[C_UNDERSCORE] = stack_bottom;
	    openers_bottom[C_ASTERISK] = stack_bottom;
	    openers_bottom[C_SINGLEQUOTE] = stack_bottom;
	    openers_bottom[C_DOUBLEQUOTE] = stack_bottom;
	
	    // find first closer above stack_bottom:
	    closer = this.delimiters;
	    while (closer !== null && closer.previous !== stack_bottom) {
	        closer = closer.previous;
	    }
	    // move forward, looking for closers, and handling each
	    while (closer !== null) {
	        var closercc = closer.cc;
	        if (!closer.can_close) {
	            closer = closer.next;
	        } else {
	            // found emphasis closer. now look back for first matching opener:
	            opener = closer.previous;
	            opener_found = false;
	            while (opener !== null && opener !== stack_bottom &&
	                   opener !== openers_bottom[closercc]) {
	                odd_match = (closer.can_open || opener.can_close) &&
	                    (opener.numdelims + closer.numdelims) % 3 === 0;
	                if (opener.cc === closer.cc && opener.can_open && !odd_match) {
	                    opener_found = true;
	                    break;
	                }
	                opener = opener.previous;
	            }
	            old_closer = closer;
	
	            if (closercc === C_ASTERISK || closercc === C_UNDERSCORE) {
	                if (!opener_found) {
	                    closer = closer.next;
	                } else {
	                    // calculate actual number of delimiters used from closer
	                    if (closer.numdelims < 3 || opener.numdelims < 3) {
	                        use_delims = closer.numdelims <= opener.numdelims ?
	                            closer.numdelims : opener.numdelims;
	                    } else {
	                        use_delims = closer.numdelims % 2 === 0 ? 2 : 1;
	                    }
	
	                    opener_inl = opener.node;
	                    closer_inl = closer.node;
	
	                    // remove used delimiters from stack elts and inlines
	                    opener.numdelims -= use_delims;
	                    closer.numdelims -= use_delims;
	                    opener_inl._literal =
	                        opener_inl._literal.slice(0,
	                                                  opener_inl._literal.length - use_delims);
	                    closer_inl._literal =
	                        closer_inl._literal.slice(0,
	                                                  closer_inl._literal.length - use_delims);
	
	                    // build contents for new emph element
	                    var emph = new Node(use_delims === 1 ? 'emph' : 'strong');
	
	                    tmp = opener_inl._next;
	                    while (tmp && tmp !== closer_inl) {
	                        next = tmp._next;
	                        tmp.unlink();
	                        emph.appendChild(tmp);
	                        tmp = next;
	                    }
	
	                    opener_inl.insertAfter(emph);
	
	                    // remove elts between opener and closer in delimiters stack
	                    removeDelimitersBetween(opener, closer);
	
	                    // if opener has 0 delims, remove it and the inline
	                    if (opener.numdelims === 0) {
	                        opener_inl.unlink();
	                        this.removeDelimiter(opener);
	                    }
	
	                    if (closer.numdelims === 0) {
	                        closer_inl.unlink();
	                        tempstack = closer.next;
	                        this.removeDelimiter(closer);
	                        closer = tempstack;
	                    }
	
	                }
	
	            } else if (closercc === C_SINGLEQUOTE) {
	                closer.node._literal = "\u2019";
	                if (opener_found) {
	                    opener.node._literal = "\u2018";
	                }
	                closer = closer.next;
	
	            } else if (closercc === C_DOUBLEQUOTE) {
	                closer.node._literal = "\u201D";
	                if (opener_found) {
	                    opener.node.literal = "\u201C";
	                }
	                closer = closer.next;
	
	            }
	            if (!opener_found && !odd_match) {
	                // Set lower bound for future searches for openers:
	                // We don't do this with odd_match because a **
	                // that doesn't match an earlier * might turn into
	                // an opener, and the * might be matched by something
	                // else.
	                openers_bottom[closercc] = old_closer.previous;
	                if (!old_closer.can_open) {
	                    // We can remove a closer that can't be an opener,
	                    // once we've seen there's no matching opener:
	                    this.removeDelimiter(old_closer);
	                }
	            }
	        }
	
	    }
	
	    // remove all delimiters
	    while (this.delimiters !== null && this.delimiters !== stack_bottom) {
	        this.removeDelimiter(this.delimiters);
	    }
	};
	
	// Attempt to parse link title (sans quotes), returning the string
	// or null if no match.
	var parseLinkTitle = function() {
	    var title = this.match(reLinkTitle);
	    if (title === null) {
	        return null;
	    } else {
	        // chop off quotes from title and unescape:
	        return unescapeString(title.substr(1, title.length - 2));
	    }
	};
	
	// Attempt to parse link destination, returning the string or
	// null if no match.
	var parseLinkDestination = function() {
	    var res = this.match(reLinkDestinationBraces);
	    if (res === null) {
	        res = this.match(reLinkDestination);
	        if (res === null) {
	            return null;
	        } else {
	            return normalizeURI(unescapeString(res));
	        }
	    } else {  // chop off surrounding <..>:
	        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));
	    }
	};
	
	// Attempt to parse a link label, returning number of characters parsed.
	var parseLinkLabel = function() {
	    var m = this.match(reLinkLabel);
	    if (m === null || m.length > 1001) {
	        return 0;
	    } else {
	        return m.length;
	    }
	};
	
	// Add open bracket to delimiter stack and add a text node to block's children.
	var parseOpenBracket = function(block) {
	    var startpos = this.pos;
	    this.pos += 1;
	
	    var node = text('[');
	    block.appendChild(node);
	
	    // Add entry to stack for this opener
	    this.addBracket(node, startpos, false);
	    return true;
	};
	
	// IF next character is [, and ! delimiter to delimiter stack and
	// add a text node to block's children.  Otherwise just add a text node.
	var parseBang = function(block) {
	    var startpos = this.pos;
	    this.pos += 1;
	    if (this.peek() === C_OPEN_BRACKET) {
	        this.pos += 1;
	
	        var node = text('![');
	        block.appendChild(node);
	
	        // Add entry to stack for this opener
	        this.addBracket(node, startpos + 1, true);
	    } else {
	        block.appendChild(text('!'));
	    }
	    return true;
	};
	
	// Try to match close bracket against an opening in the delimiter
	// stack.  Add either a link or image, or a plain [ character,
	// to block's children.  If there is a matching delimiter,
	// remove it from the delimiter stack.
	var parseCloseBracket = function(block) {
	    var startpos;
	    var is_image;
	    var dest;
	    var title;
	    var matched = false;
	    var reflabel;
	    var opener;
	
	    this.pos += 1;
	    startpos = this.pos;
	
	    // get last [ or ![
	    opener = this.brackets;
	
	    if (opener === null) {
	        // no matched opener, just return a literal
	        block.appendChild(text(']'));
	        return true;
	    }
	
	    if (!opener.active) {
	        // no matched opener, just return a literal
	        block.appendChild(text(']'));
	        // take opener off brackets stack
	        this.removeBracket();
	        return true;
	    }
	
	    // If we got here, open is a potential opener
	    is_image = opener.image;
	
	    // Check to see if we have a link/image
	
	    // Inline link?
	    if (this.peek() === C_OPEN_PAREN) {
	        this.pos++;
	        if (this.spnl() &&
	            ((dest = this.parseLinkDestination()) !== null) &&
	            this.spnl() &&
	            // make sure there's a space before the title:
	            (reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&
	             (title = this.parseLinkTitle()) || true) &&
	            this.spnl() &&
	            this.peek() === C_CLOSE_PAREN) {
	            this.pos += 1;
	            matched = true;
	        }
	    } else {
	
	        // Next, see if there's a link label
	        var savepos = this.pos;
	        var beforelabel = this.pos;
	        var n = this.parseLinkLabel();
	        if (n > 2) {
	            reflabel = this.subject.slice(beforelabel, beforelabel + n);
	        } else if (!opener.bracketAfter) {
	            // Empty or missing second label means to use the first label as the reference.
	            // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.
	            reflabel = this.subject.slice(opener.index, startpos);
	        }
	        if (n === 0) {
	            // If shortcut reference link, rewind before spaces we skipped.
	            this.pos = savepos;
	        }
	
	        if (reflabel) {
	            // lookup rawlabel in refmap
	            var link = this.refmap[normalizeReference(reflabel)];
	            if (link) {
	                dest = link.destination;
	                title = link.title;
	                matched = true;
	            }
	        }
	    }
	
	    if (matched) {
	        var node = new Node(is_image ? 'image' : 'link');
	        node._destination = dest;
	        node._title = title || '';
	
	        var tmp, next;
	        tmp = opener.node._next;
	        while (tmp) {
	            next = tmp._next;
	            tmp.unlink();
	            node.appendChild(tmp);
	            tmp = next;
	        }
	        block.appendChild(node);
	        this.processEmphasis(opener.previousDelimiter);
	        this.removeBracket();
	        opener.node.unlink();
	
	        // We remove this bracket and processEmphasis will remove later delimiters.
	        // Now, for a link, we also deactivate earlier link openers.
	        // (no links in links)
	        if (!is_image) {
	          opener = this.brackets;
	          while (opener !== null) {
	            if (!opener.image) {
	                opener.active = false; // deactivate this opener
	            }
	            opener = opener.previous;
	          }
	        }
	
	        return true;
	
	    } else { // no match
	
	        this.removeBracket();  // remove this opener from stack
	        this.pos = startpos;
	        block.appendChild(text(']'));
	        return true;
	    }
	
	};
	
	var addBracket = function(node, index, image) {
	    if (this.brackets !== null) {
	        this.brackets.bracketAfter = true;
	    }
	    this.brackets = { node: node,
	                      previous: this.brackets,
	                      previousDelimiter: this.delimiters,
	                      index: index,
	                      image: image,
	                      active: true };
	};
	
	var removeBracket = function() {
	    this.brackets = this.brackets.previous;
	};
	
	// Attempt to parse an entity.
	var parseEntity = function(block) {
	    var m;
	    if ((m = this.match(reEntityHere))) {
	        block.appendChild(text(decodeHTML(m)));
	        return true;
	    } else {
	        return false;
	    }
	};
	
	// Parse a run of ordinary characters, or a single character with
	// a special meaning in markdown, as a plain string.
	var parseString = function(block) {
	    var m;
	    if ((m = this.match(reMain))) {
	        if (this.options.smart) {
	            block.appendChild(text(
	                m.replace(reEllipses, "\u2026")
	                    .replace(reDash, function(chars) {
	                        var enCount = 0;
	                        var emCount = 0;
	                        if (chars.length % 3 === 0) { // If divisible by 3, use all em dashes
	                            emCount = chars.length / 3;
	                        } else if (chars.length % 2 === 0) { // If divisible by 2, use all en dashes
	                            enCount = chars.length / 2;
	                        } else if (chars.length % 3 === 2) { // If 2 extra dashes, use en dash for last 2; em dashes for rest
	                            enCount = 1;
	                            emCount = (chars.length - 2) / 3;
	                        } else { // Use en dashes for last 4 hyphens; em dashes for rest
	                            enCount = 2;
	                            emCount = (chars.length - 4) / 3;
	                        }
	                        return "\u2014".repeat(emCount) + "\u2013".repeat(enCount);
	                    })));
	        } else {
	            block.appendChild(text(m));
	        }
	        return true;
	    } else {
	        return false;
	    }
	};
	
	// Parse a newline.  If it was preceded by two spaces, return a hard
	// line break; otherwise a soft line break.
	var parseNewline = function(block) {
	    this.pos += 1; // assume we're at a \n
	    // check previous node for trailing spaces
	    var lastc = block._lastChild;
	    if (lastc && lastc.type === 'text' && lastc._literal[lastc._literal.length - 1] === ' ') {
	        var hardbreak = lastc._literal[lastc._literal.length - 2] === ' ';
	        lastc._literal = lastc._literal.replace(reFinalSpace, '');
	        block.appendChild(new Node(hardbreak ? 'linebreak' : 'softbreak'));
	    } else {
	        block.appendChild(new Node('softbreak'));
	    }
	    this.match(reInitialSpace); // gobble leading spaces in next line
	    return true;
	};
	
	// Attempt to parse a link reference, modifying refmap.
	var parseReference = function(s, refmap) {
	    this.subject = s;
	    this.pos = 0;
	    var rawlabel;
	    var dest;
	    var title;
	    var matchChars;
	    var startpos = this.pos;
	
	    // label:
	    matchChars = this.parseLinkLabel();
	    if (matchChars === 0) {
	        return 0;
	    } else {
	        rawlabel = this.subject.substr(0, matchChars);
	    }
	
	    // colon:
	    if (this.peek() === C_COLON) {
	        this.pos++;
	    } else {
	        this.pos = startpos;
	        return 0;
	    }
	
	    //  link url
	    this.spnl();
	
	    dest = this.parseLinkDestination();
	    if (dest === null || dest.length === 0) {
	        this.pos = startpos;
	        return 0;
	    }
	
	    var beforetitle = this.pos;
	    this.spnl();
	    title = this.parseLinkTitle();
	    if (title === null) {
	        title = '';
	        // rewind before spaces
	        this.pos = beforetitle;
	    }
	
	    // make sure we're at line end:
	    var atLineEnd = true;
	    if (this.match(reSpaceAtEndOfLine) === null) {
	        if (title === '') {
	            atLineEnd = false;
	        } else {
	            // the potential title we found is not at the line end,
	            // but it could still be a legal link reference if we
	            // discard the title
	            title = '';
	            // rewind before spaces
	            this.pos = beforetitle;
	            // and instead check if the link URL is at the line end
	            atLineEnd = this.match(reSpaceAtEndOfLine) !== null;
	        }
	    }
	
	    if (!atLineEnd) {
	        this.pos = startpos;
	        return 0;
	    }
	
	    var normlabel = normalizeReference(rawlabel);
	    if (normlabel === '') {
	        // label must contain non-whitespace characters
	        this.pos = startpos;
	        return 0;
	    }
	
	    if (!refmap[normlabel]) {
	        refmap[normlabel] = { destination: dest, title: title };
	    }
	    return this.pos - startpos;
	};
	
	// Parse the next inline element in subject, advancing subject position.
	// On success, add the result to block's children and return true.
	// On failure, return false.
	var parseInline = function(block) {
	    var res = false;
	    var c = this.peek();
	    if (c === -1) {
	        return false;
	    }
	    switch(c) {
	    case C_NEWLINE:
	        res = this.parseNewline(block);
	        break;
	    case C_BACKSLASH:
	        res = this.parseBackslash(block);
	        break;
	    case C_BACKTICK:
	        res = this.parseBackticks(block);
	        break;
	    case C_ASTERISK:
	    case C_UNDERSCORE:
	        res = this.handleDelim(c, block);
	        break;
	    case C_SINGLEQUOTE:
	    case C_DOUBLEQUOTE:
	        res = this.options.smart && this.handleDelim(c, block);
	        break;
	    case C_OPEN_BRACKET:
	        res = this.parseOpenBracket(block);
	        break;
	    case C_BANG:
	        res = this.parseBang(block);
	        break;
	    case C_CLOSE_BRACKET:
	        res = this.parseCloseBracket(block);
	        break;
	    case C_LESSTHAN:
	        res = this.parseAutolink(block) || this.parseHtmlTag(block);
	        break;
	    case C_AMPERSAND:
	        res = this.parseEntity(block);
	        break;
	    default:
	        res = this.parseString(block);
	        break;
	    }
	    if (!res) {
	        this.pos += 1;
	        block.appendChild(text(fromCodePoint(c)));
	    }
	
	    return true;
	};
	
	// Parse string content in block into inline children,
	// using refmap to resolve references.
	var parseInlines = function(block) {
	    this.subject = block._string_content.trim();
	    this.pos = 0;
	    this.delimiters = null;
	    this.brackets = null;
	    while (this.parseInline(block)) {
	    }
	    block._string_content = null; // allow raw string to be garbage collected
	    this.processEmphasis(null);
	};
	
	// The InlineParser object.
	function InlineParser(options){
	    return {
	        subject: '',
	        delimiters: null,  // used by handleDelim method
	        brackets: null,
	        pos: 0,
	        refmap: {},
	        match: match,
	        peek: peek,
	        spnl: spnl,
	        parseBackticks: parseBackticks,
	        parseBackslash: parseBackslash,
	        parseAutolink: parseAutolink,
	        parseHtmlTag: parseHtmlTag,
	        scanDelims: scanDelims,
	        handleDelim: handleDelim,
	        parseLinkTitle: parseLinkTitle,
	        parseLinkDestination: parseLinkDestination,
	        parseLinkLabel: parseLinkLabel,
	        parseOpenBracket: parseOpenBracket,
	        parseBang: parseBang,
	        parseCloseBracket: parseCloseBracket,
	        addBracket: addBracket,
	        removeBracket: removeBracket,
	        parseEntity: parseEntity,
	        parseString: parseString,
	        parseNewline: parseNewline,
	        parseReference: parseReference,
	        parseInline: parseInline,
	        processEmphasis: processEmphasis,
	        removeDelimiter: removeDelimiter,
	        options: options || {},
	        parse: parseInlines
	    };
	}
	
	module.exports = InlineParser;


/***/ }),
/* 98 */
/***/ (function(module, exports) {

	"use strict";
	
	/* The bulk of this code derives from https://github.com/dmoscrop/fold-case
	But in addition to case-folding, we also normalize whitespace.
	
	fold-case is Copyright Mathias Bynens <https://mathiasbynens.be/>
	
	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	*/
	
	/*eslint-disable  key-spacing, comma-spacing */
	
	var regex = /[ \t\r\n]+|[A-Z\xB5\xC0-\xD6\xD8-\xDF\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u0149\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u017F\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C5\u01C7\u01C8\u01CA\u01CB\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F0-\u01F2\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0345\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03AB\u03B0\u03C2\u03CF-\u03D1\u03D5\u03D6\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F0\u03F1\u03F4\u03F5\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u0587\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E96-\u1E9B\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F50\u1F52\u1F54\u1F56\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1F80-\u1FAF\u1FB2-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD2\u1FD3\u1FD6-\u1FDB\u1FE2-\u1FE4\u1FE6-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2126\u212A\u212B\u2132\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0\uA7B1\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27]|\uD806[\uDCA0-\uDCBF]/g;
	
	var map = {'A':'a','B':'b','C':'c','D':'d','E':'e','F':'f','G':'g','H':'h','I':'i','J':'j','K':'k','L':'l','M':'m','N':'n','O':'o','P':'p','Q':'q','R':'r','S':'s','T':'t','U':'u','V':'v','W':'w','X':'x','Y':'y','Z':'z','\xB5':'\u03BC','\xC0':'\xE0','\xC1':'\xE1','\xC2':'\xE2','\xC3':'\xE3','\xC4':'\xE4','\xC5':'\xE5','\xC6':'\xE6','\xC7':'\xE7','\xC8':'\xE8','\xC9':'\xE9','\xCA':'\xEA','\xCB':'\xEB','\xCC':'\xEC','\xCD':'\xED','\xCE':'\xEE','\xCF':'\xEF','\xD0':'\xF0','\xD1':'\xF1','\xD2':'\xF2','\xD3':'\xF3','\xD4':'\xF4','\xD5':'\xF5','\xD6':'\xF6','\xD8':'\xF8','\xD9':'\xF9','\xDA':'\xFA','\xDB':'\xFB','\xDC':'\xFC','\xDD':'\xFD','\xDE':'\xFE','\u0100':'\u0101','\u0102':'\u0103','\u0104':'\u0105','\u0106':'\u0107','\u0108':'\u0109','\u010A':'\u010B','\u010C':'\u010D','\u010E':'\u010F','\u0110':'\u0111','\u0112':'\u0113','\u0114':'\u0115','\u0116':'\u0117','\u0118':'\u0119','\u011A':'\u011B','\u011C':'\u011D','\u011E':'\u011F','\u0120':'\u0121','\u0122':'\u0123','\u0124':'\u0125','\u0126':'\u0127','\u0128':'\u0129','\u012A':'\u012B','\u012C':'\u012D','\u012E':'\u012F','\u0132':'\u0133','\u0134':'\u0135','\u0136':'\u0137','\u0139':'\u013A','\u013B':'\u013C','\u013D':'\u013E','\u013F':'\u0140','\u0141':'\u0142','\u0143':'\u0144','\u0145':'\u0146','\u0147':'\u0148','\u014A':'\u014B','\u014C':'\u014D','\u014E':'\u014F','\u0150':'\u0151','\u0152':'\u0153','\u0154':'\u0155','\u0156':'\u0157','\u0158':'\u0159','\u015A':'\u015B','\u015C':'\u015D','\u015E':'\u015F','\u0160':'\u0161','\u0162':'\u0163','\u0164':'\u0165','\u0166':'\u0167','\u0168':'\u0169','\u016A':'\u016B','\u016C':'\u016D','\u016E':'\u016F','\u0170':'\u0171','\u0172':'\u0173','\u0174':'\u0175','\u0176':'\u0177','\u0178':'\xFF','\u0179':'\u017A','\u017B':'\u017C','\u017D':'\u017E','\u017F':'s','\u0181':'\u0253','\u0182':'\u0183','\u0184':'\u0185','\u0186':'\u0254','\u0187':'\u0188','\u0189':'\u0256','\u018A':'\u0257','\u018B':'\u018C','\u018E':'\u01DD','\u018F':'\u0259','\u0190':'\u025B','\u0191':'\u0192','\u0193':'\u0260','\u0194':'\u0263','\u0196':'\u0269','\u0197':'\u0268','\u0198':'\u0199','\u019C':'\u026F','\u019D':'\u0272','\u019F':'\u0275','\u01A0':'\u01A1','\u01A2':'\u01A3','\u01A4':'\u01A5','\u01A6':'\u0280','\u01A7':'\u01A8','\u01A9':'\u0283','\u01AC':'\u01AD','\u01AE':'\u0288','\u01AF':'\u01B0','\u01B1':'\u028A','\u01B2':'\u028B','\u01B3':'\u01B4','\u01B5':'\u01B6','\u01B7':'\u0292','\u01B8':'\u01B9','\u01BC':'\u01BD','\u01C4':'\u01C6','\u01C5':'\u01C6','\u01C7':'\u01C9','\u01C8':'\u01C9','\u01CA':'\u01CC','\u01CB':'\u01CC','\u01CD':'\u01CE','\u01CF':'\u01D0','\u01D1':'\u01D2','\u01D3':'\u01D4','\u01D5':'\u01D6','\u01D7':'\u01D8','\u01D9':'\u01DA','\u01DB':'\u01DC','\u01DE':'\u01DF','\u01E0':'\u01E1','\u01E2':'\u01E3','\u01E4':'\u01E5','\u01E6':'\u01E7','\u01E8':'\u01E9','\u01EA':'\u01EB','\u01EC':'\u01ED','\u01EE':'\u01EF','\u01F1':'\u01F3','\u01F2':'\u01F3','\u01F4':'\u01F5','\u01F6':'\u0195','\u01F7':'\u01BF','\u01F8':'\u01F9','\u01FA':'\u01FB','\u01FC':'\u01FD','\u01FE':'\u01FF','\u0200':'\u0201','\u0202':'\u0203','\u0204':'\u0205','\u0206':'\u0207','\u0208':'\u0209','\u020A':'\u020B','\u020C':'\u020D','\u020E':'\u020F','\u0210':'\u0211','\u0212':'\u0213','\u0214':'\u0215','\u0216':'\u0217','\u0218':'\u0219','\u021A':'\u021B','\u021C':'\u021D','\u021E':'\u021F','\u0220':'\u019E','\u0222':'\u0223','\u0224':'\u0225','\u0226':'\u0227','\u0228':'\u0229','\u022A':'\u022B','\u022C':'\u022D','\u022E':'\u022F','\u0230':'\u0231','\u0232':'\u0233','\u023A':'\u2C65','\u023B':'\u023C','\u023D':'\u019A','\u023E':'\u2C66','\u0241':'\u0242','\u0243':'\u0180','\u0244':'\u0289','\u0245':'\u028C','\u0246':'\u0247','\u0248':'\u0249','\u024A':'\u024B','\u024C':'\u024D','\u024E':'\u024F','\u0345':'\u03B9','\u0370':'\u0371','\u0372':'\u0373','\u0376':'\u0377','\u037F':'\u03F3','\u0386':'\u03AC','\u0388':'\u03AD','\u0389':'\u03AE','\u038A':'\u03AF','\u038C':'\u03CC','\u038E':'\u03CD','\u038F':'\u03CE','\u0391':'\u03B1','\u0392':'\u03B2','\u0393':'\u03B3','\u0394':'\u03B4','\u0395':'\u03B5','\u0396':'\u03B6','\u0397':'\u03B7','\u0398':'\u03B8','\u0399':'\u03B9','\u039A':'\u03BA','\u039B':'\u03BB','\u039C':'\u03BC','\u039D':'\u03BD','\u039E':'\u03BE','\u039F':'\u03BF','\u03A0':'\u03C0','\u03A1':'\u03C1','\u03A3':'\u03C3','\u03A4':'\u03C4','\u03A5':'\u03C5','\u03A6':'\u03C6','\u03A7':'\u03C7','\u03A8':'\u03C8','\u03A9':'\u03C9','\u03AA':'\u03CA','\u03AB':'\u03CB','\u03C2':'\u03C3','\u03CF':'\u03D7','\u03D0':'\u03B2','\u03D1':'\u03B8','\u03D5':'\u03C6','\u03D6':'\u03C0','\u03D8':'\u03D9','\u03DA':'\u03DB','\u03DC':'\u03DD','\u03DE':'\u03DF','\u03E0':'\u03E1','\u03E2':'\u03E3','\u03E4':'\u03E5','\u03E6':'\u03E7','\u03E8':'\u03E9','\u03EA':'\u03EB','\u03EC':'\u03ED','\u03EE':'\u03EF','\u03F0':'\u03BA','\u03F1':'\u03C1','\u03F4':'\u03B8','\u03F5':'\u03B5','\u03F7':'\u03F8','\u03F9':'\u03F2','\u03FA':'\u03FB','\u03FD':'\u037B','\u03FE':'\u037C','\u03FF':'\u037D','\u0400':'\u0450','\u0401':'\u0451','\u0402':'\u0452','\u0403':'\u0453','\u0404':'\u0454','\u0405':'\u0455','\u0406':'\u0456','\u0407':'\u0457','\u0408':'\u0458','\u0409':'\u0459','\u040A':'\u045A','\u040B':'\u045B','\u040C':'\u045C','\u040D':'\u045D','\u040E':'\u045E','\u040F':'\u045F','\u0410':'\u0430','\u0411':'\u0431','\u0412':'\u0432','\u0413':'\u0433','\u0414':'\u0434','\u0415':'\u0435','\u0416':'\u0436','\u0417':'\u0437','\u0418':'\u0438','\u0419':'\u0439','\u041A':'\u043A','\u041B':'\u043B','\u041C':'\u043C','\u041D':'\u043D','\u041E':'\u043E','\u041F':'\u043F','\u0420':'\u0440','\u0421':'\u0441','\u0422':'\u0442','\u0423':'\u0443','\u0424':'\u0444','\u0425':'\u0445','\u0426':'\u0446','\u0427':'\u0447','\u0428':'\u0448','\u0429':'\u0449','\u042A':'\u044A','\u042B':'\u044B','\u042C':'\u044C','\u042D':'\u044D','\u042E':'\u044E','\u042F':'\u044F','\u0460':'\u0461','\u0462':'\u0463','\u0464':'\u0465','\u0466':'\u0467','\u0468':'\u0469','\u046A':'\u046B','\u046C':'\u046D','\u046E':'\u046F','\u0470':'\u0471','\u0472':'\u0473','\u0474':'\u0475','\u0476':'\u0477','\u0478':'\u0479','\u047A':'\u047B','\u047C':'\u047D','\u047E':'\u047F','\u0480':'\u0481','\u048A':'\u048B','\u048C':'\u048D','\u048E':'\u048F','\u0490':'\u0491','\u0492':'\u0493','\u0494':'\u0495','\u0496':'\u0497','\u0498':'\u0499','\u049A':'\u049B','\u049C':'\u049D','\u049E':'\u049F','\u04A0':'\u04A1','\u04A2':'\u04A3','\u04A4':'\u04A5','\u04A6':'\u04A7','\u04A8':'\u04A9','\u04AA':'\u04AB','\u04AC':'\u04AD','\u04AE':'\u04AF','\u04B0':'\u04B1','\u04B2':'\u04B3','\u04B4':'\u04B5','\u04B6':'\u04B7','\u04B8':'\u04B9','\u04BA':'\u04BB','\u04BC':'\u04BD','\u04BE':'\u04BF','\u04C0':'\u04CF','\u04C1':'\u04C2','\u04C3':'\u04C4','\u04C5':'\u04C6','\u04C7':'\u04C8','\u04C9':'\u04CA','\u04CB':'\u04CC','\u04CD':'\u04CE','\u04D0':'\u04D1','\u04D2':'\u04D3','\u04D4':'\u04D5','\u04D6':'\u04D7','\u04D8':'\u04D9','\u04DA':'\u04DB','\u04DC':'\u04DD','\u04DE':'\u04DF','\u04E0':'\u04E1','\u04E2':'\u04E3','\u04E4':'\u04E5','\u04E6':'\u04E7','\u04E8':'\u04E9','\u04EA':'\u04EB','\u04EC':'\u04ED','\u04EE':'\u04EF','\u04F0':'\u04F1','\u04F2':'\u04F3','\u04F4':'\u04F5','\u04F6':'\u04F7','\u04F8':'\u04F9','\u04FA':'\u04FB','\u04FC':'\u04FD','\u04FE':'\u04FF','\u0500':'\u0501','\u0502':'\u0503','\u0504':'\u0505','\u0506':'\u0507','\u0508':'\u0509','\u050A':'\u050B','\u050C':'\u050D','\u050E':'\u050F','\u0510':'\u0511','\u0512':'\u0513','\u0514':'\u0515','\u0516':'\u0517','\u0518':'\u0519','\u051A':'\u051B','\u051C':'\u051D','\u051E':'\u051F','\u0520':'\u0521','\u0522':'\u0523','\u0524':'\u0525','\u0526':'\u0527','\u0528':'\u0529','\u052A':'\u052B','\u052C':'\u052D','\u052E':'\u052F','\u0531':'\u0561','\u0532':'\u0562','\u0533':'\u0563','\u0534':'\u0564','\u0535':'\u0565','\u0536':'\u0566','\u0537':'\u0567','\u0538':'\u0568','\u0539':'\u0569','\u053A':'\u056A','\u053B':'\u056B','\u053C':'\u056C','\u053D':'\u056D','\u053E':'\u056E','\u053F':'\u056F','\u0540':'\u0570','\u0541':'\u0571','\u0542':'\u0572','\u0543':'\u0573','\u0544':'\u0574','\u0545':'\u0575','\u0546':'\u0576','\u0547':'\u0577','\u0548':'\u0578','\u0549':'\u0579','\u054A':'\u057A','\u054B':'\u057B','\u054C':'\u057C','\u054D':'\u057D','\u054E':'\u057E','\u054F':'\u057F','\u0550':'\u0580','\u0551':'\u0581','\u0552':'\u0582','\u0553':'\u0583','\u0554':'\u0584','\u0555':'\u0585','\u0556':'\u0586','\u10A0':'\u2D00','\u10A1':'\u2D01','\u10A2':'\u2D02','\u10A3':'\u2D03','\u10A4':'\u2D04','\u10A5':'\u2D05','\u10A6':'\u2D06','\u10A7':'\u2D07','\u10A8':'\u2D08','\u10A9':'\u2D09','\u10AA':'\u2D0A','\u10AB':'\u2D0B','\u10AC':'\u2D0C','\u10AD':'\u2D0D','\u10AE':'\u2D0E','\u10AF':'\u2D0F','\u10B0':'\u2D10','\u10B1':'\u2D11','\u10B2':'\u2D12','\u10B3':'\u2D13','\u10B4':'\u2D14','\u10B5':'\u2D15','\u10B6':'\u2D16','\u10B7':'\u2D17','\u10B8':'\u2D18','\u10B9':'\u2D19','\u10BA':'\u2D1A','\u10BB':'\u2D1B','\u10BC':'\u2D1C','\u10BD':'\u2D1D','\u10BE':'\u2D1E','\u10BF':'\u2D1F','\u10C0':'\u2D20','\u10C1':'\u2D21','\u10C2':'\u2D22','\u10C3':'\u2D23','\u10C4':'\u2D24','\u10C5':'\u2D25','\u10C7':'\u2D27','\u10CD':'\u2D2D','\u1E00':'\u1E01','\u1E02':'\u1E03','\u1E04':'\u1E05','\u1E06':'\u1E07','\u1E08':'\u1E09','\u1E0A':'\u1E0B','\u1E0C':'\u1E0D','\u1E0E':'\u1E0F','\u1E10':'\u1E11','\u1E12':'\u1E13','\u1E14':'\u1E15','\u1E16':'\u1E17','\u1E18':'\u1E19','\u1E1A':'\u1E1B','\u1E1C':'\u1E1D','\u1E1E':'\u1E1F','\u1E20':'\u1E21','\u1E22':'\u1E23','\u1E24':'\u1E25','\u1E26':'\u1E27','\u1E28':'\u1E29','\u1E2A':'\u1E2B','\u1E2C':'\u1E2D','\u1E2E':'\u1E2F','\u1E30':'\u1E31','\u1E32':'\u1E33','\u1E34':'\u1E35','\u1E36':'\u1E37','\u1E38':'\u1E39','\u1E3A':'\u1E3B','\u1E3C':'\u1E3D','\u1E3E':'\u1E3F','\u1E40':'\u1E41','\u1E42':'\u1E43','\u1E44':'\u1E45','\u1E46':'\u1E47','\u1E48':'\u1E49','\u1E4A':'\u1E4B','\u1E4C':'\u1E4D','\u1E4E':'\u1E4F','\u1E50':'\u1E51','\u1E52':'\u1E53','\u1E54':'\u1E55','\u1E56':'\u1E57','\u1E58':'\u1E59','\u1E5A':'\u1E5B','\u1E5C':'\u1E5D','\u1E5E':'\u1E5F','\u1E60':'\u1E61','\u1E62':'\u1E63','\u1E64':'\u1E65','\u1E66':'\u1E67','\u1E68':'\u1E69','\u1E6A':'\u1E6B','\u1E6C':'\u1E6D','\u1E6E':'\u1E6F','\u1E70':'\u1E71','\u1E72':'\u1E73','\u1E74':'\u1E75','\u1E76':'\u1E77','\u1E78':'\u1E79','\u1E7A':'\u1E7B','\u1E7C':'\u1E7D','\u1E7E':'\u1E7F','\u1E80':'\u1E81','\u1E82':'\u1E83','\u1E84':'\u1E85','\u1E86':'\u1E87','\u1E88':'\u1E89','\u1E8A':'\u1E8B','\u1E8C':'\u1E8D','\u1E8E':'\u1E8F','\u1E90':'\u1E91','\u1E92':'\u1E93','\u1E94':'\u1E95','\u1E9B':'\u1E61','\u1EA0':'\u1EA1','\u1EA2':'\u1EA3','\u1EA4':'\u1EA5','\u1EA6':'\u1EA7','\u1EA8':'\u1EA9','\u1EAA':'\u1EAB','\u1EAC':'\u1EAD','\u1EAE':'\u1EAF','\u1EB0':'\u1EB1','\u1EB2':'\u1EB3','\u1EB4':'\u1EB5','\u1EB6':'\u1EB7','\u1EB8':'\u1EB9','\u1EBA':'\u1EBB','\u1EBC':'\u1EBD','\u1EBE':'\u1EBF','\u1EC0':'\u1EC1','\u1EC2':'\u1EC3','\u1EC4':'\u1EC5','\u1EC6':'\u1EC7','\u1EC8':'\u1EC9','\u1ECA':'\u1ECB','\u1ECC':'\u1ECD','\u1ECE':'\u1ECF','\u1ED0':'\u1ED1','\u1ED2':'\u1ED3','\u1ED4':'\u1ED5','\u1ED6':'\u1ED7','\u1ED8':'\u1ED9','\u1EDA':'\u1EDB','\u1EDC':'\u1EDD','\u1EDE':'\u1EDF','\u1EE0':'\u1EE1','\u1EE2':'\u1EE3','\u1EE4':'\u1EE5','\u1EE6':'\u1EE7','\u1EE8':'\u1EE9','\u1EEA':'\u1EEB','\u1EEC':'\u1EED','\u1EEE':'\u1EEF','\u1EF0':'\u1EF1','\u1EF2':'\u1EF3','\u1EF4':'\u1EF5','\u1EF6':'\u1EF7','\u1EF8':'\u1EF9','\u1EFA':'\u1EFB','\u1EFC':'\u1EFD','\u1EFE':'\u1EFF','\u1F08':'\u1F00','\u1F09':'\u1F01','\u1F0A':'\u1F02','\u1F0B':'\u1F03','\u1F0C':'\u1F04','\u1F0D':'\u1F05','\u1F0E':'\u1F06','\u1F0F':'\u1F07','\u1F18':'\u1F10','\u1F19':'\u1F11','\u1F1A':'\u1F12','\u1F1B':'\u1F13','\u1F1C':'\u1F14','\u1F1D':'\u1F15','\u1F28':'\u1F20','\u1F29':'\u1F21','\u1F2A':'\u1F22','\u1F2B':'\u1F23','\u1F2C':'\u1F24','\u1F2D':'\u1F25','\u1F2E':'\u1F26','\u1F2F':'\u1F27','\u1F38':'\u1F30','\u1F39':'\u1F31','\u1F3A':'\u1F32','\u1F3B':'\u1F33','\u1F3C':'\u1F34','\u1F3D':'\u1F35','\u1F3E':'\u1F36','\u1F3F':'\u1F37','\u1F48':'\u1F40','\u1F49':'\u1F41','\u1F4A':'\u1F42','\u1F4B':'\u1F43','\u1F4C':'\u1F44','\u1F4D':'\u1F45','\u1F59':'\u1F51','\u1F5B':'\u1F53','\u1F5D':'\u1F55','\u1F5F':'\u1F57','\u1F68':'\u1F60','\u1F69':'\u1F61','\u1F6A':'\u1F62','\u1F6B':'\u1F63','\u1F6C':'\u1F64','\u1F6D':'\u1F65','\u1F6E':'\u1F66','\u1F6F':'\u1F67','\u1FB8':'\u1FB0','\u1FB9':'\u1FB1','\u1FBA':'\u1F70','\u1FBB':'\u1F71','\u1FBE':'\u03B9','\u1FC8':'\u1F72','\u1FC9':'\u1F73','\u1FCA':'\u1F74','\u1FCB':'\u1F75','\u1FD8':'\u1FD0','\u1FD9':'\u1FD1','\u1FDA':'\u1F76','\u1FDB':'\u1F77','\u1FE8':'\u1FE0','\u1FE9':'\u1FE1','\u1FEA':'\u1F7A','\u1FEB':'\u1F7B','\u1FEC':'\u1FE5','\u1FF8':'\u1F78','\u1FF9':'\u1F79','\u1FFA':'\u1F7C','\u1FFB':'\u1F7D','\u2126':'\u03C9','\u212A':'k','\u212B':'\xE5','\u2132':'\u214E','\u2160':'\u2170','\u2161':'\u2171','\u2162':'\u2172','\u2163':'\u2173','\u2164':'\u2174','\u2165':'\u2175','\u2166':'\u2176','\u2167':'\u2177','\u2168':'\u2178','\u2169':'\u2179','\u216A':'\u217A','\u216B':'\u217B','\u216C':'\u217C','\u216D':'\u217D','\u216E':'\u217E','\u216F':'\u217F','\u2183':'\u2184','\u24B6':'\u24D0','\u24B7':'\u24D1','\u24B8':'\u24D2','\u24B9':'\u24D3','\u24BA':'\u24D4','\u24BB':'\u24D5','\u24BC':'\u24D6','\u24BD':'\u24D7','\u24BE':'\u24D8','\u24BF':'\u24D9','\u24C0':'\u24DA','\u24C1':'\u24DB','\u24C2':'\u24DC','\u24C3':'\u24DD','\u24C4':'\u24DE','\u24C5':'\u24DF','\u24C6':'\u24E0','\u24C7':'\u24E1','\u24C8':'\u24E2','\u24C9':'\u24E3','\u24CA':'\u24E4','\u24CB':'\u24E5','\u24CC':'\u24E6','\u24CD':'\u24E7','\u24CE':'\u24E8','\u24CF':'\u24E9','\u2C00':'\u2C30','\u2C01':'\u2C31','\u2C02':'\u2C32','\u2C03':'\u2C33','\u2C04':'\u2C34','\u2C05':'\u2C35','\u2C06':'\u2C36','\u2C07':'\u2C37','\u2C08':'\u2C38','\u2C09':'\u2C39','\u2C0A':'\u2C3A','\u2C0B':'\u2C3B','\u2C0C':'\u2C3C','\u2C0D':'\u2C3D','\u2C0E':'\u2C3E','\u2C0F':'\u2C3F','\u2C10':'\u2C40','\u2C11':'\u2C41','\u2C12':'\u2C42','\u2C13':'\u2C43','\u2C14':'\u2C44','\u2C15':'\u2C45','\u2C16':'\u2C46','\u2C17':'\u2C47','\u2C18':'\u2C48','\u2C19':'\u2C49','\u2C1A':'\u2C4A','\u2C1B':'\u2C4B','\u2C1C':'\u2C4C','\u2C1D':'\u2C4D','\u2C1E':'\u2C4E','\u2C1F':'\u2C4F','\u2C20':'\u2C50','\u2C21':'\u2C51','\u2C22':'\u2C52','\u2C23':'\u2C53','\u2C24':'\u2C54','\u2C25':'\u2C55','\u2C26':'\u2C56','\u2C27':'\u2C57','\u2C28':'\u2C58','\u2C29':'\u2C59','\u2C2A':'\u2C5A','\u2C2B':'\u2C5B','\u2C2C':'\u2C5C','\u2C2D':'\u2C5D','\u2C2E':'\u2C5E','\u2C60':'\u2C61','\u2C62':'\u026B','\u2C63':'\u1D7D','\u2C64':'\u027D','\u2C67':'\u2C68','\u2C69':'\u2C6A','\u2C6B':'\u2C6C','\u2C6D':'\u0251','\u2C6E':'\u0271','\u2C6F':'\u0250','\u2C70':'\u0252','\u2C72':'\u2C73','\u2C75':'\u2C76','\u2C7E':'\u023F','\u2C7F':'\u0240','\u2C80':'\u2C81','\u2C82':'\u2C83','\u2C84':'\u2C85','\u2C86':'\u2C87','\u2C88':'\u2C89','\u2C8A':'\u2C8B','\u2C8C':'\u2C8D','\u2C8E':'\u2C8F','\u2C90':'\u2C91','\u2C92':'\u2C93','\u2C94':'\u2C95','\u2C96':'\u2C97','\u2C98':'\u2C99','\u2C9A':'\u2C9B','\u2C9C':'\u2C9D','\u2C9E':'\u2C9F','\u2CA0':'\u2CA1','\u2CA2':'\u2CA3','\u2CA4':'\u2CA5','\u2CA6':'\u2CA7','\u2CA8':'\u2CA9','\u2CAA':'\u2CAB','\u2CAC':'\u2CAD','\u2CAE':'\u2CAF','\u2CB0':'\u2CB1','\u2CB2':'\u2CB3','\u2CB4':'\u2CB5','\u2CB6':'\u2CB7','\u2CB8':'\u2CB9','\u2CBA':'\u2CBB','\u2CBC':'\u2CBD','\u2CBE':'\u2CBF','\u2CC0':'\u2CC1','\u2CC2':'\u2CC3','\u2CC4':'\u2CC5','\u2CC6':'\u2CC7','\u2CC8':'\u2CC9','\u2CCA':'\u2CCB','\u2CCC':'\u2CCD','\u2CCE':'\u2CCF','\u2CD0':'\u2CD1','\u2CD2':'\u2CD3','\u2CD4':'\u2CD5','\u2CD6':'\u2CD7','\u2CD8':'\u2CD9','\u2CDA':'\u2CDB','\u2CDC':'\u2CDD','\u2CDE':'\u2CDF','\u2CE0':'\u2CE1','\u2CE2':'\u2CE3','\u2CEB':'\u2CEC','\u2CED':'\u2CEE','\u2CF2':'\u2CF3','\uA640':'\uA641','\uA642':'\uA643','\uA644':'\uA645','\uA646':'\uA647','\uA648':'\uA649','\uA64A':'\uA64B','\uA64C':'\uA64D','\uA64E':'\uA64F','\uA650':'\uA651','\uA652':'\uA653','\uA654':'\uA655','\uA656':'\uA657','\uA658':'\uA659','\uA65A':'\uA65B','\uA65C':'\uA65D','\uA65E':'\uA65F','\uA660':'\uA661','\uA662':'\uA663','\uA664':'\uA665','\uA666':'\uA667','\uA668':'\uA669','\uA66A':'\uA66B','\uA66C':'\uA66D','\uA680':'\uA681','\uA682':'\uA683','\uA684':'\uA685','\uA686':'\uA687','\uA688':'\uA689','\uA68A':'\uA68B','\uA68C':'\uA68D','\uA68E':'\uA68F','\uA690':'\uA691','\uA692':'\uA693','\uA694':'\uA695','\uA696':'\uA697','\uA698':'\uA699','\uA69A':'\uA69B','\uA722':'\uA723','\uA724':'\uA725','\uA726':'\uA727','\uA728':'\uA729','\uA72A':'\uA72B','\uA72C':'\uA72D','\uA72E':'\uA72F','\uA732':'\uA733','\uA734':'\uA735','\uA736':'\uA737','\uA738':'\uA739','\uA73A':'\uA73B','\uA73C':'\uA73D','\uA73E':'\uA73F','\uA740':'\uA741','\uA742':'\uA743','\uA744':'\uA745','\uA746':'\uA747','\uA748':'\uA749','\uA74A':'\uA74B','\uA74C':'\uA74D','\uA74E':'\uA74F','\uA750':'\uA751','\uA752':'\uA753','\uA754':'\uA755','\uA756':'\uA757','\uA758':'\uA759','\uA75A':'\uA75B','\uA75C':'\uA75D','\uA75E':'\uA75F','\uA760':'\uA761','\uA762':'\uA763','\uA764':'\uA765','\uA766':'\uA767','\uA768':'\uA769','\uA76A':'\uA76B','\uA76C':'\uA76D','\uA76E':'\uA76F','\uA779':'\uA77A','\uA77B':'\uA77C','\uA77D':'\u1D79','\uA77E':'\uA77F','\uA780':'\uA781','\uA782':'\uA783','\uA784':'\uA785','\uA786':'\uA787','\uA78B':'\uA78C','\uA78D':'\u0265','\uA790':'\uA791','\uA792':'\uA793','\uA796':'\uA797','\uA798':'\uA799','\uA79A':'\uA79B','\uA79C':'\uA79D','\uA79E':'\uA79F','\uA7A0':'\uA7A1','\uA7A2':'\uA7A3','\uA7A4':'\uA7A5','\uA7A6':'\uA7A7','\uA7A8':'\uA7A9','\uA7AA':'\u0266','\uA7AB':'\u025C','\uA7AC':'\u0261','\uA7AD':'\u026C','\uA7B0':'\u029E','\uA7B1':'\u0287','\uFF21':'\uFF41','\uFF22':'\uFF42','\uFF23':'\uFF43','\uFF24':'\uFF44','\uFF25':'\uFF45','\uFF26':'\uFF46','\uFF27':'\uFF47','\uFF28':'\uFF48','\uFF29':'\uFF49','\uFF2A':'\uFF4A','\uFF2B':'\uFF4B','\uFF2C':'\uFF4C','\uFF2D':'\uFF4D','\uFF2E':'\uFF4E','\uFF2F':'\uFF4F','\uFF30':'\uFF50','\uFF31':'\uFF51','\uFF32':'\uFF52','\uFF33':'\uFF53','\uFF34':'\uFF54','\uFF35':'\uFF55','\uFF36':'\uFF56','\uFF37':'\uFF57','\uFF38':'\uFF58','\uFF39':'\uFF59','\uFF3A':'\uFF5A','\uD801\uDC00':'\uD801\uDC28','\uD801\uDC01':'\uD801\uDC29','\uD801\uDC02':'\uD801\uDC2A','\uD801\uDC03':'\uD801\uDC2B','\uD801\uDC04':'\uD801\uDC2C','\uD801\uDC05':'\uD801\uDC2D','\uD801\uDC06':'\uD801\uDC2E','\uD801\uDC07':'\uD801\uDC2F','\uD801\uDC08':'\uD801\uDC30','\uD801\uDC09':'\uD801\uDC31','\uD801\uDC0A':'\uD801\uDC32','\uD801\uDC0B':'\uD801\uDC33','\uD801\uDC0C':'\uD801\uDC34','\uD801\uDC0D':'\uD801\uDC35','\uD801\uDC0E':'\uD801\uDC36','\uD801\uDC0F':'\uD801\uDC37','\uD801\uDC10':'\uD801\uDC38','\uD801\uDC11':'\uD801\uDC39','\uD801\uDC12':'\uD801\uDC3A','\uD801\uDC13':'\uD801\uDC3B','\uD801\uDC14':'\uD801\uDC3C','\uD801\uDC15':'\uD801\uDC3D','\uD801\uDC16':'\uD801\uDC3E','\uD801\uDC17':'\uD801\uDC3F','\uD801\uDC18':'\uD801\uDC40','\uD801\uDC19':'\uD801\uDC41','\uD801\uDC1A':'\uD801\uDC42','\uD801\uDC1B':'\uD801\uDC43','\uD801\uDC1C':'\uD801\uDC44','\uD801\uDC1D':'\uD801\uDC45','\uD801\uDC1E':'\uD801\uDC46','\uD801\uDC1F':'\uD801\uDC47','\uD801\uDC20':'\uD801\uDC48','\uD801\uDC21':'\uD801\uDC49','\uD801\uDC22':'\uD801\uDC4A','\uD801\uDC23':'\uD801\uDC4B','\uD801\uDC24':'\uD801\uDC4C','\uD801\uDC25':'\uD801\uDC4D','\uD801\uDC26':'\uD801\uDC4E','\uD801\uDC27':'\uD801\uDC4F','\uD806\uDCA0':'\uD806\uDCC0','\uD806\uDCA1':'\uD806\uDCC1','\uD806\uDCA2':'\uD806\uDCC2','\uD806\uDCA3':'\uD806\uDCC3','\uD806\uDCA4':'\uD806\uDCC4','\uD806\uDCA5':'\uD806\uDCC5','\uD806\uDCA6':'\uD806\uDCC6','\uD806\uDCA7':'\uD806\uDCC7','\uD806\uDCA8':'\uD806\uDCC8','\uD806\uDCA9':'\uD806\uDCC9','\uD806\uDCAA':'\uD806\uDCCA','\uD806\uDCAB':'\uD806\uDCCB','\uD806\uDCAC':'\uD806\uDCCC','\uD806\uDCAD':'\uD806\uDCCD','\uD806\uDCAE':'\uD806\uDCCE','\uD806\uDCAF':'\uD806\uDCCF','\uD806\uDCB0':'\uD806\uDCD0','\uD806\uDCB1':'\uD806\uDCD1','\uD806\uDCB2':'\uD806\uDCD2','\uD806\uDCB3':'\uD806\uDCD3','\uD806\uDCB4':'\uD806\uDCD4','\uD806\uDCB5':'\uD806\uDCD5','\uD806\uDCB6':'\uD806\uDCD6','\uD806\uDCB7':'\uD806\uDCD7','\uD806\uDCB8':'\uD806\uDCD8','\uD806\uDCB9':'\uD806\uDCD9','\uD806\uDCBA':'\uD806\uDCDA','\uD806\uDCBB':'\uD806\uDCDB','\uD806\uDCBC':'\uD806\uDCDC','\uD806\uDCBD':'\uD806\uDCDD','\uD806\uDCBE':'\uD806\uDCDE','\uD806\uDCBF':'\uD806\uDCDF','\xDF':'ss','\u0130':'i\u0307','\u0149':'\u02BCn','\u01F0':'j\u030C','\u0390':'\u03B9\u0308\u0301','\u03B0':'\u03C5\u0308\u0301','\u0587':'\u0565\u0582','\u1E96':'h\u0331','\u1E97':'t\u0308','\u1E98':'w\u030A','\u1E99':'y\u030A','\u1E9A':'a\u02BE','\u1E9E':'ss','\u1F50':'\u03C5\u0313','\u1F52':'\u03C5\u0313\u0300','\u1F54':'\u03C5\u0313\u0301','\u1F56':'\u03C5\u0313\u0342','\u1F80':'\u1F00\u03B9','\u1F81':'\u1F01\u03B9','\u1F82':'\u1F02\u03B9','\u1F83':'\u1F03\u03B9','\u1F84':'\u1F04\u03B9','\u1F85':'\u1F05\u03B9','\u1F86':'\u1F06\u03B9','\u1F87':'\u1F07\u03B9','\u1F88':'\u1F00\u03B9','\u1F89':'\u1F01\u03B9','\u1F8A':'\u1F02\u03B9','\u1F8B':'\u1F03\u03B9','\u1F8C':'\u1F04\u03B9','\u1F8D':'\u1F05\u03B9','\u1F8E':'\u1F06\u03B9','\u1F8F':'\u1F07\u03B9','\u1F90':'\u1F20\u03B9','\u1F91':'\u1F21\u03B9','\u1F92':'\u1F22\u03B9','\u1F93':'\u1F23\u03B9','\u1F94':'\u1F24\u03B9','\u1F95':'\u1F25\u03B9','\u1F96':'\u1F26\u03B9','\u1F97':'\u1F27\u03B9','\u1F98':'\u1F20\u03B9','\u1F99':'\u1F21\u03B9','\u1F9A':'\u1F22\u03B9','\u1F9B':'\u1F23\u03B9','\u1F9C':'\u1F24\u03B9','\u1F9D':'\u1F25\u03B9','\u1F9E':'\u1F26\u03B9','\u1F9F':'\u1F27\u03B9','\u1FA0':'\u1F60\u03B9','\u1FA1':'\u1F61\u03B9','\u1FA2':'\u1F62\u03B9','\u1FA3':'\u1F63\u03B9','\u1FA4':'\u1F64\u03B9','\u1FA5':'\u1F65\u03B9','\u1FA6':'\u1F66\u03B9','\u1FA7':'\u1F67\u03B9','\u1FA8':'\u1F60\u03B9','\u1FA9':'\u1F61\u03B9','\u1FAA':'\u1F62\u03B9','\u1FAB':'\u1F63\u03B9','\u1FAC':'\u1F64\u03B9','\u1FAD':'\u1F65\u03B9','\u1FAE':'\u1F66\u03B9','\u1FAF':'\u1F67\u03B9','\u1FB2':'\u1F70\u03B9','\u1FB3':'\u03B1\u03B9','\u1FB4':'\u03AC\u03B9','\u1FB6':'\u03B1\u0342','\u1FB7':'\u03B1\u0342\u03B9','\u1FBC':'\u03B1\u03B9','\u1FC2':'\u1F74\u03B9','\u1FC3':'\u03B7\u03B9','\u1FC4':'\u03AE\u03B9','\u1FC6':'\u03B7\u0342','\u1FC7':'\u03B7\u0342\u03B9','\u1FCC':'\u03B7\u03B9','\u1FD2':'\u03B9\u0308\u0300','\u1FD3':'\u03B9\u0308\u0301','\u1FD6':'\u03B9\u0342','\u1FD7':'\u03B9\u0308\u0342','\u1FE2':'\u03C5\u0308\u0300','\u1FE3':'\u03C5\u0308\u0301','\u1FE4':'\u03C1\u0313','\u1FE6':'\u03C5\u0342','\u1FE7':'\u03C5\u0308\u0342','\u1FF2':'\u1F7C\u03B9','\u1FF3':'\u03C9\u03B9','\u1FF4':'\u03CE\u03B9','\u1FF6':'\u03C9\u0342','\u1FF7':'\u03C9\u0342\u03B9','\u1FFC':'\u03C9\u03B9','\uFB00':'ff','\uFB01':'fi','\uFB02':'fl','\uFB03':'ffi','\uFB04':'ffl','\uFB05':'st','\uFB06':'st','\uFB13':'\u0574\u0576','\uFB14':'\u0574\u0565','\uFB15':'\u0574\u056B','\uFB16':'\u057E\u0576','\uFB17':'\u0574\u056D'};
	
	// Normalize reference label: collapse internal whitespace
	// to single space, remove leading/trailing whitespace, case fold.
	module.exports = function(string) {
	    return string.slice(1, string.length - 1).trim().replace(regex, function($0) {
	        // Note: there is no need to check `hasOwnProperty($0)` here.
	        // If character not found in lookup table, it must be whitespace.
	        return map[$0] || ' ';
	    });
	};


/***/ }),
/* 99 */
/***/ (function(module, exports) {

	"use strict";
	
	// derived from https://github.com/mathiasbynens/String.fromCodePoint
	/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
	if (String.fromCodePoint) {
	    module.exports = function (_) {
	        try {
	            return String.fromCodePoint(_);
	        } catch (e) {
	            if (e instanceof RangeError) {
	                return String.fromCharCode(0xFFFD);
	            }
	            throw e;
	        }
	    };
	
	} else {
	
	  var stringFromCharCode = String.fromCharCode;
	  var floor = Math.floor;
	  var fromCodePoint = function() {
	      var MAX_SIZE = 0x4000;
	      var codeUnits = [];
	      var highSurrogate;
	      var lowSurrogate;
	      var index = -1;
	      var length = arguments.length;
	      if (!length) {
	          return '';
	      }
	      var result = '';
	      while (++index < length) {
	          var codePoint = Number(arguments[index]);
	          if (
	              !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
	                  codePoint < 0 || // not a valid Unicode code point
	                  codePoint > 0x10FFFF || // not a valid Unicode code point
	                  floor(codePoint) !== codePoint // not an integer
	          ) {
	              return String.fromCharCode(0xFFFD);
	          }
	          if (codePoint <= 0xFFFF) { // BMP code point
	              codeUnits.push(codePoint);
	          } else { // Astral code point; split in surrogate halves
	              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	              codePoint -= 0x10000;
	              highSurrogate = (codePoint >> 10) + 0xD800;
	              lowSurrogate = (codePoint % 0x400) + 0xDC00;
	              codeUnits.push(highSurrogate, lowSurrogate);
	          }
	          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
	              result += stringFromCharCode.apply(null, codeUnits);
	              codeUnits.length = 0;
	          }
	      }
	      return result;
	  };
	  module.exports = fromCodePoint;
	}


/***/ }),
/* 100 */
/***/ (function(module, exports) {

	/*! http://mths.be/repeat v0.2.0 by @mathias */
	if (!String.prototype.repeat) {
		(function() {
			'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
			var defineProperty = (function() {
				// IE 8 only supports `Object.defineProperty` on DOM elements
				try {
					var object = {};
					var $defineProperty = Object.defineProperty;
					var result = $defineProperty(object, object, object) && $defineProperty;
				} catch(error) {}
				return result;
			}());
			var repeat = function(count) {
				if (this == null) {
					throw TypeError();
				}
				var string = String(this);
				// `ToInteger`
				var n = count ? Number(count) : 0;
				if (n != n) { // better `isNaN`
					n = 0;
				}
				// Account for out-of-bounds indices
				if (n < 0 || n == Infinity) {
					throw RangeError();
				}
				var result = '';
				while (n) {
					if (n % 2 == 1) {
						result += string;
					}
					if (n > 1) {
						string += string;
					}
					n >>= 1;
				}
				return result;
			};
			if (defineProperty) {
				defineProperty(String.prototype, 'repeat', {
					'value': repeat,
					'configurable': true,
					'writable': true
				});
			} else {
				String.prototype.repeat = repeat;
			}
		}());
	}


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var Renderer = __webpack_require__(102);
	
	var esc = __webpack_require__(86).escapeXml;
	
	var reUnsafeProtocol = /^javascript:|vbscript:|file:|data:/i;
	var reSafeDataProtocol = /^data:image\/(?:png|gif|jpeg|webp)/i;
	
	var potentiallyUnsafe = function(url) {
	    return reUnsafeProtocol.test(url) &&
	        !reSafeDataProtocol.test(url);
	};
	
	// Helper function to produce an HTML tag.
	function tag(name, attrs, selfclosing) {
	    if (this.disableTags > 0) {
	        return;
	    }
	    this.buffer += ('<' + name);
	    if (attrs && attrs.length > 0) {
	        var i = 0;
	        var attrib;
	        while ((attrib = attrs[i]) !== undefined) {
	            this.buffer += (' ' + attrib[0] + '="' + attrib[1] + '"');
	            i++;
	        }
	    }
	    if (selfclosing) {
	        this.buffer += ' /';
	    }
	    this.buffer += '>';
	    this.lastOut = '>';
	}
	
	
	function HtmlRenderer(options) {
	  options = options || {};
	  // by default, soft breaks are rendered as newlines in HTML
	  options.softbreak = options.softbreak || '\n';
	  // set to "<br />" to make them hard breaks
	  // set to " " if you want to ignore line wrapping in source
	
	  this.disableTags = 0;
	  this.lastOut = "\n";
	  this.options = options;
	}
	
	/* Node methods */
	
	function text(node) {
	  this.out(node.literal);
	}
	
	function softbreak() {
	  this.lit(this.options.softbreak);
	}
	
	function linebreak() {
	  this.tag('br', [], true);
	  this.cr();
	}
	
	function link(node, entering) {
	  var attrs = this.attrs(node);
	  if (entering) {
	      if (!(this.options.safe && potentiallyUnsafe(node.destination))) {
	          attrs.push(['href', esc(node.destination, true)]);
	      }
	      if (node.title) {
	          attrs.push(['title', esc(node.title, true)]);
	      }
	      this.tag('a', attrs);
	  } else {
	      this.tag('/a');
	  }
	}
	
	function image(node, entering) {
	  if (entering) {
	      if (this.disableTags === 0) {
	          if (this.options.safe &&
	               potentiallyUnsafe(node.destination)) {
	              this.lit('<img src="" alt="');
	          } else {
	              this.lit('<img src="' + esc(node.destination, true) +
	                  '" alt="');
	          }
	      }
	      this.disableTags += 1;
	  } else {
	      this.disableTags -= 1;
	      if (this.disableTags === 0) {
	          if (node.title) {
	              this.lit('" title="' + esc(node.title, true));
	          }
	          this.lit('" />');
	      }
	  }
	}
	
	function emph(node, entering) {
	  this.tag(entering ? 'em' : '/em');
	}
	
	function strong(node, entering) {
	  this.tag(entering ? 'strong' : '/strong');
	}
	
	function paragraph(node, entering) {
	  var grandparent = node.parent.parent
	    , attrs = this.attrs(node);
	  if (grandparent !== null &&
	      grandparent.type === 'list') {
	      if (grandparent.listTight) {
	          return;
	      }
	  }
	  if (entering) {
	      this.cr();
	      this.tag('p', attrs);
	  } else {
	      this.tag('/p');
	      this.cr();
	  }
	}
	
	function heading(node, entering) {
	  var tagname = 'h' + node.level
	    , attrs = this.attrs(node);
	  if (entering) {
	      this.cr();
	      this.tag(tagname, attrs);
	  } else {
	      this.tag('/' + tagname);
	      this.cr();
	  }
	}
	
	function code(node) {
	  this.tag('code');
	  this.out(node.literal);
	  this.tag('/code');
	}
	
	function code_block(node) {
	  var info_words = node.info ? node.info.split(/\s+/) : []
	    , attrs = this.attrs(node);
	  if (info_words.length > 0 && info_words[0].length > 0) {
	      attrs.push(['class', 'language-' + esc(info_words[0], true)]);
	  }
	  this.cr();
	  this.tag('pre');
	  this.tag('code', attrs);
	  this.out(node.literal);
	  this.tag('/code');
	  this.tag('/pre');
	  this.cr();
	}
	
	function thematic_break(node) {
	  var attrs = this.attrs(node);
	  this.cr();
	  this.tag('hr', attrs, true);
	  this.cr();
	}
	
	function block_quote(node, entering) {
	  var attrs = this.attrs(node);
	  if (entering) {
	      this.cr();
	      this.tag('blockquote', attrs);
	      this.cr();
	  } else {
	      this.cr();
	      this.tag('/blockquote');
	      this.cr();
	  }
	}
	
	function list(node, entering) {
	  var tagname = node.listType === 'bullet' ? 'ul' : 'ol'
	    , attrs = this.attrs(node);
	
	  if (entering) {
	      var start = node.listStart;
	      if (start !== null && start !== 1) {
	          attrs.push(['start', start.toString()]);
	      }
	      this.cr();
	      this.tag(tagname, attrs);
	      this.cr();
	  } else {
	      this.cr();
	      this.tag('/' + tagname);
	      this.cr();
	  }
	}
	
	function item(node, entering) {
	  var attrs = this.attrs(node);
	  if (entering) {
	      this.tag('li', attrs);
	  } else {
	      this.tag('/li');
	      this.cr();
	  }
	}
	
	function html_inline(node) {
	  if (this.options.safe) {
	      this.lit('<!-- raw HTML omitted -->');
	  } else {
	      this.lit(node.literal);
	  }
	}
	
	function html_block(node) {
	  this.cr();
	  if (this.options.safe) {
	      this.lit('<!-- raw HTML omitted -->');
	  } else {
	      this.lit(node.literal);
	  }
	  this.cr();
	}
	
	function custom_inline(node, entering) {
	  if (entering && node.onEnter) {
	      this.lit(node.onEnter);
	  } else if (!entering && node.onExit) {
	      this.lit(node.onExit);
	  }
	}
	
	function custom_block(node, entering) {
	  this.cr();
	  if (entering && node.onEnter) {
	      this.lit(node.onEnter);
	  } else if (!entering && node.onExit) {
	      this.lit(node.onExit);
	  }
	  this.cr();
	}
	
	/* Helper methods */
	
	function out(s) {
	  this.lit(esc(s, false));
	}
	
	function attrs (node) {
	  var att = [];
	  if (this.options.sourcepos) {
	      var pos = node.sourcepos;
	      if (pos) {
	          att.push(['data-sourcepos', String(pos[0][0]) + ':' +
	                      String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +
	                      String(pos[1][1])]);
	      }
	  }
	  return att;
	}
	
	// quick browser-compatible inheritance
	HtmlRenderer.prototype = Object.create(Renderer.prototype);
	
	HtmlRenderer.prototype.text = text;
	HtmlRenderer.prototype.html_inline = html_inline;
	HtmlRenderer.prototype.html_block = html_block;
	HtmlRenderer.prototype.softbreak = softbreak;
	HtmlRenderer.prototype.linebreak = linebreak;
	HtmlRenderer.prototype.link = link;
	HtmlRenderer.prototype.image = image;
	HtmlRenderer.prototype.emph = emph;
	HtmlRenderer.prototype.strong = strong;
	HtmlRenderer.prototype.paragraph = paragraph;
	HtmlRenderer.prototype.heading = heading;
	HtmlRenderer.prototype.code = code;
	HtmlRenderer.prototype.code_block = code_block;
	HtmlRenderer.prototype.thematic_break = thematic_break;
	HtmlRenderer.prototype.block_quote = block_quote;
	HtmlRenderer.prototype.list = list;
	HtmlRenderer.prototype.item = item;
	HtmlRenderer.prototype.custom_inline = custom_inline;
	HtmlRenderer.prototype.custom_block = custom_block;
	
	HtmlRenderer.prototype.out = out;
	HtmlRenderer.prototype.tag = tag;
	HtmlRenderer.prototype.attrs = attrs;
	
	module.exports = HtmlRenderer;


/***/ }),
/* 102 */
/***/ (function(module, exports) {

	"use strict";
	
	function Renderer() {}
	
	/**
	 *  Walks the AST and calls member methods for each Node type.
	 *
	 *  @param ast {Node} The root of the abstract syntax tree.
	 */
	function render(ast) {
	  var walker = ast.walker()
	    , event
	    , type;
	
	  this.buffer = '';
	  this.lastOut = '\n';
	
	  while((event = walker.next())) {
	    type = event.node.type;
	    if (this[type]) {
	      this[type](event.node, event.entering);
	    }
	  }
	  return this.buffer;
	}
	
	/**
	 *  Concatenate a literal string to the buffer.
	 *
	 *  @param str {String} The string to concatenate.
	 */
	function lit(str) {
	  this.buffer += str;
	  this.lastOut = str;
	}
	
	function cr() {
	    if (this.lastOut !== '\n') {
	        this.lit('\n');
	    }
	}
	
	/**
	 *  Concatenate a string to the buffer possibly escaping the content.
	 *
	 *  Concrete renderer implementations should override this method.
	 *
	 *  @param str {String} The string to concatenate.
	 */
	function out(str) {
	  this.lit(str);
	}
	
	Renderer.prototype.render = render;
	Renderer.prototype.out = out;
	Renderer.prototype.lit = lit;
	Renderer.prototype.cr  = cr;
	
	module.exports = Renderer;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	
	var escapeXml = __webpack_require__(86).escapeXml;
	
	// Helper function to produce an XML tag.
	var tag = function(name, attrs, selfclosing) {
	    var result = '<' + name;
	    if (attrs && attrs.length > 0) {
	        var i = 0;
	        var attrib;
	        while ((attrib = attrs[i]) !== undefined) {
	            result += ' ' + attrib[0] + '="' + escapeXml(attrib[1]) + '"';
	            i++;
	        }
	    }
	    if (selfclosing) {
	        result += ' /';
	    }
	
	    result += '>';
	    return result;
	};
	
	var reXMLTag = /\<[^>]*\>/;
	
	var toTagName = function(s) {
	    return s.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
	};
	
	var renderNodes = function(block) {
	
	    var attrs;
	    var tagname;
	    var walker = block.walker();
	    var event, node, entering;
	    var buffer = "";
	    var lastOut = "\n";
	    var disableTags = 0;
	    var indentLevel = 0;
	    var indent = '  ';
	    var container;
	    var selfClosing;
	    var nodetype;
	
	    var out = function(s) {
	        if (disableTags > 0) {
	            buffer += s.replace(reXMLTag, '');
	        } else {
	            buffer += s;
	        }
	        lastOut = s;
	    };
	    var esc = this.escape;
	    var cr = function() {
	        if (lastOut !== '\n') {
	            buffer += '\n';
	            lastOut = '\n';
	            for (var i = indentLevel; i > 0; i--) {
	                buffer += indent;
	            }
	        }
	    };
	
	    var options = this.options;
	
	    if (options.time) { console.time("rendering"); }
	
	    buffer += '<?xml version="1.0" encoding="UTF-8"?>\n';
	    buffer += '<!DOCTYPE CommonMark SYSTEM "CommonMark.dtd">\n';
	
	    while ((event = walker.next())) {
	        entering = event.entering;
	        node = event.node;
	        nodetype = node.type;
	
	        container = node.isContainer;
	        selfClosing = nodetype === 'thematic_break' || nodetype === 'linebreak' ||
	            nodetype === 'softbreak';
	        tagname = toTagName(nodetype);
	
	        if (entering) {
	
	            attrs = [];
	
	            switch (nodetype) {
	            case 'document':
	                attrs.push(['xmlns', 'http://commonmark.org/xml/1.0']);
	                break;
	            case 'list':
	                if (node.listType !== null) {
	                    attrs.push(['type', node.listType.toLowerCase()]);
	                }
	                if (node.listStart !== null) {
	                    attrs.push(['start', String(node.listStart)]);
	                }
	                if (node.listTight !== null) {
	                    attrs.push(['tight', (node.listTight ? 'true' : 'false')]);
	                }
	                var delim = node.listDelimiter;
	                if (delim !== null) {
	                    var delimword = '';
	                    if (delim === '.') {
	                        delimword = 'period';
	                    } else {
	                        delimword = 'paren';
	                    }
	                    attrs.push(['delimiter', delimword]);
	                }
	                break;
	            case 'code_block':
	                if (node.info) {
	                    attrs.push(['info', node.info]);
	                }
	                break;
	            case 'heading':
	                attrs.push(['level', String(node.level)]);
	                break;
	            case 'link':
	            case 'image':
	                attrs.push(['destination', node.destination]);
	                attrs.push(['title', node.title]);
	                break;
	            case 'custom_inline':
	            case 'custom_block':
	                attrs.push(['on_enter', node.onEnter]);
	                attrs.push(['on_exit', node.onExit]);
	                break;
	            default:
	                break;
	            }
	            if (options.sourcepos) {
	                var pos = node.sourcepos;
	                if (pos) {
	                    attrs.push(['sourcepos', String(pos[0][0]) + ':' +
	                                String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +
	                                String(pos[1][1])]);
	                }
	            }
	
	            cr();
	            out(tag(tagname, attrs, selfClosing));
	            if (container) {
	                indentLevel += 1;
	            } else if (!container && !selfClosing) {
	                var lit = node.literal;
	                if (lit) {
	                    out(esc(lit));
	                }
	                out(tag('/' + tagname));
	            }
	        } else {
	            indentLevel -= 1;
	            cr();
	            out(tag('/' + tagname));
	        }
	
	
	    }
	    if (options.time) { console.timeEnd("rendering"); }
	    buffer += '\n';
	    return buffer;
	};
	
	// The XmlRenderer object.
	function XmlRenderer(options){
	    return {
	        // default options:
	        softbreak: '\n', // by default, soft breaks are rendered as newlines in HTML
	        // set to "<br />" to make them hard breaks
	        // set to " " if you want to ignore line wrapping in source
	        escape: escapeXml,
	        options: options || {},
	        render: renderNodes
	    };
	}
	
	module.exports = XmlRenderer;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-console:0 */
	/**
	 * This is the main entry point for KaTeX. Here, we expose functions for
	 * rendering expressions either to DOM nodes or to markup strings.
	 *
	 * We also expose the ParseError class to check if errors thrown from KaTeX are
	 * errors in the expression, or errors in javascript handling.
	 */
	
	var ParseError = __webpack_require__(105);
	var Settings = __webpack_require__(106);
	
	var buildTree = __webpack_require__(107);
	var parseTree = __webpack_require__(121);
	var utils = __webpack_require__(115);
	
	/**
	 * Parse and build an expression, and place that expression in the DOM node
	 * given.
	 */
	var render = function(expression, baseNode, options) {
	    utils.clearNode(baseNode);
	
	    var settings = new Settings(options);
	
	    var tree = parseTree(expression, settings);
	    var node = buildTree(tree, expression, settings).toNode();
	
	    baseNode.appendChild(node);
	};
	
	// KaTeX's styles don't work properly in quirks mode. Print out an error, and
	// disable rendering.
	if (typeof document !== "undefined") {
	    if (document.compatMode !== "CSS1Compat") {
	        typeof console !== "undefined" && console.warn(
	            "Warning: KaTeX doesn't work in quirks mode. Make sure your " +
	                "website has a suitable doctype.");
	
	        render = function() {
	            throw new ParseError("KaTeX doesn't work in quirks mode.");
	        };
	    }
	}
	
	/**
	 * Parse and build an expression, and return the markup for that.
	 */
	var renderToString = function(expression, options) {
	    var settings = new Settings(options);
	
	    var tree = parseTree(expression, settings);
	    return buildTree(tree, expression, settings).toMarkup();
	};
	
	/**
	 * Parse an expression and return the parse tree.
	 */
	var generateParseTree = function(expression, options) {
	    var settings = new Settings(options);
	    return parseTree(expression, settings);
	};
	
	module.exports = {
	    render: render,
	    renderToString: renderToString,
	    /**
	     * NOTE: This method is not currently recommended for public use.
	     * The internal tree representation is unstable and is very likely
	     * to change. Use at your own risk.
	     */
	    __parse: generateParseTree,
	    ParseError: ParseError
	};


/***/ }),
/* 105 */
/***/ (function(module, exports) {

	/**
	 * This is the ParseError class, which is the main error thrown by KaTeX
	 * functions when something has gone wrong. This is used to distinguish internal
	 * errors from errors in the expression that the user provided.
	 *
	 * If possible, a caller should provide a Token or ParseNode with information
	 * about where in the source string the problem occurred.
	 *
	 * @param {string} message  The error message
	 * @param {(Token|ParseNode)=} token  An object providing position information
	 */
	function ParseError(message, token) {
	    var error = "KaTeX parse error: " + message;
	    var start;
	    var end;
	
	    if (token && token.lexer && token.start <= token.end) {
	        // If we have the input and a position, make the error a bit fancier
	
	        // Get the input
	        var input = token.lexer.input;
	
	        // Prepend some information
	        start = token.start;
	        end = token.end;
	        if (start === input.length) {
	            error += " at end of input: ";
	        } else {
	            error += " at position " + (start + 1) + ": ";
	        }
	
	        // Underline token in question using combining underscores
	        var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");
	
	        // Extract some context from the input and add it to the error
	        var left;
	        if (start > 15) {
	            left = "" + input.slice(start - 15, start);
	        } else {
	            left = input.slice(0, start);
	        }
	        var right;
	        if (end + 15 < input.length) {
	            right = input.slice(end, end + 15) + "";
	        } else {
	            right = input.slice(end);
	        }
	        error += left + underlined + right;
	    }
	
	    // Some hackery to make ParseError a prototype of Error
	    // See http://stackoverflow.com/a/8460753
	    var self = new Error(error);
	    self.name = "ParseError";
	    self.__proto__ = ParseError.prototype;
	
	    self.position = start;
	    return self;
	}
	
	// More hackery
	ParseError.prototype.__proto__ = Error.prototype;
	
	module.exports = ParseError;


/***/ }),
/* 106 */
/***/ (function(module, exports) {

	/**
	 * This is a module for storing settings passed into KaTeX. It correctly handles
	 * default settings.
	 */
	
	/**
	 * Helper function for getting a default value if the value is undefined
	 */
	function get(option, defaultValue) {
	    return option === undefined ? defaultValue : option;
	}
	
	/**
	 * The main Settings object
	 *
	 * The current options stored are:
	 *  - displayMode: Whether the expression should be typeset by default in
	 *                 textstyle or displaystyle (default false)
	 */
	function Settings(options) {
	    // allow null options
	    options = options || {};
	    this.displayMode = get(options.displayMode, false);
	    this.throwOnError = get(options.throwOnError, true);
	    this.errorColor = get(options.errorColor, "#cc0000");
	    this.macros = options.macros || {};
	}
	
	module.exports = Settings;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	var buildHTML = __webpack_require__(108);
	var buildMathML = __webpack_require__(118);
	var buildCommon = __webpack_require__(113);
	var Options = __webpack_require__(120);
	var Settings = __webpack_require__(106);
	var Style = __webpack_require__(109);
	
	var makeSpan = buildCommon.makeSpan;
	
	var buildTree = function(tree, expression, settings) {
	    settings = settings || new Settings({});
	
	    var startStyle = Style.TEXT;
	    if (settings.displayMode) {
	        startStyle = Style.DISPLAY;
	    }
	
	    // Setup the default options
	    var options = new Options({
	        style: startStyle,
	        size: "size5"
	    });
	
	    // `buildHTML` sometimes messes with the parse tree (like turning bins ->
	    // ords), so we build the MathML version first.
	    var mathMLNode = buildMathML(tree, expression, options);
	    var htmlNode = buildHTML(tree, options);
	
	    var katexNode = makeSpan(["katex"], [
	        mathMLNode, htmlNode
	    ]);
	
	    if (settings.displayMode) {
	        return makeSpan(["katex-display"], [katexNode]);
	    } else {
	        return katexNode;
	    }
	};
	
	module.exports = buildTree;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-console:0 */
	/**
	 * This file does the main work of building a domTree structure from a parse
	 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
	 * Then, the buildExpression, buildGroup, and various groupTypes functions are
	 * called, to produce a final HTML tree.
	 */
	
	var ParseError = __webpack_require__(105);
	var Style = __webpack_require__(109);
	
	var buildCommon = __webpack_require__(113);
	var delimiter = __webpack_require__(117);
	var domTree = __webpack_require__(114);
	var fontMetrics = __webpack_require__(110);
	var utils = __webpack_require__(115);
	
	var makeSpan = buildCommon.makeSpan;
	
	var isSpace = function(node) {
	    return node instanceof domTree.span && node.classes[0] === "mspace";
	};
	
	// Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
	// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
	// and the text before Rule 19.
	
	var isBin = function(node) {
	    return node && node.classes[0] === "mbin";
	};
	
	var isBinLeftCanceller = function(node, isRealGroup) {
	    // TODO: This code assumes that a node's math class is the first element
	    // of its `classes` array. A later cleanup should ensure this, for
	    // instance by changing the signature of `makeSpan`.
	    if (node) {
	        return utils.contains(["mbin", "mopen", "mrel", "mop", "mpunct"],
	                              node.classes[0]);
	    } else {
	        return isRealGroup;
	    }
	};
	
	var isBinRightCanceller = function(node, isRealGroup) {
	    if (node) {
	        return utils.contains(["mrel", "mclose", "mpunct"], node.classes[0]);
	    } else {
	        return isRealGroup;
	    }
	};
	
	/**
	 * Take a list of nodes, build them in order, and return a list of the built
	 * nodes. documentFragments are flattened into their contents, so the
	 * returned list contains no fragments. `isRealGroup` is true if `expression`
	 * is a real group (no atoms will be added on either side), as opposed to
	 * a partial group (e.g. one created by \color).
	 */
	var buildExpression = function(expression, options, isRealGroup) {
	    // Parse expressions into `groups`.
	    var groups = [];
	    for (var i = 0; i < expression.length; i++) {
	        var group = expression[i];
	        var output = buildGroup(group, options);
	        if (output instanceof domTree.documentFragment) {
	            Array.prototype.push.apply(groups, output.children);
	        } else {
	            groups.push(output);
	        }
	    }
	    // At this point `groups` consists entirely of `symbolNode`s and `span`s.
	
	    // Explicit spaces (e.g., \;, \,) should be ignored with respect to atom
	    // spacing (e.g., "add thick space between mord and mrel"). Since CSS
	    // adjacency rules implement atom spacing, spaces should be invisible to
	    // CSS. So we splice them out of `groups` and into the atoms themselves.
	    var spaces = null;
	    for (i = 0; i < groups.length; i++) {
	        if (isSpace(groups[i])) {
	            spaces = spaces || [];
	            spaces.push(groups[i]);
	            groups.splice(i, 1);
	            i--;
	        } else if (spaces) {
	            if (groups[i] instanceof domTree.symbolNode) {
	                groups[i] = makeSpan([].concat(groups[i].classes), [groups[i]]);
	            }
	            buildCommon.prependChildren(groups[i], spaces);
	            spaces = null;
	        }
	    }
	    if (spaces) {
	        Array.prototype.push.apply(groups, spaces);
	    }
	
	    // Binary operators change to ordinary symbols in some contexts.
	    for (i = 0; i < groups.length; i++) {
	        if (isBin(groups[i])
	            && (isBinLeftCanceller(groups[i - 1], isRealGroup)
	                || isBinRightCanceller(groups[i + 1], isRealGroup))) {
	            groups[i].classes[0] = "mord";
	        }
	    }
	
	    return groups;
	};
	
	// Return math atom class (mclass) of a domTree.
	var getTypeOfDomTree = function(node) {
	    if (node instanceof domTree.documentFragment) {
	        if (node.children.length) {
	            return getTypeOfDomTree(
	                node.children[node.children.length - 1]);
	        }
	    } else {
	        if (utils.contains(["mord", "mop", "mbin", "mrel", "mopen", "mclose",
	            "mpunct", "minner"], node.classes[0])) {
	            return node.classes[0];
	        }
	    }
	    return null;
	};
	
	/**
	 * Sometimes, groups perform special rules when they have superscripts or
	 * subscripts attached to them. This function lets the `supsub` group know that
	 * its inner element should handle the superscripts and subscripts instead of
	 * handling them itself.
	 */
	var shouldHandleSupSub = function(group, options) {
	    if (!group) {
	        return false;
	    } else if (group.type === "op") {
	        // Operators handle supsubs differently when they have limits
	        // (e.g. `\displaystyle\sum_2^3`)
	        return group.value.limits &&
	            (options.style.size === Style.DISPLAY.size ||
	            group.value.alwaysHandleSupSub);
	    } else if (group.type === "accent") {
	        return isCharacterBox(group.value.base);
	    } else {
	        return null;
	    }
	};
	
	/**
	 * Sometimes we want to pull out the innermost element of a group. In most
	 * cases, this will just be the group itself, but when ordgroups and colors have
	 * a single element, we want to pull that out.
	 */
	var getBaseElem = function(group) {
	    if (!group) {
	        return false;
	    } else if (group.type === "ordgroup") {
	        if (group.value.length === 1) {
	            return getBaseElem(group.value[0]);
	        } else {
	            return group;
	        }
	    } else if (group.type === "color") {
	        if (group.value.value.length === 1) {
	            return getBaseElem(group.value.value[0]);
	        } else {
	            return group;
	        }
	    } else if (group.type === "font") {
	        return getBaseElem(group.value.body);
	    } else {
	        return group;
	    }
	};
	
	/**
	 * TeXbook algorithms often reference "character boxes", which are simply groups
	 * with a single character in them. To decide if something is a character box,
	 * we find its innermost group, and see if it is a single character.
	 */
	var isCharacterBox = function(group) {
	    var baseElem = getBaseElem(group);
	
	    // These are all they types of groups which hold single characters
	    return baseElem.type === "mathord" ||
	        baseElem.type === "textord" ||
	        baseElem.type === "bin" ||
	        baseElem.type === "rel" ||
	        baseElem.type === "inner" ||
	        baseElem.type === "open" ||
	        baseElem.type === "close" ||
	        baseElem.type === "punct";
	};
	
	var makeNullDelimiter = function(options, classes) {
	    return makeSpan(classes.concat([
	        "sizing", "reset-" + options.size, "size5",
	        options.style.reset(), Style.TEXT.cls(),
	        "nulldelimiter"]));
	};
	
	/**
	 * This is a map of group types to the function used to handle that type.
	 * Simpler types come at the beginning, while complicated types come afterwards.
	 */
	var groupTypes = {};
	
	groupTypes.mathord = function(group, options) {
	    return buildCommon.makeOrd(group, options, "mathord");
	};
	
	groupTypes.textord = function(group, options) {
	    return buildCommon.makeOrd(group, options, "textord");
	};
	
	groupTypes.bin = function(group, options) {
	    return buildCommon.mathsym(
	        group.value, group.mode, options, ["mbin"]);
	};
	
	groupTypes.rel = function(group, options) {
	    return buildCommon.mathsym(
	        group.value, group.mode, options, ["mrel"]);
	};
	
	groupTypes.open = function(group, options) {
	    return buildCommon.mathsym(
	        group.value, group.mode, options, ["mopen"]);
	};
	
	groupTypes.close = function(group, options) {
	    return buildCommon.mathsym(
	        group.value, group.mode, options, ["mclose"]);
	};
	
	groupTypes.inner = function(group, options) {
	    return buildCommon.mathsym(
	        group.value, group.mode, options, ["minner"]);
	};
	
	groupTypes.punct = function(group, options) {
	    return buildCommon.mathsym(
	        group.value, group.mode, options, ["mpunct"]);
	};
	
	groupTypes.ordgroup = function(group, options) {
	    return makeSpan(
	        ["mord", options.style.cls()],
	        buildExpression(group.value, options.reset(), true),
	        options
	    );
	};
	
	groupTypes.text = function(group, options) {
	    var newOptions = options.withFont(group.value.style);
	    var inner = buildExpression(group.value.body, newOptions, true);
	    for (var i = 0; i < inner.length - 1; i++) {
	        if (inner[i].tryCombine(inner[i + 1])) {
	            inner.splice(i + 1, 1);
	            i--;
	        }
	    }
	    return makeSpan(["mord", "text", newOptions.style.cls()],
	        inner, newOptions);
	};
	
	groupTypes.color = function(group, options) {
	    var elements = buildExpression(
	        group.value.value,
	        options.withColor(group.value.color),
	        false
	    );
	
	    // \color isn't supposed to affect the type of the elements it contains.
	    // To accomplish this, we wrap the results in a fragment, so the inner
	    // elements will be able to directly interact with their neighbors. For
	    // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
	    return new buildCommon.makeFragment(elements);
	};
	
	groupTypes.supsub = function(group, options) {
	    // Superscript and subscripts are handled in the TeXbook on page
	    // 445-446, rules 18(a-f).
	
	    // Here is where we defer to the inner group if it should handle
	    // superscripts and subscripts itself.
	    if (shouldHandleSupSub(group.value.base, options)) {
	        return groupTypes[group.value.base.type](group, options);
	    }
	
	    var base = buildGroup(group.value.base, options.reset());
	    var supmid;
	    var submid;
	    var sup;
	    var sub;
	
	    var style = options.style;
	    var newOptions;
	
	    if (group.value.sup) {
	        newOptions = options.withStyle(style.sup());
	        sup = buildGroup(group.value.sup, newOptions);
	        supmid = makeSpan([style.reset(), style.sup().cls()],
	            [sup], newOptions);
	    }
	
	    if (group.value.sub) {
	        newOptions = options.withStyle(style.sub());
	        sub = buildGroup(group.value.sub, newOptions);
	        submid = makeSpan([style.reset(), style.sub().cls()],
	            [sub], newOptions);
	    }
	
	    // Rule 18a
	    var supShift;
	    var subShift;
	    if (isCharacterBox(group.value.base)) {
	        supShift = 0;
	        subShift = 0;
	    } else {
	        supShift = base.height - style.metrics.supDrop;
	        subShift = base.depth + style.metrics.subDrop;
	    }
	
	    // Rule 18c
	    var minSupShift;
	    if (style === Style.DISPLAY) {
	        minSupShift = style.metrics.sup1;
	    } else if (style.cramped) {
	        minSupShift = style.metrics.sup3;
	    } else {
	        minSupShift = style.metrics.sup2;
	    }
	
	    // scriptspace is a font-size-independent size, so scale it
	    // appropriately
	    var multiplier = Style.TEXT.sizeMultiplier *
	            style.sizeMultiplier;
	    var scriptspace =
	        (0.5 / fontMetrics.metrics.ptPerEm) / multiplier + "em";
	
	    var supsub;
	    if (!group.value.sup) {
	        // Rule 18b
	        subShift = Math.max(
	            subShift, style.metrics.sub1,
	            sub.height - 0.8 * style.metrics.xHeight);
	
	        supsub = buildCommon.makeVList([
	            {type: "elem", elem: submid}
	        ], "shift", subShift, options);
	
	        supsub.children[0].style.marginRight = scriptspace;
	
	        // Subscripts shouldn't be shifted by the base's italic correction.
	        // Account for that by shifting the subscript back the appropriate
	        // amount. Note we only do this when the base is a single symbol.
	        if (base instanceof domTree.symbolNode) {
	            supsub.children[0].style.marginLeft = -base.italic + "em";
	        }
	    } else if (!group.value.sub) {
	        // Rule 18c, d
	        supShift = Math.max(supShift, minSupShift,
	            sup.depth + 0.25 * style.metrics.xHeight);
	
	        supsub = buildCommon.makeVList([
	            {type: "elem", elem: supmid}
	        ], "shift", -supShift, options);
	
	        supsub.children[0].style.marginRight = scriptspace;
	    } else {
	        supShift = Math.max(
	            supShift, minSupShift, sup.depth + 0.25 * style.metrics.xHeight);
	        subShift = Math.max(subShift, style.metrics.sub2);
	
	        var ruleWidth = fontMetrics.metrics.defaultRuleThickness;
	
	        // Rule 18e
	        if ((supShift - sup.depth) - (sub.height - subShift) <
	                4 * ruleWidth) {
	            subShift = 4 * ruleWidth - (supShift - sup.depth) + sub.height;
	            var psi = 0.8 * style.metrics.xHeight - (supShift - sup.depth);
	            if (psi > 0) {
	                supShift += psi;
	                subShift -= psi;
	            }
	        }
	
	        supsub = buildCommon.makeVList([
	            {type: "elem", elem: submid, shift: subShift},
	            {type: "elem", elem: supmid, shift: -supShift}
	        ], "individualShift", null, options);
	
	        // See comment above about subscripts not being shifted
	        if (base instanceof domTree.symbolNode) {
	            supsub.children[0].style.marginLeft = -base.italic + "em";
	        }
	
	        supsub.children[0].style.marginRight = scriptspace;
	        supsub.children[1].style.marginRight = scriptspace;
	    }
	
	    // We ensure to wrap the supsub vlist in a span.msupsub to reset text-align
	    var mclass = getTypeOfDomTree(base) || "mord";
	    return makeSpan([mclass],
	        [base, makeSpan(["msupsub"], [supsub])],
	        options);
	};
	
	groupTypes.genfrac = function(group, options) {
	    // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
	    // Figure out what style this fraction should be in based on the
	    // function used
	    var style = options.style;
	    if (group.value.size === "display") {
	        style = Style.DISPLAY;
	    } else if (group.value.size === "text") {
	        style = Style.TEXT;
	    }
	
	    var nstyle = style.fracNum();
	    var dstyle = style.fracDen();
	    var newOptions;
	
	    newOptions = options.withStyle(nstyle);
	    var numer = buildGroup(group.value.numer, newOptions);
	    var numerreset = makeSpan([style.reset(), nstyle.cls()],
	        [numer], newOptions);
	
	    newOptions = options.withStyle(dstyle);
	    var denom = buildGroup(group.value.denom, newOptions);
	    var denomreset = makeSpan([style.reset(), dstyle.cls()],
	        [denom], newOptions);
	
	    var ruleWidth;
	    if (group.value.hasBarLine) {
	        ruleWidth = fontMetrics.metrics.defaultRuleThickness /
	            options.style.sizeMultiplier;
	    } else {
	        ruleWidth = 0;
	    }
	
	    // Rule 15b
	    var numShift;
	    var clearance;
	    var denomShift;
	    if (style.size === Style.DISPLAY.size) {
	        numShift = style.metrics.num1;
	        if (ruleWidth > 0) {
	            clearance = 3 * ruleWidth;
	        } else {
	            clearance = 7 * fontMetrics.metrics.defaultRuleThickness;
	        }
	        denomShift = style.metrics.denom1;
	    } else {
	        if (ruleWidth > 0) {
	            numShift = style.metrics.num2;
	            clearance = ruleWidth;
	        } else {
	            numShift = style.metrics.num3;
	            clearance = 3 * fontMetrics.metrics.defaultRuleThickness;
	        }
	        denomShift = style.metrics.denom2;
	    }
	
	    var frac;
	    if (ruleWidth === 0) {
	        // Rule 15c
	        var candidateClearance =
	            (numShift - numer.depth) - (denom.height - denomShift);
	        if (candidateClearance < clearance) {
	            numShift += 0.5 * (clearance - candidateClearance);
	            denomShift += 0.5 * (clearance - candidateClearance);
	        }
	
	        frac = buildCommon.makeVList([
	            {type: "elem", elem: denomreset, shift: denomShift},
	            {type: "elem", elem: numerreset, shift: -numShift}
	        ], "individualShift", null, options);
	    } else {
	        // Rule 15d
	        var axisHeight = style.metrics.axisHeight;
	
	        if ((numShift - numer.depth) - (axisHeight + 0.5 * ruleWidth) <
	                clearance) {
	            numShift +=
	                clearance - ((numShift - numer.depth) -
	                             (axisHeight + 0.5 * ruleWidth));
	        }
	
	        if ((axisHeight - 0.5 * ruleWidth) - (denom.height - denomShift) <
	                clearance) {
	            denomShift +=
	                clearance - ((axisHeight - 0.5 * ruleWidth) -
	                             (denom.height - denomShift));
	        }
	
	        var mid = makeSpan(
	            [options.style.reset(), Style.TEXT.cls(), "frac-line"]);
	        // Manually set the height of the line because its height is
	        // created in CSS
	        mid.height = ruleWidth;
	
	        var midShift = -(axisHeight - 0.5 * ruleWidth);
	
	        frac = buildCommon.makeVList([
	            {type: "elem", elem: denomreset, shift: denomShift},
	            {type: "elem", elem: mid,        shift: midShift},
	            {type: "elem", elem: numerreset, shift: -numShift}
	        ], "individualShift", null, options);
	    }
	
	    // Since we manually change the style sometimes (with \dfrac or \tfrac),
	    // account for the possible size change here.
	    frac.height *= style.sizeMultiplier / options.style.sizeMultiplier;
	    frac.depth *= style.sizeMultiplier / options.style.sizeMultiplier;
	
	    // Rule 15e
	    var delimSize;
	    if (style.size === Style.DISPLAY.size) {
	        delimSize = style.metrics.delim1;
	    } else {
	        delimSize = style.metrics.delim2;
	    }
	
	    var leftDelim;
	    var rightDelim;
	    if (group.value.leftDelim == null) {
	        leftDelim = makeNullDelimiter(options, ["mopen"]);
	    } else {
	        leftDelim = delimiter.customSizedDelim(
	            group.value.leftDelim, delimSize, true,
	            options.withStyle(style), group.mode, ["mopen"]);
	    }
	    if (group.value.rightDelim == null) {
	        rightDelim = makeNullDelimiter(options, ["mclose"]);
	    } else {
	        rightDelim = delimiter.customSizedDelim(
	            group.value.rightDelim, delimSize, true,
	            options.withStyle(style), group.mode, ["mclose"]);
	    }
	
	    return makeSpan(
	        ["mord", options.style.reset(), style.cls()],
	        [leftDelim, makeSpan(["mfrac"], [frac]), rightDelim],
	        options);
	};
	
	var calculateSize = function(sizeValue, style) {
	    var x = sizeValue.number;
	    if (sizeValue.unit === "ex") {
	        x *= style.metrics.emPerEx;
	    } else if (sizeValue.unit === "mu") {
	        x /= 18;
	    }
	    return x;
	};
	
	groupTypes.array = function(group, options) {
	    var r;
	    var c;
	    var nr = group.value.body.length;
	    var nc = 0;
	    var body = new Array(nr);
	
	    var style = options.style;
	
	    // Horizontal spacing
	    var pt = 1 / fontMetrics.metrics.ptPerEm;
	    var arraycolsep = 5 * pt; // \arraycolsep in article.cls
	
	    // Vertical spacing
	    var baselineskip = 12 * pt; // see size10.clo
	    // Default \arraystretch from lttab.dtx
	    // TODO(gagern): may get redefined once we have user-defined macros
	    var arraystretch = utils.deflt(group.value.arraystretch, 1);
	    var arrayskip = arraystretch * baselineskip;
	    var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and
	    var arstrutDepth = 0.3 * arrayskip;  // \@arstrutbox in lttab.dtx
	
	    var totalHeight = 0;
	    for (r = 0; r < group.value.body.length; ++r) {
	        var inrow = group.value.body[r];
	        var height = arstrutHeight; // \@array adds an \@arstrut
	        var depth = arstrutDepth;   // to each tow (via the template)
	
	        if (nc < inrow.length) {
	            nc = inrow.length;
	        }
	
	        var outrow = new Array(inrow.length);
	        for (c = 0; c < inrow.length; ++c) {
	            var elt = buildGroup(inrow[c], options);
	            if (depth < elt.depth) {
	                depth = elt.depth;
	            }
	            if (height < elt.height) {
	                height = elt.height;
	            }
	            outrow[c] = elt;
	        }
	
	        var gap = 0;
	        if (group.value.rowGaps[r]) {
	            gap = calculateSize(group.value.rowGaps[r].value, style);
	            if (gap > 0) { // \@argarraycr
	                gap += arstrutDepth;
	                if (depth < gap) {
	                    depth = gap; // \@xargarraycr
	                }
	                gap = 0;
	            }
	        }
	
	        outrow.height = height;
	        outrow.depth = depth;
	        totalHeight += height;
	        outrow.pos = totalHeight;
	        totalHeight += depth + gap; // \@yargarraycr
	        body[r] = outrow;
	    }
	
	    var offset = totalHeight / 2 + style.metrics.axisHeight;
	    var colDescriptions = group.value.cols || [];
	    var cols = [];
	    var colSep;
	    var colDescrNum;
	    for (c = 0, colDescrNum = 0;
	         // Continue while either there are more columns or more column
	         // descriptions, so trailing separators don't get lost.
	         c < nc || colDescrNum < colDescriptions.length;
	         ++c, ++colDescrNum) {
	
	        var colDescr = colDescriptions[colDescrNum] || {};
	
	        var firstSeparator = true;
	        while (colDescr.type === "separator") {
	            // If there is more than one separator in a row, add a space
	            // between them.
	            if (!firstSeparator) {
	                colSep = makeSpan(["arraycolsep"], []);
	                colSep.style.width =
	                    fontMetrics.metrics.doubleRuleSep + "em";
	                cols.push(colSep);
	            }
	
	            if (colDescr.separator === "|") {
	                var separator = makeSpan(
	                    ["vertical-separator"],
	                    []);
	                separator.style.height = totalHeight + "em";
	                separator.style.verticalAlign =
	                    -(totalHeight - offset) + "em";
	
	                cols.push(separator);
	            } else {
	                throw new ParseError(
	                    "Invalid separator type: " + colDescr.separator);
	            }
	
	            colDescrNum++;
	            colDescr = colDescriptions[colDescrNum] || {};
	            firstSeparator = false;
	        }
	
	        if (c >= nc) {
	            continue;
	        }
	
	        var sepwidth;
	        if (c > 0 || group.value.hskipBeforeAndAfter) {
	            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
	            if (sepwidth !== 0) {
	                colSep = makeSpan(["arraycolsep"], []);
	                colSep.style.width = sepwidth + "em";
	                cols.push(colSep);
	            }
	        }
	
	        var col = [];
	        for (r = 0; r < nr; ++r) {
	            var row = body[r];
	            var elem = row[c];
	            if (!elem) {
	                continue;
	            }
	            var shift = row.pos - offset;
	            elem.depth = row.depth;
	            elem.height = row.height;
	            col.push({type: "elem", elem: elem, shift: shift});
	        }
	
	        col = buildCommon.makeVList(col, "individualShift", null, options);
	        col = makeSpan(
	            ["col-align-" + (colDescr.align || "c")],
	            [col]);
	        cols.push(col);
	
	        if (c < nc - 1 || group.value.hskipBeforeAndAfter) {
	            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
	            if (sepwidth !== 0) {
	                colSep = makeSpan(["arraycolsep"], []);
	                colSep.style.width = sepwidth + "em";
	                cols.push(colSep);
	            }
	        }
	    }
	    body = makeSpan(["mtable"], cols);
	    return makeSpan(["mord"], [body], options);
	};
	
	groupTypes.spacing = function(group, options) {
	    if (group.value === "\\ " || group.value === "\\space" ||
	        group.value === " " || group.value === "~") {
	        // Spaces are generated by adding an actual space. Each of these
	        // things has an entry in the symbols table, so these will be turned
	        // into appropriate outputs.
	        if (group.mode === "text") {
	            return buildCommon.makeOrd(group, options, "textord");
	        } else {
	            return makeSpan(["mspace"],
	                [buildCommon.mathsym(group.value, group.mode, options)],
	                options);
	        }
	    } else {
	        // Other kinds of spaces are of arbitrary width. We use CSS to
	        // generate these.
	        return makeSpan(
	            ["mspace",
	                buildCommon.spacingFunctions[group.value].className],
	            [], options);
	    }
	};
	
	groupTypes.llap = function(group, options) {
	    var inner = makeSpan(
	        ["inner"], [buildGroup(group.value.body, options.reset())]);
	    var fix = makeSpan(["fix"], []);
	    return makeSpan(
	        ["mord", "llap", options.style.cls()], [inner, fix], options);
	};
	
	groupTypes.rlap = function(group, options) {
	    var inner = makeSpan(
	        ["inner"], [buildGroup(group.value.body, options.reset())]);
	    var fix = makeSpan(["fix"], []);
	    return makeSpan(
	        ["mord", "rlap", options.style.cls()], [inner, fix], options);
	};
	
	groupTypes.op = function(group, options) {
	    // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
	    var supGroup;
	    var subGroup;
	    var hasLimits = false;
	    if (group.type === "supsub") {
	        // If we have limits, supsub will pass us its group to handle. Pull
	        // out the superscript and subscript and set the group to the op in
	        // its base.
	        supGroup = group.value.sup;
	        subGroup = group.value.sub;
	        group = group.value.base;
	        hasLimits = true;
	    }
	
	    var style = options.style;
	
	    // Most operators have a large successor symbol, but these don't.
	    var noSuccessor = [
	        "\\smallint"
	    ];
	
	    var large = false;
	    if (style.size === Style.DISPLAY.size &&
	        group.value.symbol &&
	        !utils.contains(noSuccessor, group.value.body)) {
	
	        // Most symbol operators get larger in displaystyle (rule 13)
	        large = true;
	    }
	
	    var base;
	    var baseShift = 0;
	    var slant = 0;
	    if (group.value.symbol) {
	        // If this is a symbol, create the symbol.
	        var fontName = large ? "Size2-Regular" : "Size1-Regular";
	        base = buildCommon.makeSymbol(
	            group.value.body, fontName, "math", options,
	            ["mop", "op-symbol", large ? "large-op" : "small-op"]);
	
	        // Shift the symbol so its center lies on the axis (rule 13). It
	        // appears that our fonts have the centers of the symbols already
	        // almost on the axis, so these numbers are very small. Note we
	        // don't actually apply this here, but instead it is used either in
	        // the vlist creation or separately when there are no limits.
	        baseShift = (base.height - base.depth) / 2 -
	            style.metrics.axisHeight * style.sizeMultiplier;
	
	        // The slant of the symbol is just its italic correction.
	        slant = base.italic;
	    } else if (group.value.value) {
	        // If this is a list, compose that list.
	        var inner = buildExpression(group.value.value, options, true);
	
	        base = makeSpan(["mop"], inner, options);
	    } else {
	        // Otherwise, this is a text operator. Build the text from the
	        // operator's name.
	        // TODO(emily): Add a space in the middle of some of these
	        // operators, like \limsup
	        var output = [];
	        for (var i = 1; i < group.value.body.length; i++) {
	            output.push(buildCommon.mathsym(group.value.body[i], group.mode));
	        }
	        base = makeSpan(["mop"], output, options);
	    }
	
	    if (hasLimits) {
	        // IE 8 clips \int if it is in a display: inline-block. We wrap it
	        // in a new span so it is an inline, and works.
	        base = makeSpan([], [base]);
	
	        var supmid;
	        var supKern;
	        var submid;
	        var subKern;
	        var newOptions;
	        // We manually have to handle the superscripts and subscripts. This,
	        // aside from the kern calculations, is copied from supsub.
	        if (supGroup) {
	            newOptions = options.withStyle(style.sup());
	            var sup = buildGroup(supGroup, newOptions);
	            supmid = makeSpan([style.reset(), style.sup().cls()],
	                [sup], newOptions);
	
	            supKern = Math.max(
	                fontMetrics.metrics.bigOpSpacing1,
	                fontMetrics.metrics.bigOpSpacing3 - sup.depth);
	        }
	
	        if (subGroup) {
	            newOptions = options.withStyle(style.sub());
	            var sub = buildGroup(subGroup, newOptions);
	            submid = makeSpan([style.reset(), style.sub().cls()],
	                [sub], newOptions);
	
	            subKern = Math.max(
	                fontMetrics.metrics.bigOpSpacing2,
	                fontMetrics.metrics.bigOpSpacing4 - sub.height);
	        }
	
	        // Build the final group as a vlist of the possible subscript, base,
	        // and possible superscript.
	        var finalGroup;
	        var top;
	        var bottom;
	        if (!supGroup) {
	            top = base.height - baseShift;
	
	            finalGroup = buildCommon.makeVList([
	                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
	                {type: "elem", elem: submid},
	                {type: "kern", size: subKern},
	                {type: "elem", elem: base}
	            ], "top", top, options);
	
	            // Here, we shift the limits by the slant of the symbol. Note
	            // that we are supposed to shift the limits by 1/2 of the slant,
	            // but since we are centering the limits adding a full slant of
	            // margin will shift by 1/2 that.
	            finalGroup.children[0].style.marginLeft = -slant + "em";
	        } else if (!subGroup) {
	            bottom = base.depth + baseShift;
	
	            finalGroup = buildCommon.makeVList([
	                {type: "elem", elem: base},
	                {type: "kern", size: supKern},
	                {type: "elem", elem: supmid},
	                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
	            ], "bottom", bottom, options);
	
	            // See comment above about slants
	            finalGroup.children[1].style.marginLeft = slant + "em";
	        } else if (!supGroup && !subGroup) {
	            // This case probably shouldn't occur (this would mean the
	            // supsub was sending us a group with no superscript or
	            // subscript) but be safe.
	            return base;
	        } else {
	            bottom = fontMetrics.metrics.bigOpSpacing5 +
	                submid.height + submid.depth +
	                subKern +
	                base.depth + baseShift;
	
	            finalGroup = buildCommon.makeVList([
	                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
	                {type: "elem", elem: submid},
	                {type: "kern", size: subKern},
	                {type: "elem", elem: base},
	                {type: "kern", size: supKern},
	                {type: "elem", elem: supmid},
	                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
	            ], "bottom", bottom, options);
	
	            // See comment above about slants
	            finalGroup.children[0].style.marginLeft = -slant + "em";
	            finalGroup.children[2].style.marginLeft = slant + "em";
	        }
	
	        return makeSpan(["mop", "op-limits"], [finalGroup], options);
	    } else {
	        if (group.value.symbol) {
	            base.style.top = baseShift + "em";
	        }
	
	        return base;
	    }
	};
	
	groupTypes.mod = function(group, options) {
	    var inner = [];
	
	    if (group.value.modType === "bmod") {
	        // \nonscript\mskip-\medmuskip\mkern5mu
	        if (!options.style.isTight()) {
	            inner.push(makeSpan(
	                ["mspace", "negativemediumspace"], [], options));
	        }
	        inner.push(makeSpan(["mspace", "thickspace"], [], options));
	    } else if (options.style.size === Style.DISPLAY.size) {
	        inner.push(makeSpan(["mspace", "quad"], [], options));
	    } else if (group.value.modType === "mod") {
	        inner.push(makeSpan(["mspace", "twelvemuspace"], [], options));
	    } else {
	        inner.push(makeSpan(["mspace", "eightmuspace"], [], options));
	    }
	
	    if (group.value.modType === "pod" || group.value.modType === "pmod") {
	        inner.push(buildCommon.mathsym("(", group.mode));
	    }
	
	    if (group.value.modType !== "pod") {
	        var modInner = [
	            buildCommon.mathsym("m", group.mode),
	            buildCommon.mathsym("o", group.mode),
	            buildCommon.mathsym("d", group.mode)];
	        if (group.value.modType === "bmod") {
	            inner.push(makeSpan(["mbin"], modInner, options));
	            // \mkern5mu\nonscript\mskip-\medmuskip
	            inner.push(makeSpan(["mspace", "thickspace"], [], options));
	            if (!options.style.isTight()) {
	                inner.push(makeSpan(
	                    ["mspace", "negativemediumspace"], [], options));
	            }
	        } else {
	            Array.prototype.push.apply(inner, modInner);
	            inner.push(makeSpan(["mspace", "sixmuspace"], [], options));
	        }
	    }
	
	    if (group.value.value) {
	        Array.prototype.push.apply(inner,
	            buildExpression(group.value.value, options, false));
	    }
	
	    if (group.value.modType === "pod" || group.value.modType === "pmod") {
	        inner.push(buildCommon.mathsym(")", group.mode));
	    }
	
	    return buildCommon.makeFragment(inner);
	};
	
	groupTypes.katex = function(group, options) {
	    // The KaTeX logo. The offsets for the K and a were chosen to look
	    // good, but the offsets for the T, E, and X were taken from the
	    // definition of \TeX in TeX (see TeXbook pg. 356)
	    var k = makeSpan(
	        ["k"], [buildCommon.mathsym("K", group.mode)], options);
	    var a = makeSpan(
	        ["a"], [buildCommon.mathsym("A", group.mode)], options);
	
	    a.height = (a.height + 0.2) * 0.75;
	    a.depth = (a.height - 0.2) * 0.75;
	
	    var t = makeSpan(
	        ["t"], [buildCommon.mathsym("T", group.mode)], options);
	    var e = makeSpan(
	        ["e"], [buildCommon.mathsym("E", group.mode)], options);
	
	    e.height = (e.height - 0.2155);
	    e.depth = (e.depth + 0.2155);
	
	    var x = makeSpan(
	        ["x"], [buildCommon.mathsym("X", group.mode)], options);
	
	    return makeSpan(
	        ["mord", "katex-logo"], [k, a, t, e, x], options);
	};
	
	groupTypes.overline = function(group, options) {
	    // Overlines are handled in the TeXbook pg 443, Rule 9.
	    var style = options.style;
	
	    // Build the inner group in the cramped style.
	    var innerGroup = buildGroup(group.value.body,
	            options.withStyle(style.cramp()));
	
	    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
	        style.sizeMultiplier;
	
	    // Create the line above the body
	    var line = makeSpan(
	        [style.reset(), Style.TEXT.cls(), "overline-line"]);
	    line.height = ruleWidth;
	    line.maxFontSize = 1.0;
	
	    // Generate the vlist, with the appropriate kerns
	    var vlist = buildCommon.makeVList([
	        {type: "elem", elem: innerGroup},
	        {type: "kern", size: 3 * ruleWidth},
	        {type: "elem", elem: line},
	        {type: "kern", size: ruleWidth}
	    ], "firstBaseline", null, options);
	
	    return makeSpan(["mord", "overline"], [vlist], options);
	};
	
	groupTypes.underline = function(group, options) {
	    // Underlines are handled in the TeXbook pg 443, Rule 10.
	    var style = options.style;
	
	    // Build the inner group.
	    var innerGroup = buildGroup(group.value.body, options);
	
	    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
	        style.sizeMultiplier;
	
	    // Create the line above the body
	    var line = makeSpan([style.reset(), Style.TEXT.cls(), "underline-line"]);
	    line.height = ruleWidth;
	    line.maxFontSize = 1.0;
	
	    // Generate the vlist, with the appropriate kerns
	    var vlist = buildCommon.makeVList([
	        {type: "kern", size: ruleWidth},
	        {type: "elem", elem: line},
	        {type: "kern", size: 3 * ruleWidth},
	        {type: "elem", elem: innerGroup}
	    ], "top", innerGroup.height, options);
	
	    return makeSpan(["mord", "underline"], [vlist], options);
	};
	
	groupTypes.sqrt = function(group, options) {
	    // Square roots are handled in the TeXbook pg. 443, Rule 11.
	    var style = options.style;
	
	    // First, we do the same steps as in overline to build the inner group
	    // and line
	    var inner = buildGroup(group.value.body, options.withStyle(style.cramp()));
	
	    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
	        style.sizeMultiplier;
	
	    var line = makeSpan(
	        [style.reset(), Style.TEXT.cls(), "sqrt-line"], [],
	        options);
	    line.height = ruleWidth;
	    line.maxFontSize = 1.0;
	
	    var phi = ruleWidth;
	    if (style.id < Style.TEXT.id) {
	        phi = style.metrics.xHeight;
	    }
	
	    // Calculate the clearance between the body and line
	    var lineClearance = ruleWidth + phi / 4;
	
	    var innerHeight = (inner.height + inner.depth) * style.sizeMultiplier;
	    var minDelimiterHeight = innerHeight + lineClearance + ruleWidth;
	
	    // Create a \surd delimiter of the required minimum size
	    var delim = makeSpan(["sqrt-sign"], [
	        delimiter.customSizedDelim("\\surd", minDelimiterHeight,
	                                   false, options, group.mode)],
	                         options);
	
	    var delimDepth = (delim.height + delim.depth) - ruleWidth;
	
	    // Adjust the clearance based on the delimiter size
	    if (delimDepth > inner.height + inner.depth + lineClearance) {
	        lineClearance =
	            (lineClearance + delimDepth - inner.height - inner.depth) / 2;
	    }
	
	    // Shift the delimiter so that its top lines up with the top of the line
	    var delimShift = -(inner.height + lineClearance + ruleWidth) + delim.height;
	    delim.style.top = delimShift + "em";
	    delim.height -= delimShift;
	    delim.depth += delimShift;
	
	    // We add a special case here, because even when `inner` is empty, we
	    // still get a line. So, we use a simple heuristic to decide if we
	    // should omit the body entirely. (note this doesn't work for something
	    // like `\sqrt{\rlap{x}}`, but if someone is doing that they deserve for
	    // it not to work.
	    var body;
	    if (inner.height === 0 && inner.depth === 0) {
	        body = makeSpan();
	    } else {
	        body = buildCommon.makeVList([
	            {type: "elem", elem: inner},
	            {type: "kern", size: lineClearance},
	            {type: "elem", elem: line},
	            {type: "kern", size: ruleWidth}
	        ], "firstBaseline", null, options);
	    }
	
	    if (!group.value.index) {
	        return makeSpan(["mord", "sqrt"], [delim, body], options);
	    } else {
	        // Handle the optional root index
	
	        // The index is always in scriptscript style
	        var newOptions = options.withStyle(Style.SCRIPTSCRIPT);
	        var root = buildGroup(group.value.index, newOptions);
	        var rootWrap = makeSpan(
	            [style.reset(), Style.SCRIPTSCRIPT.cls()],
	            [root],
	            newOptions);
	
	        // Figure out the height and depth of the inner part
	        var innerRootHeight = Math.max(delim.height, body.height);
	        var innerRootDepth = Math.max(delim.depth, body.depth);
	
	        // The amount the index is shifted by. This is taken from the TeX
	        // source, in the definition of `\r@@t`.
	        var toShift = 0.6 * (innerRootHeight - innerRootDepth);
	
	        // Build a VList with the superscript shifted up correctly
	        var rootVList = buildCommon.makeVList(
	            [{type: "elem", elem: rootWrap}],
	            "shift", -toShift, options);
	        // Add a class surrounding it so we can add on the appropriate
	        // kerning
	        var rootVListWrap = makeSpan(["root"], [rootVList]);
	
	        return makeSpan(["mord", "sqrt"],
	            [rootVListWrap, delim, body], options);
	    }
	};
	
	groupTypes.sizing = function(group, options) {
	    // Handle sizing operators like \Huge. Real TeX doesn't actually allow
	    // these functions inside of math expressions, so we do some special
	    // handling.
	    var inner = buildExpression(group.value.value,
	            options.withSize(group.value.size), false);
	
	    // Compute the correct maxFontSize.
	    var style = options.style;
	    var fontSize = buildCommon.sizingMultiplier[group.value.size];
	    fontSize = fontSize * style.sizeMultiplier;
	
	    // Add size-resetting classes to the inner list and set maxFontSize
	    // manually. Handle nested size changes.
	    for (var i = 0; i < inner.length; i++) {
	        var pos = utils.indexOf(inner[i].classes, "sizing");
	        if (pos < 0) {
	            inner[i].classes.push("sizing", "reset-" + options.size,
	                                  group.value.size, style.cls());
	            inner[i].maxFontSize = fontSize;
	        } else if (inner[i].classes[pos + 1] === "reset-" + group.value.size) {
	            // This is a nested size change: e.g., inner[i] is the "b" in
	            // `\Huge a \small b`. Override the old size (the `reset-` class)
	            // but not the new size.
	            inner[i].classes[pos + 1] = "reset-" + options.size;
	        }
	    }
	
	    return buildCommon.makeFragment(inner);
	};
	
	groupTypes.styling = function(group, options) {
	    // Style changes are handled in the TeXbook on pg. 442, Rule 3.
	
	    // Figure out what style we're changing to.
	    var styleMap = {
	        "display": Style.DISPLAY,
	        "text": Style.TEXT,
	        "script": Style.SCRIPT,
	        "scriptscript": Style.SCRIPTSCRIPT
	    };
	
	    var newStyle = styleMap[group.value.style];
	    var newOptions = options.withStyle(newStyle);
	
	    // Build the inner expression in the new style.
	    var inner = buildExpression(
	        group.value.value, newOptions, false);
	
	    // Add style-resetting classes to the inner list. Handle nested changes.
	    for (var i = 0; i < inner.length; i++) {
	        var pos = utils.indexOf(inner[i].classes, newStyle.reset());
	        if (pos < 0) {
	            inner[i].classes.push(options.style.reset(), newStyle.cls());
	        } else {
	            // This is a nested style change, as `\textstyle a\scriptstyle b`.
	            // Only override the old style (the reset class).
	            inner[i].classes[pos] = options.style.reset();
	        }
	    }
	
	    return new buildCommon.makeFragment(inner);
	};
	
	groupTypes.font = function(group, options) {
	    var font = group.value.font;
	    return buildGroup(group.value.body, options.withFont(font));
	};
	
	groupTypes.delimsizing = function(group, options) {
	    var delim = group.value.value;
	
	    if (delim === ".") {
	        // Empty delimiters still count as elements, even though they don't
	        // show anything.
	        return makeSpan([group.value.mclass]);
	    }
	
	    // Use delimiter.sizedDelim to generate the delimiter.
	    return delimiter.sizedDelim(
	            delim, group.value.size, options, group.mode,
	            [group.value.mclass]);
	};
	
	groupTypes.leftright = function(group, options) {
	    // Build the inner expression
	    var inner = buildExpression(group.value.body, options.reset(), true);
	
	    var innerHeight = 0;
	    var innerDepth = 0;
	    var hadMiddle = false;
	
	    // Calculate its height and depth
	    for (var i = 0; i < inner.length; i++) {
	        if (inner[i].isMiddle) {
	            hadMiddle = true;
	        } else {
	            innerHeight = Math.max(inner[i].height, innerHeight);
	            innerDepth = Math.max(inner[i].depth, innerDepth);
	        }
	    }
	
	    var style = options.style;
	
	    // The size of delimiters is the same, regardless of what style we are
	    // in. Thus, to correctly calculate the size of delimiter we need around
	    // a group, we scale down the inner size based on the size.
	    innerHeight *= style.sizeMultiplier;
	    innerDepth *= style.sizeMultiplier;
	
	    var leftDelim;
	    if (group.value.left === ".") {
	        // Empty delimiters in \left and \right make null delimiter spaces.
	        leftDelim = makeNullDelimiter(options, ["mopen"]);
	    } else {
	        // Otherwise, use leftRightDelim to generate the correct sized
	        // delimiter.
	        leftDelim = delimiter.leftRightDelim(
	            group.value.left, innerHeight, innerDepth, options,
	            group.mode, ["mopen"]);
	    }
	    // Add it to the beginning of the expression
	    inner.unshift(leftDelim);
	
	    // Handle middle delimiters
	    if (hadMiddle) {
	        for (i = 1; i < inner.length; i++) {
	            if (inner[i].isMiddle) {
	                // Apply the options that were active when \middle was called
	                inner[i] = delimiter.leftRightDelim(
	                    inner[i].isMiddle.value, innerHeight, innerDepth,
	                    inner[i].isMiddle.options, group.mode, []);
	            }
	        }
	    }
	
	    var rightDelim;
	    // Same for the right delimiter
	    if (group.value.right === ".") {
	        rightDelim = makeNullDelimiter(options, ["mclose"]);
	    } else {
	        rightDelim = delimiter.leftRightDelim(
	            group.value.right, innerHeight, innerDepth, options,
	            group.mode, ["mclose"]);
	    }
	    // Add it to the end of the expression.
	    inner.push(rightDelim);
	
	    return makeSpan(
	        ["minner", style.cls()], inner, options);
	};
	
	groupTypes.middle = function(group, options) {
	    var middleDelim;
	    if (group.value.value === ".") {
	        middleDelim = makeNullDelimiter(options, []);
	    } else {
	        middleDelim = delimiter.sizedDelim(
	            group.value.value, 1, options,
	            group.mode, []);
	        middleDelim.isMiddle = {value: group.value.value, options: options};
	    }
	    return middleDelim;
	};
	
	groupTypes.rule = function(group, options) {
	    // Make an empty span for the rule
	    var rule = makeSpan(["mord", "rule"], [], options);
	    var style = options.style;
	
	    // Calculate the shift, width, and height of the rule, and account for units
	    var shift = 0;
	    if (group.value.shift) {
	        shift = calculateSize(group.value.shift, style);
	    }
	
	    var width = calculateSize(group.value.width, style);
	    var height = calculateSize(group.value.height, style);
	
	    // The sizes of rules are absolute, so make it larger if we are in a
	    // smaller style.
	    shift /= style.sizeMultiplier;
	    width /= style.sizeMultiplier;
	    height /= style.sizeMultiplier;
	
	    // Style the rule to the right size
	    rule.style.borderRightWidth = width + "em";
	    rule.style.borderTopWidth = height + "em";
	    rule.style.bottom = shift + "em";
	
	    // Record the height and width
	    rule.width = width;
	    rule.height = height + shift;
	    rule.depth = -shift;
	
	    return rule;
	};
	
	groupTypes.kern = function(group, options) {
	    // Make an empty span for the rule
	    var rule = makeSpan(["mord", "rule"], [], options);
	    var style = options.style;
	
	    var dimension = 0;
	    if (group.value.dimension) {
	        dimension = calculateSize(group.value.dimension, style);
	    }
	
	    dimension /= style.sizeMultiplier;
	
	    rule.style.marginLeft = dimension + "em";
	
	    return rule;
	};
	
	groupTypes.accent = function(group, options) {
	    // Accents are handled in the TeXbook pg. 443, rule 12.
	    var base = group.value.base;
	    var style = options.style;
	
	    var supsubGroup;
	    if (group.type === "supsub") {
	        // If our base is a character box, and we have superscripts and
	        // subscripts, the supsub will defer to us. In particular, we want
	        // to attach the superscripts and subscripts to the inner body (so
	        // that the position of the superscripts and subscripts won't be
	        // affected by the height of the accent). We accomplish this by
	        // sticking the base of the accent into the base of the supsub, and
	        // rendering that, while keeping track of where the accent is.
	
	        // The supsub group is the group that was passed in
	        var supsub = group;
	        // The real accent group is the base of the supsub group
	        group = supsub.value.base;
	        // The character box is the base of the accent group
	        base = group.value.base;
	        // Stick the character box into the base of the supsub group
	        supsub.value.base = base;
	
	        // Rerender the supsub group with its new base, and store that
	        // result.
	        supsubGroup = buildGroup(
	            supsub, options.reset());
	    }
	
	    // Build the base group
	    var body = buildGroup(
	        base, options.withStyle(style.cramp()));
	
	    // Calculate the skew of the accent. This is based on the line "If the
	    // nucleus is not a single character, let s = 0; otherwise set s to the
	    // kern amount for the nucleus followed by the \skewchar of its font."
	    // Note that our skew metrics are just the kern between each character
	    // and the skewchar.
	    var skew;
	    if (isCharacterBox(base)) {
	        // If the base is a character box, then we want the skew of the
	        // innermost character. To do that, we find the innermost character:
	        var baseChar = getBaseElem(base);
	        // Then, we render its group to get the symbol inside it
	        var baseGroup = buildGroup(
	            baseChar, options.withStyle(style.cramp()));
	        // Finally, we pull the skew off of the symbol.
	        skew = baseGroup.skew;
	        // Note that we now throw away baseGroup, because the layers we
	        // removed with getBaseElem might contain things like \color which
	        // we can't get rid of.
	        // TODO(emily): Find a better way to get the skew
	    } else {
	        skew = 0;
	    }
	
	    // calculate the amount of space between the body and the accent
	    var clearance = Math.min(
	        body.height,
	        style.metrics.xHeight);
	
	    // Build the accent
	    var accent = buildCommon.makeSymbol(
	        group.value.accent, "Main-Regular", "math", options);
	    // Remove the italic correction of the accent, because it only serves to
	    // shift the accent over to a place we don't want.
	    accent.italic = 0;
	
	    // The \vec character that the fonts use is a combining character, and
	    // thus shows up much too far to the left. To account for this, we add a
	    // specific class which shifts the accent over to where we want it.
	    // TODO(emily): Fix this in a better way, like by changing the font
	    var vecClass = group.value.accent === "\\vec" ? "accent-vec" : null;
	
	    var accentBody = makeSpan(["accent-body", vecClass], [
	        makeSpan([], [accent])]);
	
	    accentBody = buildCommon.makeVList([
	        {type: "elem", elem: body},
	        {type: "kern", size: -clearance},
	        {type: "elem", elem: accentBody}
	    ], "firstBaseline", null, options);
	
	    // Shift the accent over by the skew. Note we shift by twice the skew
	    // because we are centering the accent, so by adding 2*skew to the left,
	    // we shift it to the right by 1*skew.
	    accentBody.children[1].style.marginLeft = 2 * skew + "em";
	
	    var accentWrap = makeSpan(["mord", "accent"], [accentBody], options);
	
	    if (supsubGroup) {
	        // Here, we replace the "base" child of the supsub with our newly
	        // generated accent.
	        supsubGroup.children[0] = accentWrap;
	
	        // Since we don't rerun the height calculation after replacing the
	        // accent, we manually recalculate height.
	        supsubGroup.height = Math.max(accentWrap.height, supsubGroup.height);
	
	        // Accents should always be ords, even when their innards are not.
	        supsubGroup.classes[0] = "mord";
	
	        return supsubGroup;
	    } else {
	        return accentWrap;
	    }
	};
	
	groupTypes.phantom = function(group, options) {
	    var elements = buildExpression(
	        group.value.value,
	        options.withPhantom(),
	        false
	    );
	
	    // \phantom isn't supposed to affect the elements it contains.
	    // See "color" for more details.
	    return new buildCommon.makeFragment(elements);
	};
	
	groupTypes.mclass = function(group, options) {
	    var elements = buildExpression(group.value.value, options, true);
	
	    return makeSpan([group.value.mclass], elements, options);
	};
	
	/**
	 * buildGroup is the function that takes a group and calls the correct groupType
	 * function for it. It also handles the interaction of size and style changes
	 * between parents and children.
	 */
	var buildGroup = function(group, options) {
	    if (!group) {
	        return makeSpan();
	    }
	
	    if (groupTypes[group.type]) {
	        // Call the groupTypes function
	        var groupNode = groupTypes[group.type](group, options);
	        var multiplier;
	
	        // If the style changed between the parent and the current group,
	        // account for the size difference
	        if (options.style !== options.parentStyle) {
	            multiplier = options.style.sizeMultiplier /
	                    options.parentStyle.sizeMultiplier;
	
	            groupNode.height *= multiplier;
	            groupNode.depth *= multiplier;
	        }
	
	        // If the size changed between the parent and the current group, account
	        // for that size difference.
	        if (options.size !== options.parentSize) {
	            multiplier = buildCommon.sizingMultiplier[options.size] /
	                    buildCommon.sizingMultiplier[options.parentSize];
	
	            groupNode.height *= multiplier;
	            groupNode.depth *= multiplier;
	        }
	
	        return groupNode;
	    } else {
	        throw new ParseError(
	            "Got group of unknown type: '" + group.type + "'");
	    }
	};
	
	/**
	 * Take an entire parse tree, and build it into an appropriate set of HTML
	 * nodes.
	 */
	var buildHTML = function(tree, options) {
	    // buildExpression is destructive, so we need to make a clone
	    // of the incoming tree so that it isn't accidentally changed
	    tree = JSON.parse(JSON.stringify(tree));
	
	    // Build the expression contained in the tree
	    var expression = buildExpression(tree, options, true);
	    var body = makeSpan(["base", options.style.cls()], expression, options);
	
	    // Add struts, which ensure that the top of the HTML element falls at the
	    // height of the expression, and the bottom of the HTML element falls at the
	    // depth of the expression.
	    var topStrut = makeSpan(["strut"]);
	    var bottomStrut = makeSpan(["strut", "bottom"]);
	
	    topStrut.style.height = body.height + "em";
	    bottomStrut.style.height = (body.height + body.depth) + "em";
	    // We'd like to use `vertical-align: top` but in IE 9 this lowers the
	    // baseline of the box to the bottom of this strut (instead staying in the
	    // normal place) so we use an absolute value for vertical-align instead
	    bottomStrut.style.verticalAlign = -body.depth + "em";
	
	    // Wrap the struts and body together
	    var htmlNode = makeSpan(["katex-html"], [topStrut, bottomStrut, body]);
	
	    htmlNode.setAttribute("aria-hidden", "true");
	
	    return htmlNode;
	};
	
	module.exports = buildHTML;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This file contains information and classes for the various kinds of styles
	 * used in TeX. It provides a generic `Style` class, which holds information
	 * about a specific style. It then provides instances of all the different kinds
	 * of styles possible, and provides functions to move between them and get
	 * information about them.
	 */
	
	var sigmas = __webpack_require__(110).sigmas;
	
	var metrics = [{}, {}, {}];
	var i;
	for (var key in sigmas) {
	    if (sigmas.hasOwnProperty(key)) {
	        for (i = 0; i < 3; i++) {
	            metrics[i][key] = sigmas[key][i];
	        }
	    }
	}
	for (i = 0; i < 3; i++) {
	    metrics[i].emPerEx = sigmas.xHeight[i] / sigmas.quad[i];
	}
	
	/**
	 * The main style class. Contains a unique id for the style, a size (which is
	 * the same for cramped and uncramped version of a style), a cramped flag, and a
	 * size multiplier, which gives the size difference between a style and
	 * textstyle.
	 */
	function Style(id, size, multiplier, cramped) {
	    this.id = id;
	    this.size = size;
	    this.cramped = cramped;
	    this.sizeMultiplier = multiplier;
	    this.metrics = metrics[size > 0 ? size - 1 : 0];
	}
	
	/**
	 * Get the style of a superscript given a base in the current style.
	 */
	Style.prototype.sup = function() {
	    return styles[sup[this.id]];
	};
	
	/**
	 * Get the style of a subscript given a base in the current style.
	 */
	Style.prototype.sub = function() {
	    return styles[sub[this.id]];
	};
	
	/**
	 * Get the style of a fraction numerator given the fraction in the current
	 * style.
	 */
	Style.prototype.fracNum = function() {
	    return styles[fracNum[this.id]];
	};
	
	/**
	 * Get the style of a fraction denominator given the fraction in the current
	 * style.
	 */
	Style.prototype.fracDen = function() {
	    return styles[fracDen[this.id]];
	};
	
	/**
	 * Get the cramped version of a style (in particular, cramping a cramped style
	 * doesn't change the style).
	 */
	Style.prototype.cramp = function() {
	    return styles[cramp[this.id]];
	};
	
	/**
	 * HTML class name, like "displaystyle cramped"
	 */
	Style.prototype.cls = function() {
	    return sizeNames[this.size] + (this.cramped ? " cramped" : " uncramped");
	};
	
	/**
	 * HTML Reset class name, like "reset-textstyle"
	 */
	Style.prototype.reset = function() {
	    return resetNames[this.size];
	};
	
	/**
	 * Return if this style is tightly spaced (scriptstyle/scriptscriptstyle)
	 */
	Style.prototype.isTight = function() {
	    return this.size >= 2;
	};
	
	// IDs of the different styles
	var D = 0;
	var Dc = 1;
	var T = 2;
	var Tc = 3;
	var S = 4;
	var Sc = 5;
	var SS = 6;
	var SSc = 7;
	
	// String names for the different sizes
	var sizeNames = [
	    "displaystyle textstyle",
	    "textstyle",
	    "scriptstyle",
	    "scriptscriptstyle"
	];
	
	// Reset names for the different sizes
	var resetNames = [
	    "reset-textstyle",
	    "reset-textstyle",
	    "reset-scriptstyle",
	    "reset-scriptscriptstyle"
	];
	
	// Instances of the different styles
	var styles = [
	    new Style(D, 0, 1.0, false),
	    new Style(Dc, 0, 1.0, true),
	    new Style(T, 1, 1.0, false),
	    new Style(Tc, 1, 1.0, true),
	    new Style(S, 2, 0.7, false),
	    new Style(Sc, 2, 0.7, true),
	    new Style(SS, 3, 0.5, false),
	    new Style(SSc, 3, 0.5, true)
	];
	
	// Lookup tables for switching from one style to another
	var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
	var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
	var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
	var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
	var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];
	
	// We only export some of the styles. Also, we don't export the `Style` class so
	// no more styles can be generated.
	module.exports = {
	    DISPLAY: styles[D],
	    TEXT: styles[T],
	    SCRIPT: styles[S],
	    SCRIPTSCRIPT: styles[SS]
	};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-unused-vars:0 */
	
	var Style = __webpack_require__(109);
	var cjkRegex = __webpack_require__(111).cjkRegex;
	
	/**
	 * This file contains metrics regarding fonts and individual symbols. The sigma
	 * and xi variables, as well as the metricMap map contain data extracted from
	 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
	 * `metrics` variable and the getCharacterMetrics function.
	 */
	
	// In TeX, there are actually three sets of dimensions, one for each of
	// textstyle, scriptstyle, and scriptscriptstyle.  These are provided in the
	// the arrays below, in that order.
	//
	// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
	// This was determined by running the folllowing script:
	//
	//     latex -interaction=nonstopmode \
	//     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
	//     '$a$ \expandafter\show\the\textfont2' \
	//     '\expandafter\show\the\scriptfont2' \
	//     '\expandafter\show\the\scriptscriptfont2' \
	//     '\stop'
	//
	// The metrics themselves were retreived using the following commands:
	//
	//     tftopl cmsy10
	//     tftopl cmsy7
	//     tftopl cmsy5
	//
	// The output of each of these commands is quite lengthy.  The only part we
	// care about is the FONTDIMEN section. Each value is measured in EMs.
	var sigmas = {
	    slant: [0.250, 0.250, 0.250],       // sigma1
	    space: [0.000, 0.000, 0.000],       // sigma2
	    stretch: [0.000, 0.000, 0.000],     // sigma3
	    shrink: [0.000, 0.000, 0.000],      // sigma4
	    xHeight: [0.431, 0.431, 0.431],     // sigma5
	    quad: [1.000, 1.171, 1.472],        // sigma6
	    extraSpace: [0.000, 0.000, 0.000],  // sigma7
	    num1: [0.677, 0.732, 0.925],        // sigma8
	    num2: [0.394, 0.384, 0.387],        // sigma9
	    num3: [0.444, 0.471, 0.504],        // sigma10
	    denom1: [0.686, 0.752, 1.025],      // sigma11
	    denom2: [0.345, 0.344, 0.532],      // sigma12
	    sup1: [0.413, 0.503, 0.504],        // sigma13
	    sup2: [0.363, 0.431, 0.404],        // sigma14
	    sup3: [0.289, 0.286, 0.294],        // sigma15
	    sub1: [0.150, 0.143, 0.200],        // sigma16
	    sub2: [0.247, 0.286, 0.400],        // sigma17
	    supDrop: [0.386, 0.353, 0.494],     // sigma18
	    subDrop: [0.050, 0.071, 0.100],     // sigma19
	    delim1: [2.390, 1.700, 1.980],      // sigma20
	    delim2: [1.010, 1.157, 1.420],      // sigma21
	    axisHeight: [0.250, 0.250, 0.250]  // sigma22
	};
	
	// These font metrics are extracted from TeX by using
	// \font\a=cmex10
	// \showthe\fontdimenX\a
	// where X is the corresponding variable number. These correspond to the font
	// parameters of the extension fonts (family 3). See the TeXbook, page 441.
	var xi1 = 0;
	var xi2 = 0;
	var xi3 = 0;
	var xi4 = 0;
	var xi5 = 0.431;
	var xi6 = 1;
	var xi7 = 0;
	var xi8 = 0.04;
	var xi9 = 0.111;
	var xi10 = 0.166;
	var xi11 = 0.2;
	var xi12 = 0.6;
	var xi13 = 0.1;
	
	// This value determines how large a pt is, for metrics which are defined in
	// terms of pts.
	// This value is also used in katex.less; if you change it make sure the values
	// match.
	var ptPerEm = 10.0;
	
	// The space between adjacent `|` columns in an array definition. From
	// `\showthe\doublerulesep` in LaTeX.
	var doubleRuleSep = 2.0 / ptPerEm;
	
	/**
	 * This is just a mapping from common names to real metrics
	 */
	var metrics = {
	    defaultRuleThickness: xi8,
	    bigOpSpacing1: xi9,
	    bigOpSpacing2: xi10,
	    bigOpSpacing3: xi11,
	    bigOpSpacing4: xi12,
	    bigOpSpacing5: xi13,
	    ptPerEm: ptPerEm,
	    doubleRuleSep: doubleRuleSep
	};
	
	// This map contains a mapping from font name and character code to character
	// metrics, including height, depth, italic correction, and skew (kern from the
	// character to the corresponding \skewchar)
	// This map is generated via `make metrics`. It should not be changed manually.
	var metricMap = __webpack_require__(112);
	
	// These are very rough approximations.  We default to Times New Roman which
	// should have Latin-1 and Cyrillic characters, but may not depending on the
	// operating system.  The metrics do not account for extra height from the
	// accents.  In the case of Cyrillic characters which have both ascenders and
	// descenders we prefer approximations with ascenders, primarily to prevent
	// the fraction bar or root line from intersecting the glyph.
	// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.
	var extraCharacterMap = {
	    // Latin-1
	    '': 'A',
	    '': 'A',
	    '': 'A',
	    '': 'A',
	    '': 'A',
	    '': 'A',
	    '': 'A',
	    '': 'C',
	    '': 'E',
	    '': 'E',
	    '': 'E',
	    '': 'E',
	    '': 'I',
	    '': 'I',
	    '': 'I',
	    '': 'I',
	    '': 'D',
	    '': 'N',
	    '': 'O',
	    '': 'O',
	    '': 'O',
	    '': 'O',
	    '': 'O',
	    '': 'O',
	    '': 'U',
	    '': 'U',
	    '': 'U',
	    '': 'U',
	    '': 'Y',
	    '': 'o',
	    '': 'B',
	    '': 'a',
	    '': 'a',
	    '': 'a',
	    '': 'a',
	    '': 'a',
	    '': 'a',
	    '': 'a',
	    '': 'c',
	    '': 'e',
	    '': 'e',
	    '': 'e',
	    '': 'e',
	    '': 'i',
	    '': 'i',
	    '': 'i',
	    '': 'i',
	    '': 'd',
	    '': 'n',
	    '': 'o',
	    '': 'o',
	    '': 'o',
	    '': 'o',
	    '': 'o',
	    '': 'o',
	    '': 'u',
	    '': 'u',
	    '': 'u',
	    '': 'u',
	    '': 'y',
	    '': 'o',
	    '': 'y',
	
	    // Cyrillic
	    '': 'A',
	    '': 'B',
	    '': 'B',
	    '': 'F',
	    '': 'A',
	    '': 'E',
	    '': 'K',
	    '': '3',
	    '': 'N',
	    '': 'N',
	    '': 'K',
	    '': 'N',
	    '': 'M',
	    '': 'H',
	    '': 'O',
	    '': 'N',
	    '': 'P',
	    '': 'C',
	    '': 'T',
	    '': 'y',
	    '': 'O',
	    '': 'X',
	    '': 'U',
	    '': 'h',
	    '': 'W',
	    '': 'W',
	    '': 'B',
	    '': 'X',
	    '': 'B',
	    '': '3',
	    '': 'X',
	    '': 'R',
	    '': 'a',
	    '': 'b',
	    '': 'a',
	    '': 'r',
	    '': 'y',
	    '': 'e',
	    '': 'm',
	    '': 'e',
	    '': 'n',
	    '': 'n',
	    '': 'n',
	    '': 'n',
	    '': 'm',
	    '': 'n',
	    '': 'o',
	    '': 'n',
	    '': 'p',
	    '': 'c',
	    '': 'o',
	    '': 'y',
	    '': 'b',
	    '': 'x',
	    '': 'n',
	    '': 'n',
	    '': 'w',
	    '': 'w',
	    '': 'a',
	    '': 'm',
	    '': 'a',
	    '': 'e',
	    '': 'm',
	    '': 'r'
	};
	
	/**
	 * This function is a convenience function for looking up information in the
	 * metricMap table. It takes a character as a string, and a style.
	 *
	 * Note: the `width` property may be undefined if fontMetricsData.js wasn't
	 * built using `Make extended_metrics`.
	 */
	var getCharacterMetrics = function(character, style) {
	    var ch = character.charCodeAt(0);
	    if (character[0] in extraCharacterMap) {
	        ch = extraCharacterMap[character[0]].charCodeAt(0);
	    } else if (cjkRegex.test(character[0])) {
	        ch = 'M'.charCodeAt(0);
	    }
	    var metrics = metricMap[style][ch];
	    if (metrics) {
	        return {
	            depth: metrics[0],
	            height: metrics[1],
	            italic: metrics[2],
	            skew: metrics[3],
	            width: metrics[4]
	        };
	    }
	};
	
	module.exports = {
	    metrics: metrics,
	    sigmas: sigmas,
	    getCharacterMetrics: getCharacterMetrics
	};


/***/ }),
/* 111 */
/***/ (function(module, exports) {

	var hangulRegex = /[\uAC00-\uD7AF]/;
	
	// This regex combines
	// - Hiragana: [\u3040-\u309F]
	// - Katakana: [\u30A0-\u30FF]
	// - CJK ideograms: [\u4E00-\u9FAF]
	// - Hangul syllables: [\uAC00-\uD7AF]
	// Notably missing are halfwidth Katakana and Romanji glyphs.
	var cjkRegex =
	    /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/;
	
	module.exports = {
	    cjkRegex: cjkRegex,
	    hangulRegex: hangulRegex
	};


/***/ }),
/* 112 */
/***/ (function(module, exports) {

	module.exports = {
	    "AMS-Regular": {
	        "65": [0, 0.68889, 0, 0],
	        "66": [0, 0.68889, 0, 0],
	        "67": [0, 0.68889, 0, 0],
	        "68": [0, 0.68889, 0, 0],
	        "69": [0, 0.68889, 0, 0],
	        "70": [0, 0.68889, 0, 0],
	        "71": [0, 0.68889, 0, 0],
	        "72": [0, 0.68889, 0, 0],
	        "73": [0, 0.68889, 0, 0],
	        "74": [0.16667, 0.68889, 0, 0],
	        "75": [0, 0.68889, 0, 0],
	        "76": [0, 0.68889, 0, 0],
	        "77": [0, 0.68889, 0, 0],
	        "78": [0, 0.68889, 0, 0],
	        "79": [0.16667, 0.68889, 0, 0],
	        "80": [0, 0.68889, 0, 0],
	        "81": [0.16667, 0.68889, 0, 0],
	        "82": [0, 0.68889, 0, 0],
	        "83": [0, 0.68889, 0, 0],
	        "84": [0, 0.68889, 0, 0],
	        "85": [0, 0.68889, 0, 0],
	        "86": [0, 0.68889, 0, 0],
	        "87": [0, 0.68889, 0, 0],
	        "88": [0, 0.68889, 0, 0],
	        "89": [0, 0.68889, 0, 0],
	        "90": [0, 0.68889, 0, 0],
	        "107": [0, 0.68889, 0, 0],
	        "165": [0, 0.675, 0.025, 0],
	        "174": [0.15559, 0.69224, 0, 0],
	        "240": [0, 0.68889, 0, 0],
	        "295": [0, 0.68889, 0, 0],
	        "710": [0, 0.825, 0, 0],
	        "732": [0, 0.9, 0, 0],
	        "770": [0, 0.825, 0, 0],
	        "771": [0, 0.9, 0, 0],
	        "989": [0.08167, 0.58167, 0, 0],
	        "1008": [0, 0.43056, 0.04028, 0],
	        "8245": [0, 0.54986, 0, 0],
	        "8463": [0, 0.68889, 0, 0],
	        "8487": [0, 0.68889, 0, 0],
	        "8498": [0, 0.68889, 0, 0],
	        "8502": [0, 0.68889, 0, 0],
	        "8503": [0, 0.68889, 0, 0],
	        "8504": [0, 0.68889, 0, 0],
	        "8513": [0, 0.68889, 0, 0],
	        "8592": [-0.03598, 0.46402, 0, 0],
	        "8594": [-0.03598, 0.46402, 0, 0],
	        "8602": [-0.13313, 0.36687, 0, 0],
	        "8603": [-0.13313, 0.36687, 0, 0],
	        "8606": [0.01354, 0.52239, 0, 0],
	        "8608": [0.01354, 0.52239, 0, 0],
	        "8610": [0.01354, 0.52239, 0, 0],
	        "8611": [0.01354, 0.52239, 0, 0],
	        "8619": [0, 0.54986, 0, 0],
	        "8620": [0, 0.54986, 0, 0],
	        "8621": [-0.13313, 0.37788, 0, 0],
	        "8622": [-0.13313, 0.36687, 0, 0],
	        "8624": [0, 0.69224, 0, 0],
	        "8625": [0, 0.69224, 0, 0],
	        "8630": [0, 0.43056, 0, 0],
	        "8631": [0, 0.43056, 0, 0],
	        "8634": [0.08198, 0.58198, 0, 0],
	        "8635": [0.08198, 0.58198, 0, 0],
	        "8638": [0.19444, 0.69224, 0, 0],
	        "8639": [0.19444, 0.69224, 0, 0],
	        "8642": [0.19444, 0.69224, 0, 0],
	        "8643": [0.19444, 0.69224, 0, 0],
	        "8644": [0.1808, 0.675, 0, 0],
	        "8646": [0.1808, 0.675, 0, 0],
	        "8647": [0.1808, 0.675, 0, 0],
	        "8648": [0.19444, 0.69224, 0, 0],
	        "8649": [0.1808, 0.675, 0, 0],
	        "8650": [0.19444, 0.69224, 0, 0],
	        "8651": [0.01354, 0.52239, 0, 0],
	        "8652": [0.01354, 0.52239, 0, 0],
	        "8653": [-0.13313, 0.36687, 0, 0],
	        "8654": [-0.13313, 0.36687, 0, 0],
	        "8655": [-0.13313, 0.36687, 0, 0],
	        "8666": [0.13667, 0.63667, 0, 0],
	        "8667": [0.13667, 0.63667, 0, 0],
	        "8669": [-0.13313, 0.37788, 0, 0],
	        "8672": [-0.064, 0.437, 0, 0],
	        "8674": [-0.064, 0.437, 0, 0],
	        "8705": [0, 0.825, 0, 0],
	        "8708": [0, 0.68889, 0, 0],
	        "8709": [0.08167, 0.58167, 0, 0],
	        "8717": [0, 0.43056, 0, 0],
	        "8722": [-0.03598, 0.46402, 0, 0],
	        "8724": [0.08198, 0.69224, 0, 0],
	        "8726": [0.08167, 0.58167, 0, 0],
	        "8733": [0, 0.69224, 0, 0],
	        "8736": [0, 0.69224, 0, 0],
	        "8737": [0, 0.69224, 0, 0],
	        "8738": [0.03517, 0.52239, 0, 0],
	        "8739": [0.08167, 0.58167, 0, 0],
	        "8740": [0.25142, 0.74111, 0, 0],
	        "8741": [0.08167, 0.58167, 0, 0],
	        "8742": [0.25142, 0.74111, 0, 0],
	        "8756": [0, 0.69224, 0, 0],
	        "8757": [0, 0.69224, 0, 0],
	        "8764": [-0.13313, 0.36687, 0, 0],
	        "8765": [-0.13313, 0.37788, 0, 0],
	        "8769": [-0.13313, 0.36687, 0, 0],
	        "8770": [-0.03625, 0.46375, 0, 0],
	        "8774": [0.30274, 0.79383, 0, 0],
	        "8776": [-0.01688, 0.48312, 0, 0],
	        "8778": [0.08167, 0.58167, 0, 0],
	        "8782": [0.06062, 0.54986, 0, 0],
	        "8783": [0.06062, 0.54986, 0, 0],
	        "8785": [0.08198, 0.58198, 0, 0],
	        "8786": [0.08198, 0.58198, 0, 0],
	        "8787": [0.08198, 0.58198, 0, 0],
	        "8790": [0, 0.69224, 0, 0],
	        "8791": [0.22958, 0.72958, 0, 0],
	        "8796": [0.08198, 0.91667, 0, 0],
	        "8806": [0.25583, 0.75583, 0, 0],
	        "8807": [0.25583, 0.75583, 0, 0],
	        "8808": [0.25142, 0.75726, 0, 0],
	        "8809": [0.25142, 0.75726, 0, 0],
	        "8812": [0.25583, 0.75583, 0, 0],
	        "8814": [0.20576, 0.70576, 0, 0],
	        "8815": [0.20576, 0.70576, 0, 0],
	        "8816": [0.30274, 0.79383, 0, 0],
	        "8817": [0.30274, 0.79383, 0, 0],
	        "8818": [0.22958, 0.72958, 0, 0],
	        "8819": [0.22958, 0.72958, 0, 0],
	        "8822": [0.1808, 0.675, 0, 0],
	        "8823": [0.1808, 0.675, 0, 0],
	        "8828": [0.13667, 0.63667, 0, 0],
	        "8829": [0.13667, 0.63667, 0, 0],
	        "8830": [0.22958, 0.72958, 0, 0],
	        "8831": [0.22958, 0.72958, 0, 0],
	        "8832": [0.20576, 0.70576, 0, 0],
	        "8833": [0.20576, 0.70576, 0, 0],
	        "8840": [0.30274, 0.79383, 0, 0],
	        "8841": [0.30274, 0.79383, 0, 0],
	        "8842": [0.13597, 0.63597, 0, 0],
	        "8843": [0.13597, 0.63597, 0, 0],
	        "8847": [0.03517, 0.54986, 0, 0],
	        "8848": [0.03517, 0.54986, 0, 0],
	        "8858": [0.08198, 0.58198, 0, 0],
	        "8859": [0.08198, 0.58198, 0, 0],
	        "8861": [0.08198, 0.58198, 0, 0],
	        "8862": [0, 0.675, 0, 0],
	        "8863": [0, 0.675, 0, 0],
	        "8864": [0, 0.675, 0, 0],
	        "8865": [0, 0.675, 0, 0],
	        "8872": [0, 0.69224, 0, 0],
	        "8873": [0, 0.69224, 0, 0],
	        "8874": [0, 0.69224, 0, 0],
	        "8876": [0, 0.68889, 0, 0],
	        "8877": [0, 0.68889, 0, 0],
	        "8878": [0, 0.68889, 0, 0],
	        "8879": [0, 0.68889, 0, 0],
	        "8882": [0.03517, 0.54986, 0, 0],
	        "8883": [0.03517, 0.54986, 0, 0],
	        "8884": [0.13667, 0.63667, 0, 0],
	        "8885": [0.13667, 0.63667, 0, 0],
	        "8888": [0, 0.54986, 0, 0],
	        "8890": [0.19444, 0.43056, 0, 0],
	        "8891": [0.19444, 0.69224, 0, 0],
	        "8892": [0.19444, 0.69224, 0, 0],
	        "8901": [0, 0.54986, 0, 0],
	        "8903": [0.08167, 0.58167, 0, 0],
	        "8905": [0.08167, 0.58167, 0, 0],
	        "8906": [0.08167, 0.58167, 0, 0],
	        "8907": [0, 0.69224, 0, 0],
	        "8908": [0, 0.69224, 0, 0],
	        "8909": [-0.03598, 0.46402, 0, 0],
	        "8910": [0, 0.54986, 0, 0],
	        "8911": [0, 0.54986, 0, 0],
	        "8912": [0.03517, 0.54986, 0, 0],
	        "8913": [0.03517, 0.54986, 0, 0],
	        "8914": [0, 0.54986, 0, 0],
	        "8915": [0, 0.54986, 0, 0],
	        "8916": [0, 0.69224, 0, 0],
	        "8918": [0.0391, 0.5391, 0, 0],
	        "8919": [0.0391, 0.5391, 0, 0],
	        "8920": [0.03517, 0.54986, 0, 0],
	        "8921": [0.03517, 0.54986, 0, 0],
	        "8922": [0.38569, 0.88569, 0, 0],
	        "8923": [0.38569, 0.88569, 0, 0],
	        "8926": [0.13667, 0.63667, 0, 0],
	        "8927": [0.13667, 0.63667, 0, 0],
	        "8928": [0.30274, 0.79383, 0, 0],
	        "8929": [0.30274, 0.79383, 0, 0],
	        "8934": [0.23222, 0.74111, 0, 0],
	        "8935": [0.23222, 0.74111, 0, 0],
	        "8936": [0.23222, 0.74111, 0, 0],
	        "8937": [0.23222, 0.74111, 0, 0],
	        "8938": [0.20576, 0.70576, 0, 0],
	        "8939": [0.20576, 0.70576, 0, 0],
	        "8940": [0.30274, 0.79383, 0, 0],
	        "8941": [0.30274, 0.79383, 0, 0],
	        "8994": [0.19444, 0.69224, 0, 0],
	        "8995": [0.19444, 0.69224, 0, 0],
	        "9416": [0.15559, 0.69224, 0, 0],
	        "9484": [0, 0.69224, 0, 0],
	        "9488": [0, 0.69224, 0, 0],
	        "9492": [0, 0.37788, 0, 0],
	        "9496": [0, 0.37788, 0, 0],
	        "9585": [0.19444, 0.68889, 0, 0],
	        "9586": [0.19444, 0.74111, 0, 0],
	        "9632": [0, 0.675, 0, 0],
	        "9633": [0, 0.675, 0, 0],
	        "9650": [0, 0.54986, 0, 0],
	        "9651": [0, 0.54986, 0, 0],
	        "9654": [0.03517, 0.54986, 0, 0],
	        "9660": [0, 0.54986, 0, 0],
	        "9661": [0, 0.54986, 0, 0],
	        "9664": [0.03517, 0.54986, 0, 0],
	        "9674": [0.11111, 0.69224, 0, 0],
	        "9733": [0.19444, 0.69224, 0, 0],
	        "10003": [0, 0.69224, 0, 0],
	        "10016": [0, 0.69224, 0, 0],
	        "10731": [0.11111, 0.69224, 0, 0],
	        "10846": [0.19444, 0.75583, 0, 0],
	        "10877": [0.13667, 0.63667, 0, 0],
	        "10878": [0.13667, 0.63667, 0, 0],
	        "10885": [0.25583, 0.75583, 0, 0],
	        "10886": [0.25583, 0.75583, 0, 0],
	        "10887": [0.13597, 0.63597, 0, 0],
	        "10888": [0.13597, 0.63597, 0, 0],
	        "10889": [0.26167, 0.75726, 0, 0],
	        "10890": [0.26167, 0.75726, 0, 0],
	        "10891": [0.48256, 0.98256, 0, 0],
	        "10892": [0.48256, 0.98256, 0, 0],
	        "10901": [0.13667, 0.63667, 0, 0],
	        "10902": [0.13667, 0.63667, 0, 0],
	        "10933": [0.25142, 0.75726, 0, 0],
	        "10934": [0.25142, 0.75726, 0, 0],
	        "10935": [0.26167, 0.75726, 0, 0],
	        "10936": [0.26167, 0.75726, 0, 0],
	        "10937": [0.26167, 0.75726, 0, 0],
	        "10938": [0.26167, 0.75726, 0, 0],
	        "10949": [0.25583, 0.75583, 0, 0],
	        "10950": [0.25583, 0.75583, 0, 0],
	        "10955": [0.28481, 0.79383, 0, 0],
	        "10956": [0.28481, 0.79383, 0, 0],
	        "57350": [0.08167, 0.58167, 0, 0],
	        "57351": [0.08167, 0.58167, 0, 0],
	        "57352": [0.08167, 0.58167, 0, 0],
	        "57353": [0, 0.43056, 0.04028, 0],
	        "57356": [0.25142, 0.75726, 0, 0],
	        "57357": [0.25142, 0.75726, 0, 0],
	        "57358": [0.41951, 0.91951, 0, 0],
	        "57359": [0.30274, 0.79383, 0, 0],
	        "57360": [0.30274, 0.79383, 0, 0],
	        "57361": [0.41951, 0.91951, 0, 0],
	        "57366": [0.25142, 0.75726, 0, 0],
	        "57367": [0.25142, 0.75726, 0, 0],
	        "57368": [0.25142, 0.75726, 0, 0],
	        "57369": [0.25142, 0.75726, 0, 0],
	        "57370": [0.13597, 0.63597, 0, 0],
	        "57371": [0.13597, 0.63597, 0, 0]
	    },
	    "Caligraphic-Regular": {
	        "48": [0, 0.43056, 0, 0],
	        "49": [0, 0.43056, 0, 0],
	        "50": [0, 0.43056, 0, 0],
	        "51": [0.19444, 0.43056, 0, 0],
	        "52": [0.19444, 0.43056, 0, 0],
	        "53": [0.19444, 0.43056, 0, 0],
	        "54": [0, 0.64444, 0, 0],
	        "55": [0.19444, 0.43056, 0, 0],
	        "56": [0, 0.64444, 0, 0],
	        "57": [0.19444, 0.43056, 0, 0],
	        "65": [0, 0.68333, 0, 0.19445],
	        "66": [0, 0.68333, 0.03041, 0.13889],
	        "67": [0, 0.68333, 0.05834, 0.13889],
	        "68": [0, 0.68333, 0.02778, 0.08334],
	        "69": [0, 0.68333, 0.08944, 0.11111],
	        "70": [0, 0.68333, 0.09931, 0.11111],
	        "71": [0.09722, 0.68333, 0.0593, 0.11111],
	        "72": [0, 0.68333, 0.00965, 0.11111],
	        "73": [0, 0.68333, 0.07382, 0],
	        "74": [0.09722, 0.68333, 0.18472, 0.16667],
	        "75": [0, 0.68333, 0.01445, 0.05556],
	        "76": [0, 0.68333, 0, 0.13889],
	        "77": [0, 0.68333, 0, 0.13889],
	        "78": [0, 0.68333, 0.14736, 0.08334],
	        "79": [0, 0.68333, 0.02778, 0.11111],
	        "80": [0, 0.68333, 0.08222, 0.08334],
	        "81": [0.09722, 0.68333, 0, 0.11111],
	        "82": [0, 0.68333, 0, 0.08334],
	        "83": [0, 0.68333, 0.075, 0.13889],
	        "84": [0, 0.68333, 0.25417, 0],
	        "85": [0, 0.68333, 0.09931, 0.08334],
	        "86": [0, 0.68333, 0.08222, 0],
	        "87": [0, 0.68333, 0.08222, 0.08334],
	        "88": [0, 0.68333, 0.14643, 0.13889],
	        "89": [0.09722, 0.68333, 0.08222, 0.08334],
	        "90": [0, 0.68333, 0.07944, 0.13889]
	    },
	    "Fraktur-Regular": {
	        "33": [0, 0.69141, 0, 0],
	        "34": [0, 0.69141, 0, 0],
	        "38": [0, 0.69141, 0, 0],
	        "39": [0, 0.69141, 0, 0],
	        "40": [0.24982, 0.74947, 0, 0],
	        "41": [0.24982, 0.74947, 0, 0],
	        "42": [0, 0.62119, 0, 0],
	        "43": [0.08319, 0.58283, 0, 0],
	        "44": [0, 0.10803, 0, 0],
	        "45": [0.08319, 0.58283, 0, 0],
	        "46": [0, 0.10803, 0, 0],
	        "47": [0.24982, 0.74947, 0, 0],
	        "48": [0, 0.47534, 0, 0],
	        "49": [0, 0.47534, 0, 0],
	        "50": [0, 0.47534, 0, 0],
	        "51": [0.18906, 0.47534, 0, 0],
	        "52": [0.18906, 0.47534, 0, 0],
	        "53": [0.18906, 0.47534, 0, 0],
	        "54": [0, 0.69141, 0, 0],
	        "55": [0.18906, 0.47534, 0, 0],
	        "56": [0, 0.69141, 0, 0],
	        "57": [0.18906, 0.47534, 0, 0],
	        "58": [0, 0.47534, 0, 0],
	        "59": [0.12604, 0.47534, 0, 0],
	        "61": [-0.13099, 0.36866, 0, 0],
	        "63": [0, 0.69141, 0, 0],
	        "65": [0, 0.69141, 0, 0],
	        "66": [0, 0.69141, 0, 0],
	        "67": [0, 0.69141, 0, 0],
	        "68": [0, 0.69141, 0, 0],
	        "69": [0, 0.69141, 0, 0],
	        "70": [0.12604, 0.69141, 0, 0],
	        "71": [0, 0.69141, 0, 0],
	        "72": [0.06302, 0.69141, 0, 0],
	        "73": [0, 0.69141, 0, 0],
	        "74": [0.12604, 0.69141, 0, 0],
	        "75": [0, 0.69141, 0, 0],
	        "76": [0, 0.69141, 0, 0],
	        "77": [0, 0.69141, 0, 0],
	        "78": [0, 0.69141, 0, 0],
	        "79": [0, 0.69141, 0, 0],
	        "80": [0.18906, 0.69141, 0, 0],
	        "81": [0.03781, 0.69141, 0, 0],
	        "82": [0, 0.69141, 0, 0],
	        "83": [0, 0.69141, 0, 0],
	        "84": [0, 0.69141, 0, 0],
	        "85": [0, 0.69141, 0, 0],
	        "86": [0, 0.69141, 0, 0],
	        "87": [0, 0.69141, 0, 0],
	        "88": [0, 0.69141, 0, 0],
	        "89": [0.18906, 0.69141, 0, 0],
	        "90": [0.12604, 0.69141, 0, 0],
	        "91": [0.24982, 0.74947, 0, 0],
	        "93": [0.24982, 0.74947, 0, 0],
	        "94": [0, 0.69141, 0, 0],
	        "97": [0, 0.47534, 0, 0],
	        "98": [0, 0.69141, 0, 0],
	        "99": [0, 0.47534, 0, 0],
	        "100": [0, 0.62119, 0, 0],
	        "101": [0, 0.47534, 0, 0],
	        "102": [0.18906, 0.69141, 0, 0],
	        "103": [0.18906, 0.47534, 0, 0],
	        "104": [0.18906, 0.69141, 0, 0],
	        "105": [0, 0.69141, 0, 0],
	        "106": [0, 0.69141, 0, 0],
	        "107": [0, 0.69141, 0, 0],
	        "108": [0, 0.69141, 0, 0],
	        "109": [0, 0.47534, 0, 0],
	        "110": [0, 0.47534, 0, 0],
	        "111": [0, 0.47534, 0, 0],
	        "112": [0.18906, 0.52396, 0, 0],
	        "113": [0.18906, 0.47534, 0, 0],
	        "114": [0, 0.47534, 0, 0],
	        "115": [0, 0.47534, 0, 0],
	        "116": [0, 0.62119, 0, 0],
	        "117": [0, 0.47534, 0, 0],
	        "118": [0, 0.52396, 0, 0],
	        "119": [0, 0.52396, 0, 0],
	        "120": [0.18906, 0.47534, 0, 0],
	        "121": [0.18906, 0.47534, 0, 0],
	        "122": [0.18906, 0.47534, 0, 0],
	        "8216": [0, 0.69141, 0, 0],
	        "8217": [0, 0.69141, 0, 0],
	        "58112": [0, 0.62119, 0, 0],
	        "58113": [0, 0.62119, 0, 0],
	        "58114": [0.18906, 0.69141, 0, 0],
	        "58115": [0.18906, 0.69141, 0, 0],
	        "58116": [0.18906, 0.47534, 0, 0],
	        "58117": [0, 0.69141, 0, 0],
	        "58118": [0, 0.62119, 0, 0],
	        "58119": [0, 0.47534, 0, 0]
	    },
	    "Main-Bold": {
	        "33": [0, 0.69444, 0, 0],
	        "34": [0, 0.69444, 0, 0],
	        "35": [0.19444, 0.69444, 0, 0],
	        "36": [0.05556, 0.75, 0, 0],
	        "37": [0.05556, 0.75, 0, 0],
	        "38": [0, 0.69444, 0, 0],
	        "39": [0, 0.69444, 0, 0],
	        "40": [0.25, 0.75, 0, 0],
	        "41": [0.25, 0.75, 0, 0],
	        "42": [0, 0.75, 0, 0],
	        "43": [0.13333, 0.63333, 0, 0],
	        "44": [0.19444, 0.15556, 0, 0],
	        "45": [0, 0.44444, 0, 0],
	        "46": [0, 0.15556, 0, 0],
	        "47": [0.25, 0.75, 0, 0],
	        "48": [0, 0.64444, 0, 0],
	        "49": [0, 0.64444, 0, 0],
	        "50": [0, 0.64444, 0, 0],
	        "51": [0, 0.64444, 0, 0],
	        "52": [0, 0.64444, 0, 0],
	        "53": [0, 0.64444, 0, 0],
	        "54": [0, 0.64444, 0, 0],
	        "55": [0, 0.64444, 0, 0],
	        "56": [0, 0.64444, 0, 0],
	        "57": [0, 0.64444, 0, 0],
	        "58": [0, 0.44444, 0, 0],
	        "59": [0.19444, 0.44444, 0, 0],
	        "60": [0.08556, 0.58556, 0, 0],
	        "61": [-0.10889, 0.39111, 0, 0],
	        "62": [0.08556, 0.58556, 0, 0],
	        "63": [0, 0.69444, 0, 0],
	        "64": [0, 0.69444, 0, 0],
	        "65": [0, 0.68611, 0, 0],
	        "66": [0, 0.68611, 0, 0],
	        "67": [0, 0.68611, 0, 0],
	        "68": [0, 0.68611, 0, 0],
	        "69": [0, 0.68611, 0, 0],
	        "70": [0, 0.68611, 0, 0],
	        "71": [0, 0.68611, 0, 0],
	        "72": [0, 0.68611, 0, 0],
	        "73": [0, 0.68611, 0, 0],
	        "74": [0, 0.68611, 0, 0],
	        "75": [0, 0.68611, 0, 0],
	        "76": [0, 0.68611, 0, 0],
	        "77": [0, 0.68611, 0, 0],
	        "78": [0, 0.68611, 0, 0],
	        "79": [0, 0.68611, 0, 0],
	        "80": [0, 0.68611, 0, 0],
	        "81": [0.19444, 0.68611, 0, 0],
	        "82": [0, 0.68611, 0, 0],
	        "83": [0, 0.68611, 0, 0],
	        "84": [0, 0.68611, 0, 0],
	        "85": [0, 0.68611, 0, 0],
	        "86": [0, 0.68611, 0.01597, 0],
	        "87": [0, 0.68611, 0.01597, 0],
	        "88": [0, 0.68611, 0, 0],
	        "89": [0, 0.68611, 0.02875, 0],
	        "90": [0, 0.68611, 0, 0],
	        "91": [0.25, 0.75, 0, 0],
	        "92": [0.25, 0.75, 0, 0],
	        "93": [0.25, 0.75, 0, 0],
	        "94": [0, 0.69444, 0, 0],
	        "95": [0.31, 0.13444, 0.03194, 0],
	        "96": [0, 0.69444, 0, 0],
	        "97": [0, 0.44444, 0, 0],
	        "98": [0, 0.69444, 0, 0],
	        "99": [0, 0.44444, 0, 0],
	        "100": [0, 0.69444, 0, 0],
	        "101": [0, 0.44444, 0, 0],
	        "102": [0, 0.69444, 0.10903, 0],
	        "103": [0.19444, 0.44444, 0.01597, 0],
	        "104": [0, 0.69444, 0, 0],
	        "105": [0, 0.69444, 0, 0],
	        "106": [0.19444, 0.69444, 0, 0],
	        "107": [0, 0.69444, 0, 0],
	        "108": [0, 0.69444, 0, 0],
	        "109": [0, 0.44444, 0, 0],
	        "110": [0, 0.44444, 0, 0],
	        "111": [0, 0.44444, 0, 0],
	        "112": [0.19444, 0.44444, 0, 0],
	        "113": [0.19444, 0.44444, 0, 0],
	        "114": [0, 0.44444, 0, 0],
	        "115": [0, 0.44444, 0, 0],
	        "116": [0, 0.63492, 0, 0],
	        "117": [0, 0.44444, 0, 0],
	        "118": [0, 0.44444, 0.01597, 0],
	        "119": [0, 0.44444, 0.01597, 0],
	        "120": [0, 0.44444, 0, 0],
	        "121": [0.19444, 0.44444, 0.01597, 0],
	        "122": [0, 0.44444, 0, 0],
	        "123": [0.25, 0.75, 0, 0],
	        "124": [0.25, 0.75, 0, 0],
	        "125": [0.25, 0.75, 0, 0],
	        "126": [0.35, 0.34444, 0, 0],
	        "168": [0, 0.69444, 0, 0],
	        "172": [0, 0.44444, 0, 0],
	        "175": [0, 0.59611, 0, 0],
	        "176": [0, 0.69444, 0, 0],
	        "177": [0.13333, 0.63333, 0, 0],
	        "180": [0, 0.69444, 0, 0],
	        "215": [0.13333, 0.63333, 0, 0],
	        "247": [0.13333, 0.63333, 0, 0],
	        "305": [0, 0.44444, 0, 0],
	        "567": [0.19444, 0.44444, 0, 0],
	        "710": [0, 0.69444, 0, 0],
	        "711": [0, 0.63194, 0, 0],
	        "713": [0, 0.59611, 0, 0],
	        "714": [0, 0.69444, 0, 0],
	        "715": [0, 0.69444, 0, 0],
	        "728": [0, 0.69444, 0, 0],
	        "729": [0, 0.69444, 0, 0],
	        "730": [0, 0.69444, 0, 0],
	        "732": [0, 0.69444, 0, 0],
	        "768": [0, 0.69444, 0, 0],
	        "769": [0, 0.69444, 0, 0],
	        "770": [0, 0.69444, 0, 0],
	        "771": [0, 0.69444, 0, 0],
	        "772": [0, 0.59611, 0, 0],
	        "774": [0, 0.69444, 0, 0],
	        "775": [0, 0.69444, 0, 0],
	        "776": [0, 0.69444, 0, 0],
	        "778": [0, 0.69444, 0, 0],
	        "779": [0, 0.69444, 0, 0],
	        "780": [0, 0.63194, 0, 0],
	        "824": [0.19444, 0.69444, 0, 0],
	        "915": [0, 0.68611, 0, 0],
	        "916": [0, 0.68611, 0, 0],
	        "920": [0, 0.68611, 0, 0],
	        "923": [0, 0.68611, 0, 0],
	        "926": [0, 0.68611, 0, 0],
	        "928": [0, 0.68611, 0, 0],
	        "931": [0, 0.68611, 0, 0],
	        "933": [0, 0.68611, 0, 0],
	        "934": [0, 0.68611, 0, 0],
	        "936": [0, 0.68611, 0, 0],
	        "937": [0, 0.68611, 0, 0],
	        "8211": [0, 0.44444, 0.03194, 0],
	        "8212": [0, 0.44444, 0.03194, 0],
	        "8216": [0, 0.69444, 0, 0],
	        "8217": [0, 0.69444, 0, 0],
	        "8220": [0, 0.69444, 0, 0],
	        "8221": [0, 0.69444, 0, 0],
	        "8224": [0.19444, 0.69444, 0, 0],
	        "8225": [0.19444, 0.69444, 0, 0],
	        "8242": [0, 0.55556, 0, 0],
	        "8407": [0, 0.72444, 0.15486, 0],
	        "8463": [0, 0.69444, 0, 0],
	        "8465": [0, 0.69444, 0, 0],
	        "8467": [0, 0.69444, 0, 0],
	        "8472": [0.19444, 0.44444, 0, 0],
	        "8476": [0, 0.69444, 0, 0],
	        "8501": [0, 0.69444, 0, 0],
	        "8592": [-0.10889, 0.39111, 0, 0],
	        "8593": [0.19444, 0.69444, 0, 0],
	        "8594": [-0.10889, 0.39111, 0, 0],
	        "8595": [0.19444, 0.69444, 0, 0],
	        "8596": [-0.10889, 0.39111, 0, 0],
	        "8597": [0.25, 0.75, 0, 0],
	        "8598": [0.19444, 0.69444, 0, 0],
	        "8599": [0.19444, 0.69444, 0, 0],
	        "8600": [0.19444, 0.69444, 0, 0],
	        "8601": [0.19444, 0.69444, 0, 0],
	        "8636": [-0.10889, 0.39111, 0, 0],
	        "8637": [-0.10889, 0.39111, 0, 0],
	        "8640": [-0.10889, 0.39111, 0, 0],
	        "8641": [-0.10889, 0.39111, 0, 0],
	        "8656": [-0.10889, 0.39111, 0, 0],
	        "8657": [0.19444, 0.69444, 0, 0],
	        "8658": [-0.10889, 0.39111, 0, 0],
	        "8659": [0.19444, 0.69444, 0, 0],
	        "8660": [-0.10889, 0.39111, 0, 0],
	        "8661": [0.25, 0.75, 0, 0],
	        "8704": [0, 0.69444, 0, 0],
	        "8706": [0, 0.69444, 0.06389, 0],
	        "8707": [0, 0.69444, 0, 0],
	        "8709": [0.05556, 0.75, 0, 0],
	        "8711": [0, 0.68611, 0, 0],
	        "8712": [0.08556, 0.58556, 0, 0],
	        "8715": [0.08556, 0.58556, 0, 0],
	        "8722": [0.13333, 0.63333, 0, 0],
	        "8723": [0.13333, 0.63333, 0, 0],
	        "8725": [0.25, 0.75, 0, 0],
	        "8726": [0.25, 0.75, 0, 0],
	        "8727": [-0.02778, 0.47222, 0, 0],
	        "8728": [-0.02639, 0.47361, 0, 0],
	        "8729": [-0.02639, 0.47361, 0, 0],
	        "8730": [0.18, 0.82, 0, 0],
	        "8733": [0, 0.44444, 0, 0],
	        "8734": [0, 0.44444, 0, 0],
	        "8736": [0, 0.69224, 0, 0],
	        "8739": [0.25, 0.75, 0, 0],
	        "8741": [0.25, 0.75, 0, 0],
	        "8743": [0, 0.55556, 0, 0],
	        "8744": [0, 0.55556, 0, 0],
	        "8745": [0, 0.55556, 0, 0],
	        "8746": [0, 0.55556, 0, 0],
	        "8747": [0.19444, 0.69444, 0.12778, 0],
	        "8764": [-0.10889, 0.39111, 0, 0],
	        "8768": [0.19444, 0.69444, 0, 0],
	        "8771": [0.00222, 0.50222, 0, 0],
	        "8776": [0.02444, 0.52444, 0, 0],
	        "8781": [0.00222, 0.50222, 0, 0],
	        "8801": [0.00222, 0.50222, 0, 0],
	        "8804": [0.19667, 0.69667, 0, 0],
	        "8805": [0.19667, 0.69667, 0, 0],
	        "8810": [0.08556, 0.58556, 0, 0],
	        "8811": [0.08556, 0.58556, 0, 0],
	        "8826": [0.08556, 0.58556, 0, 0],
	        "8827": [0.08556, 0.58556, 0, 0],
	        "8834": [0.08556, 0.58556, 0, 0],
	        "8835": [0.08556, 0.58556, 0, 0],
	        "8838": [0.19667, 0.69667, 0, 0],
	        "8839": [0.19667, 0.69667, 0, 0],
	        "8846": [0, 0.55556, 0, 0],
	        "8849": [0.19667, 0.69667, 0, 0],
	        "8850": [0.19667, 0.69667, 0, 0],
	        "8851": [0, 0.55556, 0, 0],
	        "8852": [0, 0.55556, 0, 0],
	        "8853": [0.13333, 0.63333, 0, 0],
	        "8854": [0.13333, 0.63333, 0, 0],
	        "8855": [0.13333, 0.63333, 0, 0],
	        "8856": [0.13333, 0.63333, 0, 0],
	        "8857": [0.13333, 0.63333, 0, 0],
	        "8866": [0, 0.69444, 0, 0],
	        "8867": [0, 0.69444, 0, 0],
	        "8868": [0, 0.69444, 0, 0],
	        "8869": [0, 0.69444, 0, 0],
	        "8900": [-0.02639, 0.47361, 0, 0],
	        "8901": [-0.02639, 0.47361, 0, 0],
	        "8902": [-0.02778, 0.47222, 0, 0],
	        "8968": [0.25, 0.75, 0, 0],
	        "8969": [0.25, 0.75, 0, 0],
	        "8970": [0.25, 0.75, 0, 0],
	        "8971": [0.25, 0.75, 0, 0],
	        "8994": [-0.13889, 0.36111, 0, 0],
	        "8995": [-0.13889, 0.36111, 0, 0],
	        "9651": [0.19444, 0.69444, 0, 0],
	        "9657": [-0.02778, 0.47222, 0, 0],
	        "9661": [0.19444, 0.69444, 0, 0],
	        "9667": [-0.02778, 0.47222, 0, 0],
	        "9711": [0.19444, 0.69444, 0, 0],
	        "9824": [0.12963, 0.69444, 0, 0],
	        "9825": [0.12963, 0.69444, 0, 0],
	        "9826": [0.12963, 0.69444, 0, 0],
	        "9827": [0.12963, 0.69444, 0, 0],
	        "9837": [0, 0.75, 0, 0],
	        "9838": [0.19444, 0.69444, 0, 0],
	        "9839": [0.19444, 0.69444, 0, 0],
	        "10216": [0.25, 0.75, 0, 0],
	        "10217": [0.25, 0.75, 0, 0],
	        "10815": [0, 0.68611, 0, 0],
	        "10927": [0.19667, 0.69667, 0, 0],
	        "10928": [0.19667, 0.69667, 0, 0]
	    },
	    "Main-Italic": {
	        "33": [0, 0.69444, 0.12417, 0],
	        "34": [0, 0.69444, 0.06961, 0],
	        "35": [0.19444, 0.69444, 0.06616, 0],
	        "37": [0.05556, 0.75, 0.13639, 0],
	        "38": [0, 0.69444, 0.09694, 0],
	        "39": [0, 0.69444, 0.12417, 0],
	        "40": [0.25, 0.75, 0.16194, 0],
	        "41": [0.25, 0.75, 0.03694, 0],
	        "42": [0, 0.75, 0.14917, 0],
	        "43": [0.05667, 0.56167, 0.03694, 0],
	        "44": [0.19444, 0.10556, 0, 0],
	        "45": [0, 0.43056, 0.02826, 0],
	        "46": [0, 0.10556, 0, 0],
	        "47": [0.25, 0.75, 0.16194, 0],
	        "48": [0, 0.64444, 0.13556, 0],
	        "49": [0, 0.64444, 0.13556, 0],
	        "50": [0, 0.64444, 0.13556, 0],
	        "51": [0, 0.64444, 0.13556, 0],
	        "52": [0.19444, 0.64444, 0.13556, 0],
	        "53": [0, 0.64444, 0.13556, 0],
	        "54": [0, 0.64444, 0.13556, 0],
	        "55": [0.19444, 0.64444, 0.13556, 0],
	        "56": [0, 0.64444, 0.13556, 0],
	        "57": [0, 0.64444, 0.13556, 0],
	        "58": [0, 0.43056, 0.0582, 0],
	        "59": [0.19444, 0.43056, 0.0582, 0],
	        "61": [-0.13313, 0.36687, 0.06616, 0],
	        "63": [0, 0.69444, 0.1225, 0],
	        "64": [0, 0.69444, 0.09597, 0],
	        "65": [0, 0.68333, 0, 0],
	        "66": [0, 0.68333, 0.10257, 0],
	        "67": [0, 0.68333, 0.14528, 0],
	        "68": [0, 0.68333, 0.09403, 0],
	        "69": [0, 0.68333, 0.12028, 0],
	        "70": [0, 0.68333, 0.13305, 0],
	        "71": [0, 0.68333, 0.08722, 0],
	        "72": [0, 0.68333, 0.16389, 0],
	        "73": [0, 0.68333, 0.15806, 0],
	        "74": [0, 0.68333, 0.14028, 0],
	        "75": [0, 0.68333, 0.14528, 0],
	        "76": [0, 0.68333, 0, 0],
	        "77": [0, 0.68333, 0.16389, 0],
	        "78": [0, 0.68333, 0.16389, 0],
	        "79": [0, 0.68333, 0.09403, 0],
	        "80": [0, 0.68333, 0.10257, 0],
	        "81": [0.19444, 0.68333, 0.09403, 0],
	        "82": [0, 0.68333, 0.03868, 0],
	        "83": [0, 0.68333, 0.11972, 0],
	        "84": [0, 0.68333, 0.13305, 0],
	        "85": [0, 0.68333, 0.16389, 0],
	        "86": [0, 0.68333, 0.18361, 0],
	        "87": [0, 0.68333, 0.18361, 0],
	        "88": [0, 0.68333, 0.15806, 0],
	        "89": [0, 0.68333, 0.19383, 0],
	        "90": [0, 0.68333, 0.14528, 0],
	        "91": [0.25, 0.75, 0.1875, 0],
	        "93": [0.25, 0.75, 0.10528, 0],
	        "94": [0, 0.69444, 0.06646, 0],
	        "95": [0.31, 0.12056, 0.09208, 0],
	        "97": [0, 0.43056, 0.07671, 0],
	        "98": [0, 0.69444, 0.06312, 0],
	        "99": [0, 0.43056, 0.05653, 0],
	        "100": [0, 0.69444, 0.10333, 0],
	        "101": [0, 0.43056, 0.07514, 0],
	        "102": [0.19444, 0.69444, 0.21194, 0],
	        "103": [0.19444, 0.43056, 0.08847, 0],
	        "104": [0, 0.69444, 0.07671, 0],
	        "105": [0, 0.65536, 0.1019, 0],
	        "106": [0.19444, 0.65536, 0.14467, 0],
	        "107": [0, 0.69444, 0.10764, 0],
	        "108": [0, 0.69444, 0.10333, 0],
	        "109": [0, 0.43056, 0.07671, 0],
	        "110": [0, 0.43056, 0.07671, 0],
	        "111": [0, 0.43056, 0.06312, 0],
	        "112": [0.19444, 0.43056, 0.06312, 0],
	        "113": [0.19444, 0.43056, 0.08847, 0],
	        "114": [0, 0.43056, 0.10764, 0],
	        "115": [0, 0.43056, 0.08208, 0],
	        "116": [0, 0.61508, 0.09486, 0],
	        "117": [0, 0.43056, 0.07671, 0],
	        "118": [0, 0.43056, 0.10764, 0],
	        "119": [0, 0.43056, 0.10764, 0],
	        "120": [0, 0.43056, 0.12042, 0],
	        "121": [0.19444, 0.43056, 0.08847, 0],
	        "122": [0, 0.43056, 0.12292, 0],
	        "126": [0.35, 0.31786, 0.11585, 0],
	        "163": [0, 0.69444, 0, 0],
	        "305": [0, 0.43056, 0, 0.02778],
	        "567": [0.19444, 0.43056, 0, 0.08334],
	        "768": [0, 0.69444, 0, 0],
	        "769": [0, 0.69444, 0.09694, 0],
	        "770": [0, 0.69444, 0.06646, 0],
	        "771": [0, 0.66786, 0.11585, 0],
	        "772": [0, 0.56167, 0.10333, 0],
	        "774": [0, 0.69444, 0.10806, 0],
	        "775": [0, 0.66786, 0.11752, 0],
	        "776": [0, 0.66786, 0.10474, 0],
	        "778": [0, 0.69444, 0, 0],
	        "779": [0, 0.69444, 0.1225, 0],
	        "780": [0, 0.62847, 0.08295, 0],
	        "915": [0, 0.68333, 0.13305, 0],
	        "916": [0, 0.68333, 0, 0],
	        "920": [0, 0.68333, 0.09403, 0],
	        "923": [0, 0.68333, 0, 0],
	        "926": [0, 0.68333, 0.15294, 0],
	        "928": [0, 0.68333, 0.16389, 0],
	        "931": [0, 0.68333, 0.12028, 0],
	        "933": [0, 0.68333, 0.11111, 0],
	        "934": [0, 0.68333, 0.05986, 0],
	        "936": [0, 0.68333, 0.11111, 0],
	        "937": [0, 0.68333, 0.10257, 0],
	        "8211": [0, 0.43056, 0.09208, 0],
	        "8212": [0, 0.43056, 0.09208, 0],
	        "8216": [0, 0.69444, 0.12417, 0],
	        "8217": [0, 0.69444, 0.12417, 0],
	        "8220": [0, 0.69444, 0.1685, 0],
	        "8221": [0, 0.69444, 0.06961, 0],
	        "8463": [0, 0.68889, 0, 0]
	    },
	    "Main-Regular": {
	        "32": [0, 0, 0, 0],
	        "33": [0, 0.69444, 0, 0],
	        "34": [0, 0.69444, 0, 0],
	        "35": [0.19444, 0.69444, 0, 0],
	        "36": [0.05556, 0.75, 0, 0],
	        "37": [0.05556, 0.75, 0, 0],
	        "38": [0, 0.69444, 0, 0],
	        "39": [0, 0.69444, 0, 0],
	        "40": [0.25, 0.75, 0, 0],
	        "41": [0.25, 0.75, 0, 0],
	        "42": [0, 0.75, 0, 0],
	        "43": [0.08333, 0.58333, 0, 0],
	        "44": [0.19444, 0.10556, 0, 0],
	        "45": [0, 0.43056, 0, 0],
	        "46": [0, 0.10556, 0, 0],
	        "47": [0.25, 0.75, 0, 0],
	        "48": [0, 0.64444, 0, 0],
	        "49": [0, 0.64444, 0, 0],
	        "50": [0, 0.64444, 0, 0],
	        "51": [0, 0.64444, 0, 0],
	        "52": [0, 0.64444, 0, 0],
	        "53": [0, 0.64444, 0, 0],
	        "54": [0, 0.64444, 0, 0],
	        "55": [0, 0.64444, 0, 0],
	        "56": [0, 0.64444, 0, 0],
	        "57": [0, 0.64444, 0, 0],
	        "58": [0, 0.43056, 0, 0],
	        "59": [0.19444, 0.43056, 0, 0],
	        "60": [0.0391, 0.5391, 0, 0],
	        "61": [-0.13313, 0.36687, 0, 0],
	        "62": [0.0391, 0.5391, 0, 0],
	        "63": [0, 0.69444, 0, 0],
	        "64": [0, 0.69444, 0, 0],
	        "65": [0, 0.68333, 0, 0],
	        "66": [0, 0.68333, 0, 0],
	        "67": [0, 0.68333, 0, 0],
	        "68": [0, 0.68333, 0, 0],
	        "69": [0, 0.68333, 0, 0],
	        "70": [0, 0.68333, 0, 0],
	        "71": [0, 0.68333, 0, 0],
	        "72": [0, 0.68333, 0, 0],
	        "73": [0, 0.68333, 0, 0],
	        "74": [0, 0.68333, 0, 0],
	        "75": [0, 0.68333, 0, 0],
	        "76": [0, 0.68333, 0, 0],
	        "77": [0, 0.68333, 0, 0],
	        "78": [0, 0.68333, 0, 0],
	        "79": [0, 0.68333, 0, 0],
	        "80": [0, 0.68333, 0, 0],
	        "81": [0.19444, 0.68333, 0, 0],
	        "82": [0, 0.68333, 0, 0],
	        "83": [0, 0.68333, 0, 0],
	        "84": [0, 0.68333, 0, 0],
	        "85": [0, 0.68333, 0, 0],
	        "86": [0, 0.68333, 0.01389, 0],
	        "87": [0, 0.68333, 0.01389, 0],
	        "88": [0, 0.68333, 0, 0],
	        "89": [0, 0.68333, 0.025, 0],
	        "90": [0, 0.68333, 0, 0],
	        "91": [0.25, 0.75, 0, 0],
	        "92": [0.25, 0.75, 0, 0],
	        "93": [0.25, 0.75, 0, 0],
	        "94": [0, 0.69444, 0, 0],
	        "95": [0.31, 0.12056, 0.02778, 0],
	        "96": [0, 0.69444, 0, 0],
	        "97": [0, 0.43056, 0, 0],
	        "98": [0, 0.69444, 0, 0],
	        "99": [0, 0.43056, 0, 0],
	        "100": [0, 0.69444, 0, 0],
	        "101": [0, 0.43056, 0, 0],
	        "102": [0, 0.69444, 0.07778, 0],
	        "103": [0.19444, 0.43056, 0.01389, 0],
	        "104": [0, 0.69444, 0, 0],
	        "105": [0, 0.66786, 0, 0],
	        "106": [0.19444, 0.66786, 0, 0],
	        "107": [0, 0.69444, 0, 0],
	        "108": [0, 0.69444, 0, 0],
	        "109": [0, 0.43056, 0, 0],
	        "110": [0, 0.43056, 0, 0],
	        "111": [0, 0.43056, 0, 0],
	        "112": [0.19444, 0.43056, 0, 0],
	        "113": [0.19444, 0.43056, 0, 0],
	        "114": [0, 0.43056, 0, 0],
	        "115": [0, 0.43056, 0, 0],
	        "116": [0, 0.61508, 0, 0],
	        "117": [0, 0.43056, 0, 0],
	        "118": [0, 0.43056, 0.01389, 0],
	        "119": [0, 0.43056, 0.01389, 0],
	        "120": [0, 0.43056, 0, 0],
	        "121": [0.19444, 0.43056, 0.01389, 0],
	        "122": [0, 0.43056, 0, 0],
	        "123": [0.25, 0.75, 0, 0],
	        "124": [0.25, 0.75, 0, 0],
	        "125": [0.25, 0.75, 0, 0],
	        "126": [0.35, 0.31786, 0, 0],
	        "160": [0, 0, 0, 0],
	        "168": [0, 0.66786, 0, 0],
	        "172": [0, 0.43056, 0, 0],
	        "175": [0, 0.56778, 0, 0],
	        "176": [0, 0.69444, 0, 0],
	        "177": [0.08333, 0.58333, 0, 0],
	        "180": [0, 0.69444, 0, 0],
	        "215": [0.08333, 0.58333, 0, 0],
	        "247": [0.08333, 0.58333, 0, 0],
	        "305": [0, 0.43056, 0, 0],
	        "567": [0.19444, 0.43056, 0, 0],
	        "710": [0, 0.69444, 0, 0],
	        "711": [0, 0.62847, 0, 0],
	        "713": [0, 0.56778, 0, 0],
	        "714": [0, 0.69444, 0, 0],
	        "715": [0, 0.69444, 0, 0],
	        "728": [0, 0.69444, 0, 0],
	        "729": [0, 0.66786, 0, 0],
	        "730": [0, 0.69444, 0, 0],
	        "732": [0, 0.66786, 0, 0],
	        "768": [0, 0.69444, 0, 0],
	        "769": [0, 0.69444, 0, 0],
	        "770": [0, 0.69444, 0, 0],
	        "771": [0, 0.66786, 0, 0],
	        "772": [0, 0.56778, 0, 0],
	        "774": [0, 0.69444, 0, 0],
	        "775": [0, 0.66786, 0, 0],
	        "776": [0, 0.66786, 0, 0],
	        "778": [0, 0.69444, 0, 0],
	        "779": [0, 0.69444, 0, 0],
	        "780": [0, 0.62847, 0, 0],
	        "824": [0.19444, 0.69444, 0, 0],
	        "915": [0, 0.68333, 0, 0],
	        "916": [0, 0.68333, 0, 0],
	        "920": [0, 0.68333, 0, 0],
	        "923": [0, 0.68333, 0, 0],
	        "926": [0, 0.68333, 0, 0],
	        "928": [0, 0.68333, 0, 0],
	        "931": [0, 0.68333, 0, 0],
	        "933": [0, 0.68333, 0, 0],
	        "934": [0, 0.68333, 0, 0],
	        "936": [0, 0.68333, 0, 0],
	        "937": [0, 0.68333, 0, 0],
	        "8211": [0, 0.43056, 0.02778, 0],
	        "8212": [0, 0.43056, 0.02778, 0],
	        "8216": [0, 0.69444, 0, 0],
	        "8217": [0, 0.69444, 0, 0],
	        "8220": [0, 0.69444, 0, 0],
	        "8221": [0, 0.69444, 0, 0],
	        "8224": [0.19444, 0.69444, 0, 0],
	        "8225": [0.19444, 0.69444, 0, 0],
	        "8230": [0, 0.12, 0, 0],
	        "8242": [0, 0.55556, 0, 0],
	        "8407": [0, 0.71444, 0.15382, 0],
	        "8463": [0, 0.68889, 0, 0],
	        "8465": [0, 0.69444, 0, 0],
	        "8467": [0, 0.69444, 0, 0.11111],
	        "8472": [0.19444, 0.43056, 0, 0.11111],
	        "8476": [0, 0.69444, 0, 0],
	        "8501": [0, 0.69444, 0, 0],
	        "8592": [-0.13313, 0.36687, 0, 0],
	        "8593": [0.19444, 0.69444, 0, 0],
	        "8594": [-0.13313, 0.36687, 0, 0],
	        "8595": [0.19444, 0.69444, 0, 0],
	        "8596": [-0.13313, 0.36687, 0, 0],
	        "8597": [0.25, 0.75, 0, 0],
	        "8598": [0.19444, 0.69444, 0, 0],
	        "8599": [0.19444, 0.69444, 0, 0],
	        "8600": [0.19444, 0.69444, 0, 0],
	        "8601": [0.19444, 0.69444, 0, 0],
	        "8614": [0.011, 0.511, 0, 0],
	        "8617": [0.011, 0.511, 0, 0],
	        "8618": [0.011, 0.511, 0, 0],
	        "8636": [-0.13313, 0.36687, 0, 0],
	        "8637": [-0.13313, 0.36687, 0, 0],
	        "8640": [-0.13313, 0.36687, 0, 0],
	        "8641": [-0.13313, 0.36687, 0, 0],
	        "8652": [0.011, 0.671, 0, 0],
	        "8656": [-0.13313, 0.36687, 0, 0],
	        "8657": [0.19444, 0.69444, 0, 0],
	        "8658": [-0.13313, 0.36687, 0, 0],
	        "8659": [0.19444, 0.69444, 0, 0],
	        "8660": [-0.13313, 0.36687, 0, 0],
	        "8661": [0.25, 0.75, 0, 0],
	        "8704": [0, 0.69444, 0, 0],
	        "8706": [0, 0.69444, 0.05556, 0.08334],
	        "8707": [0, 0.69444, 0, 0],
	        "8709": [0.05556, 0.75, 0, 0],
	        "8711": [0, 0.68333, 0, 0],
	        "8712": [0.0391, 0.5391, 0, 0],
	        "8715": [0.0391, 0.5391, 0, 0],
	        "8722": [0.08333, 0.58333, 0, 0],
	        "8723": [0.08333, 0.58333, 0, 0],
	        "8725": [0.25, 0.75, 0, 0],
	        "8726": [0.25, 0.75, 0, 0],
	        "8727": [-0.03472, 0.46528, 0, 0],
	        "8728": [-0.05555, 0.44445, 0, 0],
	        "8729": [-0.05555, 0.44445, 0, 0],
	        "8730": [0.2, 0.8, 0, 0],
	        "8733": [0, 0.43056, 0, 0],
	        "8734": [0, 0.43056, 0, 0],
	        "8736": [0, 0.69224, 0, 0],
	        "8739": [0.25, 0.75, 0, 0],
	        "8741": [0.25, 0.75, 0, 0],
	        "8743": [0, 0.55556, 0, 0],
	        "8744": [0, 0.55556, 0, 0],
	        "8745": [0, 0.55556, 0, 0],
	        "8746": [0, 0.55556, 0, 0],
	        "8747": [0.19444, 0.69444, 0.11111, 0],
	        "8764": [-0.13313, 0.36687, 0, 0],
	        "8768": [0.19444, 0.69444, 0, 0],
	        "8771": [-0.03625, 0.46375, 0, 0],
	        "8773": [-0.022, 0.589, 0, 0],
	        "8776": [-0.01688, 0.48312, 0, 0],
	        "8781": [-0.03625, 0.46375, 0, 0],
	        "8784": [-0.133, 0.67, 0, 0],
	        "8800": [0.215, 0.716, 0, 0],
	        "8801": [-0.03625, 0.46375, 0, 0],
	        "8804": [0.13597, 0.63597, 0, 0],
	        "8805": [0.13597, 0.63597, 0, 0],
	        "8810": [0.0391, 0.5391, 0, 0],
	        "8811": [0.0391, 0.5391, 0, 0],
	        "8826": [0.0391, 0.5391, 0, 0],
	        "8827": [0.0391, 0.5391, 0, 0],
	        "8834": [0.0391, 0.5391, 0, 0],
	        "8835": [0.0391, 0.5391, 0, 0],
	        "8838": [0.13597, 0.63597, 0, 0],
	        "8839": [0.13597, 0.63597, 0, 0],
	        "8846": [0, 0.55556, 0, 0],
	        "8849": [0.13597, 0.63597, 0, 0],
	        "8850": [0.13597, 0.63597, 0, 0],
	        "8851": [0, 0.55556, 0, 0],
	        "8852": [0, 0.55556, 0, 0],
	        "8853": [0.08333, 0.58333, 0, 0],
	        "8854": [0.08333, 0.58333, 0, 0],
	        "8855": [0.08333, 0.58333, 0, 0],
	        "8856": [0.08333, 0.58333, 0, 0],
	        "8857": [0.08333, 0.58333, 0, 0],
	        "8866": [0, 0.69444, 0, 0],
	        "8867": [0, 0.69444, 0, 0],
	        "8868": [0, 0.69444, 0, 0],
	        "8869": [0, 0.69444, 0, 0],
	        "8872": [0.249, 0.75, 0, 0],
	        "8900": [-0.05555, 0.44445, 0, 0],
	        "8901": [-0.05555, 0.44445, 0, 0],
	        "8902": [-0.03472, 0.46528, 0, 0],
	        "8904": [0.005, 0.505, 0, 0],
	        "8942": [0.03, 0.9, 0, 0],
	        "8943": [-0.19, 0.31, 0, 0],
	        "8945": [-0.1, 0.82, 0, 0],
	        "8968": [0.25, 0.75, 0, 0],
	        "8969": [0.25, 0.75, 0, 0],
	        "8970": [0.25, 0.75, 0, 0],
	        "8971": [0.25, 0.75, 0, 0],
	        "8994": [-0.14236, 0.35764, 0, 0],
	        "8995": [-0.14236, 0.35764, 0, 0],
	        "9136": [0.244, 0.744, 0, 0],
	        "9137": [0.244, 0.744, 0, 0],
	        "9651": [0.19444, 0.69444, 0, 0],
	        "9657": [-0.03472, 0.46528, 0, 0],
	        "9661": [0.19444, 0.69444, 0, 0],
	        "9667": [-0.03472, 0.46528, 0, 0],
	        "9711": [0.19444, 0.69444, 0, 0],
	        "9824": [0.12963, 0.69444, 0, 0],
	        "9825": [0.12963, 0.69444, 0, 0],
	        "9826": [0.12963, 0.69444, 0, 0],
	        "9827": [0.12963, 0.69444, 0, 0],
	        "9837": [0, 0.75, 0, 0],
	        "9838": [0.19444, 0.69444, 0, 0],
	        "9839": [0.19444, 0.69444, 0, 0],
	        "10216": [0.25, 0.75, 0, 0],
	        "10217": [0.25, 0.75, 0, 0],
	        "10222": [0.244, 0.744, 0, 0],
	        "10223": [0.244, 0.744, 0, 0],
	        "10229": [0.011, 0.511, 0, 0],
	        "10230": [0.011, 0.511, 0, 0],
	        "10231": [0.011, 0.511, 0, 0],
	        "10232": [0.024, 0.525, 0, 0],
	        "10233": [0.024, 0.525, 0, 0],
	        "10234": [0.024, 0.525, 0, 0],
	        "10236": [0.011, 0.511, 0, 0],
	        "10815": [0, 0.68333, 0, 0],
	        "10927": [0.13597, 0.63597, 0, 0],
	        "10928": [0.13597, 0.63597, 0, 0]
	    },
	    "Math-BoldItalic": {
	        "47": [0.19444, 0.69444, 0, 0],
	        "65": [0, 0.68611, 0, 0],
	        "66": [0, 0.68611, 0.04835, 0],
	        "67": [0, 0.68611, 0.06979, 0],
	        "68": [0, 0.68611, 0.03194, 0],
	        "69": [0, 0.68611, 0.05451, 0],
	        "70": [0, 0.68611, 0.15972, 0],
	        "71": [0, 0.68611, 0, 0],
	        "72": [0, 0.68611, 0.08229, 0],
	        "73": [0, 0.68611, 0.07778, 0],
	        "74": [0, 0.68611, 0.10069, 0],
	        "75": [0, 0.68611, 0.06979, 0],
	        "76": [0, 0.68611, 0, 0],
	        "77": [0, 0.68611, 0.11424, 0],
	        "78": [0, 0.68611, 0.11424, 0],
	        "79": [0, 0.68611, 0.03194, 0],
	        "80": [0, 0.68611, 0.15972, 0],
	        "81": [0.19444, 0.68611, 0, 0],
	        "82": [0, 0.68611, 0.00421, 0],
	        "83": [0, 0.68611, 0.05382, 0],
	        "84": [0, 0.68611, 0.15972, 0],
	        "85": [0, 0.68611, 0.11424, 0],
	        "86": [0, 0.68611, 0.25555, 0],
	        "87": [0, 0.68611, 0.15972, 0],
	        "88": [0, 0.68611, 0.07778, 0],
	        "89": [0, 0.68611, 0.25555, 0],
	        "90": [0, 0.68611, 0.06979, 0],
	        "97": [0, 0.44444, 0, 0],
	        "98": [0, 0.69444, 0, 0],
	        "99": [0, 0.44444, 0, 0],
	        "100": [0, 0.69444, 0, 0],
	        "101": [0, 0.44444, 0, 0],
	        "102": [0.19444, 0.69444, 0.11042, 0],
	        "103": [0.19444, 0.44444, 0.03704, 0],
	        "104": [0, 0.69444, 0, 0],
	        "105": [0, 0.69326, 0, 0],
	        "106": [0.19444, 0.69326, 0.0622, 0],
	        "107": [0, 0.69444, 0.01852, 0],
	        "108": [0, 0.69444, 0.0088, 0],
	        "109": [0, 0.44444, 0, 0],
	        "110": [0, 0.44444, 0, 0],
	        "111": [0, 0.44444, 0, 0],
	        "112": [0.19444, 0.44444, 0, 0],
	        "113": [0.19444, 0.44444, 0.03704, 0],
	        "114": [0, 0.44444, 0.03194, 0],
	        "115": [0, 0.44444, 0, 0],
	        "116": [0, 0.63492, 0, 0],
	        "117": [0, 0.44444, 0, 0],
	        "118": [0, 0.44444, 0.03704, 0],
	        "119": [0, 0.44444, 0.02778, 0],
	        "120": [0, 0.44444, 0, 0],
	        "121": [0.19444, 0.44444, 0.03704, 0],
	        "122": [0, 0.44444, 0.04213, 0],
	        "915": [0, 0.68611, 0.15972, 0],
	        "916": [0, 0.68611, 0, 0],
	        "920": [0, 0.68611, 0.03194, 0],
	        "923": [0, 0.68611, 0, 0],
	        "926": [0, 0.68611, 0.07458, 0],
	        "928": [0, 0.68611, 0.08229, 0],
	        "931": [0, 0.68611, 0.05451, 0],
	        "933": [0, 0.68611, 0.15972, 0],
	        "934": [0, 0.68611, 0, 0],
	        "936": [0, 0.68611, 0.11653, 0],
	        "937": [0, 0.68611, 0.04835, 0],
	        "945": [0, 0.44444, 0, 0],
	        "946": [0.19444, 0.69444, 0.03403, 0],
	        "947": [0.19444, 0.44444, 0.06389, 0],
	        "948": [0, 0.69444, 0.03819, 0],
	        "949": [0, 0.44444, 0, 0],
	        "950": [0.19444, 0.69444, 0.06215, 0],
	        "951": [0.19444, 0.44444, 0.03704, 0],
	        "952": [0, 0.69444, 0.03194, 0],
	        "953": [0, 0.44444, 0, 0],
	        "954": [0, 0.44444, 0, 0],
	        "955": [0, 0.69444, 0, 0],
	        "956": [0.19444, 0.44444, 0, 0],
	        "957": [0, 0.44444, 0.06898, 0],
	        "958": [0.19444, 0.69444, 0.03021, 0],
	        "959": [0, 0.44444, 0, 0],
	        "960": [0, 0.44444, 0.03704, 0],
	        "961": [0.19444, 0.44444, 0, 0],
	        "962": [0.09722, 0.44444, 0.07917, 0],
	        "963": [0, 0.44444, 0.03704, 0],
	        "964": [0, 0.44444, 0.13472, 0],
	        "965": [0, 0.44444, 0.03704, 0],
	        "966": [0.19444, 0.44444, 0, 0],
	        "967": [0.19444, 0.44444, 0, 0],
	        "968": [0.19444, 0.69444, 0.03704, 0],
	        "969": [0, 0.44444, 0.03704, 0],
	        "977": [0, 0.69444, 0, 0],
	        "981": [0.19444, 0.69444, 0, 0],
	        "982": [0, 0.44444, 0.03194, 0],
	        "1009": [0.19444, 0.44444, 0, 0],
	        "1013": [0, 0.44444, 0, 0]
	    },
	    "Math-Italic": {
	        "47": [0.19444, 0.69444, 0, 0],
	        "65": [0, 0.68333, 0, 0.13889],
	        "66": [0, 0.68333, 0.05017, 0.08334],
	        "67": [0, 0.68333, 0.07153, 0.08334],
	        "68": [0, 0.68333, 0.02778, 0.05556],
	        "69": [0, 0.68333, 0.05764, 0.08334],
	        "70": [0, 0.68333, 0.13889, 0.08334],
	        "71": [0, 0.68333, 0, 0.08334],
	        "72": [0, 0.68333, 0.08125, 0.05556],
	        "73": [0, 0.68333, 0.07847, 0.11111],
	        "74": [0, 0.68333, 0.09618, 0.16667],
	        "75": [0, 0.68333, 0.07153, 0.05556],
	        "76": [0, 0.68333, 0, 0.02778],
	        "77": [0, 0.68333, 0.10903, 0.08334],
	        "78": [0, 0.68333, 0.10903, 0.08334],
	        "79": [0, 0.68333, 0.02778, 0.08334],
	        "80": [0, 0.68333, 0.13889, 0.08334],
	        "81": [0.19444, 0.68333, 0, 0.08334],
	        "82": [0, 0.68333, 0.00773, 0.08334],
	        "83": [0, 0.68333, 0.05764, 0.08334],
	        "84": [0, 0.68333, 0.13889, 0.08334],
	        "85": [0, 0.68333, 0.10903, 0.02778],
	        "86": [0, 0.68333, 0.22222, 0],
	        "87": [0, 0.68333, 0.13889, 0],
	        "88": [0, 0.68333, 0.07847, 0.08334],
	        "89": [0, 0.68333, 0.22222, 0],
	        "90": [0, 0.68333, 0.07153, 0.08334],
	        "97": [0, 0.43056, 0, 0],
	        "98": [0, 0.69444, 0, 0],
	        "99": [0, 0.43056, 0, 0.05556],
	        "100": [0, 0.69444, 0, 0.16667],
	        "101": [0, 0.43056, 0, 0.05556],
	        "102": [0.19444, 0.69444, 0.10764, 0.16667],
	        "103": [0.19444, 0.43056, 0.03588, 0.02778],
	        "104": [0, 0.69444, 0, 0],
	        "105": [0, 0.65952, 0, 0],
	        "106": [0.19444, 0.65952, 0.05724, 0],
	        "107": [0, 0.69444, 0.03148, 0],
	        "108": [0, 0.69444, 0.01968, 0.08334],
	        "109": [0, 0.43056, 0, 0],
	        "110": [0, 0.43056, 0, 0],
	        "111": [0, 0.43056, 0, 0.05556],
	        "112": [0.19444, 0.43056, 0, 0.08334],
	        "113": [0.19444, 0.43056, 0.03588, 0.08334],
	        "114": [0, 0.43056, 0.02778, 0.05556],
	        "115": [0, 0.43056, 0, 0.05556],
	        "116": [0, 0.61508, 0, 0.08334],
	        "117": [0, 0.43056, 0, 0.02778],
	        "118": [0, 0.43056, 0.03588, 0.02778],
	        "119": [0, 0.43056, 0.02691, 0.08334],
	        "120": [0, 0.43056, 0, 0.02778],
	        "121": [0.19444, 0.43056, 0.03588, 0.05556],
	        "122": [0, 0.43056, 0.04398, 0.05556],
	        "915": [0, 0.68333, 0.13889, 0.08334],
	        "916": [0, 0.68333, 0, 0.16667],
	        "920": [0, 0.68333, 0.02778, 0.08334],
	        "923": [0, 0.68333, 0, 0.16667],
	        "926": [0, 0.68333, 0.07569, 0.08334],
	        "928": [0, 0.68333, 0.08125, 0.05556],
	        "931": [0, 0.68333, 0.05764, 0.08334],
	        "933": [0, 0.68333, 0.13889, 0.05556],
	        "934": [0, 0.68333, 0, 0.08334],
	        "936": [0, 0.68333, 0.11, 0.05556],
	        "937": [0, 0.68333, 0.05017, 0.08334],
	        "945": [0, 0.43056, 0.0037, 0.02778],
	        "946": [0.19444, 0.69444, 0.05278, 0.08334],
	        "947": [0.19444, 0.43056, 0.05556, 0],
	        "948": [0, 0.69444, 0.03785, 0.05556],
	        "949": [0, 0.43056, 0, 0.08334],
	        "950": [0.19444, 0.69444, 0.07378, 0.08334],
	        "951": [0.19444, 0.43056, 0.03588, 0.05556],
	        "952": [0, 0.69444, 0.02778, 0.08334],
	        "953": [0, 0.43056, 0, 0.05556],
	        "954": [0, 0.43056, 0, 0],
	        "955": [0, 0.69444, 0, 0],
	        "956": [0.19444, 0.43056, 0, 0.02778],
	        "957": [0, 0.43056, 0.06366, 0.02778],
	        "958": [0.19444, 0.69444, 0.04601, 0.11111],
	        "959": [0, 0.43056, 0, 0.05556],
	        "960": [0, 0.43056, 0.03588, 0],
	        "961": [0.19444, 0.43056, 0, 0.08334],
	        "962": [0.09722, 0.43056, 0.07986, 0.08334],
	        "963": [0, 0.43056, 0.03588, 0],
	        "964": [0, 0.43056, 0.1132, 0.02778],
	        "965": [0, 0.43056, 0.03588, 0.02778],
	        "966": [0.19444, 0.43056, 0, 0.08334],
	        "967": [0.19444, 0.43056, 0, 0.05556],
	        "968": [0.19444, 0.69444, 0.03588, 0.11111],
	        "969": [0, 0.43056, 0.03588, 0],
	        "977": [0, 0.69444, 0, 0.08334],
	        "981": [0.19444, 0.69444, 0, 0.08334],
	        "982": [0, 0.43056, 0.02778, 0],
	        "1009": [0.19444, 0.43056, 0, 0.08334],
	        "1013": [0, 0.43056, 0, 0.05556]
	    },
	    "Math-Regular": {
	        "65": [0, 0.68333, 0, 0.13889],
	        "66": [0, 0.68333, 0.05017, 0.08334],
	        "67": [0, 0.68333, 0.07153, 0.08334],
	        "68": [0, 0.68333, 0.02778, 0.05556],
	        "69": [0, 0.68333, 0.05764, 0.08334],
	        "70": [0, 0.68333, 0.13889, 0.08334],
	        "71": [0, 0.68333, 0, 0.08334],
	        "72": [0, 0.68333, 0.08125, 0.05556],
	        "73": [0, 0.68333, 0.07847, 0.11111],
	        "74": [0, 0.68333, 0.09618, 0.16667],
	        "75": [0, 0.68333, 0.07153, 0.05556],
	        "76": [0, 0.68333, 0, 0.02778],
	        "77": [0, 0.68333, 0.10903, 0.08334],
	        "78": [0, 0.68333, 0.10903, 0.08334],
	        "79": [0, 0.68333, 0.02778, 0.08334],
	        "80": [0, 0.68333, 0.13889, 0.08334],
	        "81": [0.19444, 0.68333, 0, 0.08334],
	        "82": [0, 0.68333, 0.00773, 0.08334],
	        "83": [0, 0.68333, 0.05764, 0.08334],
	        "84": [0, 0.68333, 0.13889, 0.08334],
	        "85": [0, 0.68333, 0.10903, 0.02778],
	        "86": [0, 0.68333, 0.22222, 0],
	        "87": [0, 0.68333, 0.13889, 0],
	        "88": [0, 0.68333, 0.07847, 0.08334],
	        "89": [0, 0.68333, 0.22222, 0],
	        "90": [0, 0.68333, 0.07153, 0.08334],
	        "97": [0, 0.43056, 0, 0],
	        "98": [0, 0.69444, 0, 0],
	        "99": [0, 0.43056, 0, 0.05556],
	        "100": [0, 0.69444, 0, 0.16667],
	        "101": [0, 0.43056, 0, 0.05556],
	        "102": [0.19444, 0.69444, 0.10764, 0.16667],
	        "103": [0.19444, 0.43056, 0.03588, 0.02778],
	        "104": [0, 0.69444, 0, 0],
	        "105": [0, 0.65952, 0, 0],
	        "106": [0.19444, 0.65952, 0.05724, 0],
	        "107": [0, 0.69444, 0.03148, 0],
	        "108": [0, 0.69444, 0.01968, 0.08334],
	        "109": [0, 0.43056, 0, 0],
	        "110": [0, 0.43056, 0, 0],
	        "111": [0, 0.43056, 0, 0.05556],
	        "112": [0.19444, 0.43056, 0, 0.08334],
	        "113": [0.19444, 0.43056, 0.03588, 0.08334],
	        "114": [0, 0.43056, 0.02778, 0.05556],
	        "115": [0, 0.43056, 0, 0.05556],
	        "116": [0, 0.61508, 0, 0.08334],
	        "117": [0, 0.43056, 0, 0.02778],
	        "118": [0, 0.43056, 0.03588, 0.02778],
	        "119": [0, 0.43056, 0.02691, 0.08334],
	        "120": [0, 0.43056, 0, 0.02778],
	        "121": [0.19444, 0.43056, 0.03588, 0.05556],
	        "122": [0, 0.43056, 0.04398, 0.05556],
	        "915": [0, 0.68333, 0.13889, 0.08334],
	        "916": [0, 0.68333, 0, 0.16667],
	        "920": [0, 0.68333, 0.02778, 0.08334],
	        "923": [0, 0.68333, 0, 0.16667],
	        "926": [0, 0.68333, 0.07569, 0.08334],
	        "928": [0, 0.68333, 0.08125, 0.05556],
	        "931": [0, 0.68333, 0.05764, 0.08334],
	        "933": [0, 0.68333, 0.13889, 0.05556],
	        "934": [0, 0.68333, 0, 0.08334],
	        "936": [0, 0.68333, 0.11, 0.05556],
	        "937": [0, 0.68333, 0.05017, 0.08334],
	        "945": [0, 0.43056, 0.0037, 0.02778],
	        "946": [0.19444, 0.69444, 0.05278, 0.08334],
	        "947": [0.19444, 0.43056, 0.05556, 0],
	        "948": [0, 0.69444, 0.03785, 0.05556],
	        "949": [0, 0.43056, 0, 0.08334],
	        "950": [0.19444, 0.69444, 0.07378, 0.08334],
	        "951": [0.19444, 0.43056, 0.03588, 0.05556],
	        "952": [0, 0.69444, 0.02778, 0.08334],
	        "953": [0, 0.43056, 0, 0.05556],
	        "954": [0, 0.43056, 0, 0],
	        "955": [0, 0.69444, 0, 0],
	        "956": [0.19444, 0.43056, 0, 0.02778],
	        "957": [0, 0.43056, 0.06366, 0.02778],
	        "958": [0.19444, 0.69444, 0.04601, 0.11111],
	        "959": [0, 0.43056, 0, 0.05556],
	        "960": [0, 0.43056, 0.03588, 0],
	        "961": [0.19444, 0.43056, 0, 0.08334],
	        "962": [0.09722, 0.43056, 0.07986, 0.08334],
	        "963": [0, 0.43056, 0.03588, 0],
	        "964": [0, 0.43056, 0.1132, 0.02778],
	        "965": [0, 0.43056, 0.03588, 0.02778],
	        "966": [0.19444, 0.43056, 0, 0.08334],
	        "967": [0.19444, 0.43056, 0, 0.05556],
	        "968": [0.19444, 0.69444, 0.03588, 0.11111],
	        "969": [0, 0.43056, 0.03588, 0],
	        "977": [0, 0.69444, 0, 0.08334],
	        "981": [0.19444, 0.69444, 0, 0.08334],
	        "982": [0, 0.43056, 0.02778, 0],
	        "1009": [0.19444, 0.43056, 0, 0.08334],
	        "1013": [0, 0.43056, 0, 0.05556]
	    },
	    "SansSerif-Regular": {
	        "33": [0, 0.69444, 0, 0],
	        "34": [0, 0.69444, 0, 0],
	        "35": [0.19444, 0.69444, 0, 0],
	        "36": [0.05556, 0.75, 0, 0],
	        "37": [0.05556, 0.75, 0, 0],
	        "38": [0, 0.69444, 0, 0],
	        "39": [0, 0.69444, 0, 0],
	        "40": [0.25, 0.75, 0, 0],
	        "41": [0.25, 0.75, 0, 0],
	        "42": [0, 0.75, 0, 0],
	        "43": [0.08333, 0.58333, 0, 0],
	        "44": [0.125, 0.08333, 0, 0],
	        "45": [0, 0.44444, 0, 0],
	        "46": [0, 0.08333, 0, 0],
	        "47": [0.25, 0.75, 0, 0],
	        "48": [0, 0.65556, 0, 0],
	        "49": [0, 0.65556, 0, 0],
	        "50": [0, 0.65556, 0, 0],
	        "51": [0, 0.65556, 0, 0],
	        "52": [0, 0.65556, 0, 0],
	        "53": [0, 0.65556, 0, 0],
	        "54": [0, 0.65556, 0, 0],
	        "55": [0, 0.65556, 0, 0],
	        "56": [0, 0.65556, 0, 0],
	        "57": [0, 0.65556, 0, 0],
	        "58": [0, 0.44444, 0, 0],
	        "59": [0.125, 0.44444, 0, 0],
	        "61": [-0.13, 0.37, 0, 0],
	        "63": [0, 0.69444, 0, 0],
	        "64": [0, 0.69444, 0, 0],
	        "65": [0, 0.69444, 0, 0],
	        "66": [0, 0.69444, 0, 0],
	        "67": [0, 0.69444, 0, 0],
	        "68": [0, 0.69444, 0, 0],
	        "69": [0, 0.69444, 0, 0],
	        "70": [0, 0.69444, 0, 0],
	        "71": [0, 0.69444, 0, 0],
	        "72": [0, 0.69444, 0, 0],
	        "73": [0, 0.69444, 0, 0],
	        "74": [0, 0.69444, 0, 0],
	        "75": [0, 0.69444, 0, 0],
	        "76": [0, 0.69444, 0, 0],
	        "77": [0, 0.69444, 0, 0],
	        "78": [0, 0.69444, 0, 0],
	        "79": [0, 0.69444, 0, 0],
	        "80": [0, 0.69444, 0, 0],
	        "81": [0.125, 0.69444, 0, 0],
	        "82": [0, 0.69444, 0, 0],
	        "83": [0, 0.69444, 0, 0],
	        "84": [0, 0.69444, 0, 0],
	        "85": [0, 0.69444, 0, 0],
	        "86": [0, 0.69444, 0.01389, 0],
	        "87": [0, 0.69444, 0.01389, 0],
	        "88": [0, 0.69444, 0, 0],
	        "89": [0, 0.69444, 0.025, 0],
	        "90": [0, 0.69444, 0, 0],
	        "91": [0.25, 0.75, 0, 0],
	        "93": [0.25, 0.75, 0, 0],
	        "94": [0, 0.69444, 0, 0],
	        "95": [0.35, 0.09444, 0.02778, 0],
	        "97": [0, 0.44444, 0, 0],
	        "98": [0, 0.69444, 0, 0],
	        "99": [0, 0.44444, 0, 0],
	        "100": [0, 0.69444, 0, 0],
	        "101": [0, 0.44444, 0, 0],
	        "102": [0, 0.69444, 0.06944, 0],
	        "103": [0.19444, 0.44444, 0.01389, 0],
	        "104": [0, 0.69444, 0, 0],
	        "105": [0, 0.67937, 0, 0],
	        "106": [0.19444, 0.67937, 0, 0],
	        "107": [0, 0.69444, 0, 0],
	        "108": [0, 0.69444, 0, 0],
	        "109": [0, 0.44444, 0, 0],
	        "110": [0, 0.44444, 0, 0],
	        "111": [0, 0.44444, 0, 0],
	        "112": [0.19444, 0.44444, 0, 0],
	        "113": [0.19444, 0.44444, 0, 0],
	        "114": [0, 0.44444, 0.01389, 0],
	        "115": [0, 0.44444, 0, 0],
	        "116": [0, 0.57143, 0, 0],
	        "117": [0, 0.44444, 0, 0],
	        "118": [0, 0.44444, 0.01389, 0],
	        "119": [0, 0.44444, 0.01389, 0],
	        "120": [0, 0.44444, 0, 0],
	        "121": [0.19444, 0.44444, 0.01389, 0],
	        "122": [0, 0.44444, 0, 0],
	        "126": [0.35, 0.32659, 0, 0],
	        "305": [0, 0.44444, 0, 0],
	        "567": [0.19444, 0.44444, 0, 0],
	        "768": [0, 0.69444, 0, 0],
	        "769": [0, 0.69444, 0, 0],
	        "770": [0, 0.69444, 0, 0],
	        "771": [0, 0.67659, 0, 0],
	        "772": [0, 0.60889, 0, 0],
	        "774": [0, 0.69444, 0, 0],
	        "775": [0, 0.67937, 0, 0],
	        "776": [0, 0.67937, 0, 0],
	        "778": [0, 0.69444, 0, 0],
	        "779": [0, 0.69444, 0, 0],
	        "780": [0, 0.63194, 0, 0],
	        "915": [0, 0.69444, 0, 0],
	        "916": [0, 0.69444, 0, 0],
	        "920": [0, 0.69444, 0, 0],
	        "923": [0, 0.69444, 0, 0],
	        "926": [0, 0.69444, 0, 0],
	        "928": [0, 0.69444, 0, 0],
	        "931": [0, 0.69444, 0, 0],
	        "933": [0, 0.69444, 0, 0],
	        "934": [0, 0.69444, 0, 0],
	        "936": [0, 0.69444, 0, 0],
	        "937": [0, 0.69444, 0, 0],
	        "8211": [0, 0.44444, 0.02778, 0],
	        "8212": [0, 0.44444, 0.02778, 0],
	        "8216": [0, 0.69444, 0, 0],
	        "8217": [0, 0.69444, 0, 0],
	        "8220": [0, 0.69444, 0, 0],
	        "8221": [0, 0.69444, 0, 0]
	    },
	    "Script-Regular": {
	        "65": [0, 0.7, 0.22925, 0],
	        "66": [0, 0.7, 0.04087, 0],
	        "67": [0, 0.7, 0.1689, 0],
	        "68": [0, 0.7, 0.09371, 0],
	        "69": [0, 0.7, 0.18583, 0],
	        "70": [0, 0.7, 0.13634, 0],
	        "71": [0, 0.7, 0.17322, 0],
	        "72": [0, 0.7, 0.29694, 0],
	        "73": [0, 0.7, 0.19189, 0],
	        "74": [0.27778, 0.7, 0.19189, 0],
	        "75": [0, 0.7, 0.31259, 0],
	        "76": [0, 0.7, 0.19189, 0],
	        "77": [0, 0.7, 0.15981, 0],
	        "78": [0, 0.7, 0.3525, 0],
	        "79": [0, 0.7, 0.08078, 0],
	        "80": [0, 0.7, 0.08078, 0],
	        "81": [0, 0.7, 0.03305, 0],
	        "82": [0, 0.7, 0.06259, 0],
	        "83": [0, 0.7, 0.19189, 0],
	        "84": [0, 0.7, 0.29087, 0],
	        "85": [0, 0.7, 0.25815, 0],
	        "86": [0, 0.7, 0.27523, 0],
	        "87": [0, 0.7, 0.27523, 0],
	        "88": [0, 0.7, 0.26006, 0],
	        "89": [0, 0.7, 0.2939, 0],
	        "90": [0, 0.7, 0.24037, 0]
	    },
	    "Size1-Regular": {
	        "40": [0.35001, 0.85, 0, 0],
	        "41": [0.35001, 0.85, 0, 0],
	        "47": [0.35001, 0.85, 0, 0],
	        "91": [0.35001, 0.85, 0, 0],
	        "92": [0.35001, 0.85, 0, 0],
	        "93": [0.35001, 0.85, 0, 0],
	        "123": [0.35001, 0.85, 0, 0],
	        "125": [0.35001, 0.85, 0, 0],
	        "710": [0, 0.72222, 0, 0],
	        "732": [0, 0.72222, 0, 0],
	        "770": [0, 0.72222, 0, 0],
	        "771": [0, 0.72222, 0, 0],
	        "8214": [-0.00099, 0.601, 0, 0],
	        "8593": [1e-05, 0.6, 0, 0],
	        "8595": [1e-05, 0.6, 0, 0],
	        "8657": [1e-05, 0.6, 0, 0],
	        "8659": [1e-05, 0.6, 0, 0],
	        "8719": [0.25001, 0.75, 0, 0],
	        "8720": [0.25001, 0.75, 0, 0],
	        "8721": [0.25001, 0.75, 0, 0],
	        "8730": [0.35001, 0.85, 0, 0],
	        "8739": [-0.00599, 0.606, 0, 0],
	        "8741": [-0.00599, 0.606, 0, 0],
	        "8747": [0.30612, 0.805, 0.19445, 0],
	        "8748": [0.306, 0.805, 0.19445, 0],
	        "8749": [0.306, 0.805, 0.19445, 0],
	        "8750": [0.30612, 0.805, 0.19445, 0],
	        "8896": [0.25001, 0.75, 0, 0],
	        "8897": [0.25001, 0.75, 0, 0],
	        "8898": [0.25001, 0.75, 0, 0],
	        "8899": [0.25001, 0.75, 0, 0],
	        "8968": [0.35001, 0.85, 0, 0],
	        "8969": [0.35001, 0.85, 0, 0],
	        "8970": [0.35001, 0.85, 0, 0],
	        "8971": [0.35001, 0.85, 0, 0],
	        "9168": [-0.00099, 0.601, 0, 0],
	        "10216": [0.35001, 0.85, 0, 0],
	        "10217": [0.35001, 0.85, 0, 0],
	        "10752": [0.25001, 0.75, 0, 0],
	        "10753": [0.25001, 0.75, 0, 0],
	        "10754": [0.25001, 0.75, 0, 0],
	        "10756": [0.25001, 0.75, 0, 0],
	        "10758": [0.25001, 0.75, 0, 0]
	    },
	    "Size2-Regular": {
	        "40": [0.65002, 1.15, 0, 0],
	        "41": [0.65002, 1.15, 0, 0],
	        "47": [0.65002, 1.15, 0, 0],
	        "91": [0.65002, 1.15, 0, 0],
	        "92": [0.65002, 1.15, 0, 0],
	        "93": [0.65002, 1.15, 0, 0],
	        "123": [0.65002, 1.15, 0, 0],
	        "125": [0.65002, 1.15, 0, 0],
	        "710": [0, 0.75, 0, 0],
	        "732": [0, 0.75, 0, 0],
	        "770": [0, 0.75, 0, 0],
	        "771": [0, 0.75, 0, 0],
	        "8719": [0.55001, 1.05, 0, 0],
	        "8720": [0.55001, 1.05, 0, 0],
	        "8721": [0.55001, 1.05, 0, 0],
	        "8730": [0.65002, 1.15, 0, 0],
	        "8747": [0.86225, 1.36, 0.44445, 0],
	        "8748": [0.862, 1.36, 0.44445, 0],
	        "8749": [0.862, 1.36, 0.44445, 0],
	        "8750": [0.86225, 1.36, 0.44445, 0],
	        "8896": [0.55001, 1.05, 0, 0],
	        "8897": [0.55001, 1.05, 0, 0],
	        "8898": [0.55001, 1.05, 0, 0],
	        "8899": [0.55001, 1.05, 0, 0],
	        "8968": [0.65002, 1.15, 0, 0],
	        "8969": [0.65002, 1.15, 0, 0],
	        "8970": [0.65002, 1.15, 0, 0],
	        "8971": [0.65002, 1.15, 0, 0],
	        "10216": [0.65002, 1.15, 0, 0],
	        "10217": [0.65002, 1.15, 0, 0],
	        "10752": [0.55001, 1.05, 0, 0],
	        "10753": [0.55001, 1.05, 0, 0],
	        "10754": [0.55001, 1.05, 0, 0],
	        "10756": [0.55001, 1.05, 0, 0],
	        "10758": [0.55001, 1.05, 0, 0]
	    },
	    "Size3-Regular": {
	        "40": [0.95003, 1.45, 0, 0],
	        "41": [0.95003, 1.45, 0, 0],
	        "47": [0.95003, 1.45, 0, 0],
	        "91": [0.95003, 1.45, 0, 0],
	        "92": [0.95003, 1.45, 0, 0],
	        "93": [0.95003, 1.45, 0, 0],
	        "123": [0.95003, 1.45, 0, 0],
	        "125": [0.95003, 1.45, 0, 0],
	        "710": [0, 0.75, 0, 0],
	        "732": [0, 0.75, 0, 0],
	        "770": [0, 0.75, 0, 0],
	        "771": [0, 0.75, 0, 0],
	        "8730": [0.95003, 1.45, 0, 0],
	        "8968": [0.95003, 1.45, 0, 0],
	        "8969": [0.95003, 1.45, 0, 0],
	        "8970": [0.95003, 1.45, 0, 0],
	        "8971": [0.95003, 1.45, 0, 0],
	        "10216": [0.95003, 1.45, 0, 0],
	        "10217": [0.95003, 1.45, 0, 0]
	    },
	    "Size4-Regular": {
	        "40": [1.25003, 1.75, 0, 0],
	        "41": [1.25003, 1.75, 0, 0],
	        "47": [1.25003, 1.75, 0, 0],
	        "91": [1.25003, 1.75, 0, 0],
	        "92": [1.25003, 1.75, 0, 0],
	        "93": [1.25003, 1.75, 0, 0],
	        "123": [1.25003, 1.75, 0, 0],
	        "125": [1.25003, 1.75, 0, 0],
	        "710": [0, 0.825, 0, 0],
	        "732": [0, 0.825, 0, 0],
	        "770": [0, 0.825, 0, 0],
	        "771": [0, 0.825, 0, 0],
	        "8730": [1.25003, 1.75, 0, 0],
	        "8968": [1.25003, 1.75, 0, 0],
	        "8969": [1.25003, 1.75, 0, 0],
	        "8970": [1.25003, 1.75, 0, 0],
	        "8971": [1.25003, 1.75, 0, 0],
	        "9115": [0.64502, 1.155, 0, 0],
	        "9116": [1e-05, 0.6, 0, 0],
	        "9117": [0.64502, 1.155, 0, 0],
	        "9118": [0.64502, 1.155, 0, 0],
	        "9119": [1e-05, 0.6, 0, 0],
	        "9120": [0.64502, 1.155, 0, 0],
	        "9121": [0.64502, 1.155, 0, 0],
	        "9122": [-0.00099, 0.601, 0, 0],
	        "9123": [0.64502, 1.155, 0, 0],
	        "9124": [0.64502, 1.155, 0, 0],
	        "9125": [-0.00099, 0.601, 0, 0],
	        "9126": [0.64502, 1.155, 0, 0],
	        "9127": [1e-05, 0.9, 0, 0],
	        "9128": [0.65002, 1.15, 0, 0],
	        "9129": [0.90001, 0, 0, 0],
	        "9130": [0, 0.3, 0, 0],
	        "9131": [1e-05, 0.9, 0, 0],
	        "9132": [0.65002, 1.15, 0, 0],
	        "9133": [0.90001, 0, 0, 0],
	        "9143": [0.88502, 0.915, 0, 0],
	        "10216": [1.25003, 1.75, 0, 0],
	        "10217": [1.25003, 1.75, 0, 0],
	        "57344": [-0.00499, 0.605, 0, 0],
	        "57345": [-0.00499, 0.605, 0, 0],
	        "57680": [0, 0.12, 0, 0],
	        "57681": [0, 0.12, 0, 0],
	        "57682": [0, 0.12, 0, 0],
	        "57683": [0, 0.12, 0, 0]
	    },
	    "Typewriter-Regular": {
	        "33": [0, 0.61111, 0, 0],
	        "34": [0, 0.61111, 0, 0],
	        "35": [0, 0.61111, 0, 0],
	        "36": [0.08333, 0.69444, 0, 0],
	        "37": [0.08333, 0.69444, 0, 0],
	        "38": [0, 0.61111, 0, 0],
	        "39": [0, 0.61111, 0, 0],
	        "40": [0.08333, 0.69444, 0, 0],
	        "41": [0.08333, 0.69444, 0, 0],
	        "42": [0, 0.52083, 0, 0],
	        "43": [-0.08056, 0.53055, 0, 0],
	        "44": [0.13889, 0.125, 0, 0],
	        "45": [-0.08056, 0.53055, 0, 0],
	        "46": [0, 0.125, 0, 0],
	        "47": [0.08333, 0.69444, 0, 0],
	        "48": [0, 0.61111, 0, 0],
	        "49": [0, 0.61111, 0, 0],
	        "50": [0, 0.61111, 0, 0],
	        "51": [0, 0.61111, 0, 0],
	        "52": [0, 0.61111, 0, 0],
	        "53": [0, 0.61111, 0, 0],
	        "54": [0, 0.61111, 0, 0],
	        "55": [0, 0.61111, 0, 0],
	        "56": [0, 0.61111, 0, 0],
	        "57": [0, 0.61111, 0, 0],
	        "58": [0, 0.43056, 0, 0],
	        "59": [0.13889, 0.43056, 0, 0],
	        "60": [-0.05556, 0.55556, 0, 0],
	        "61": [-0.19549, 0.41562, 0, 0],
	        "62": [-0.05556, 0.55556, 0, 0],
	        "63": [0, 0.61111, 0, 0],
	        "64": [0, 0.61111, 0, 0],
	        "65": [0, 0.61111, 0, 0],
	        "66": [0, 0.61111, 0, 0],
	        "67": [0, 0.61111, 0, 0],
	        "68": [0, 0.61111, 0, 0],
	        "69": [0, 0.61111, 0, 0],
	        "70": [0, 0.61111, 0, 0],
	        "71": [0, 0.61111, 0, 0],
	        "72": [0, 0.61111, 0, 0],
	        "73": [0, 0.61111, 0, 0],
	        "74": [0, 0.61111, 0, 0],
	        "75": [0, 0.61111, 0, 0],
	        "76": [0, 0.61111, 0, 0],
	        "77": [0, 0.61111, 0, 0],
	        "78": [0, 0.61111, 0, 0],
	        "79": [0, 0.61111, 0, 0],
	        "80": [0, 0.61111, 0, 0],
	        "81": [0.13889, 0.61111, 0, 0],
	        "82": [0, 0.61111, 0, 0],
	        "83": [0, 0.61111, 0, 0],
	        "84": [0, 0.61111, 0, 0],
	        "85": [0, 0.61111, 0, 0],
	        "86": [0, 0.61111, 0, 0],
	        "87": [0, 0.61111, 0, 0],
	        "88": [0, 0.61111, 0, 0],
	        "89": [0, 0.61111, 0, 0],
	        "90": [0, 0.61111, 0, 0],
	        "91": [0.08333, 0.69444, 0, 0],
	        "92": [0.08333, 0.69444, 0, 0],
	        "93": [0.08333, 0.69444, 0, 0],
	        "94": [0, 0.61111, 0, 0],
	        "95": [0.09514, 0, 0, 0],
	        "96": [0, 0.61111, 0, 0],
	        "97": [0, 0.43056, 0, 0],
	        "98": [0, 0.61111, 0, 0],
	        "99": [0, 0.43056, 0, 0],
	        "100": [0, 0.61111, 0, 0],
	        "101": [0, 0.43056, 0, 0],
	        "102": [0, 0.61111, 0, 0],
	        "103": [0.22222, 0.43056, 0, 0],
	        "104": [0, 0.61111, 0, 0],
	        "105": [0, 0.61111, 0, 0],
	        "106": [0.22222, 0.61111, 0, 0],
	        "107": [0, 0.61111, 0, 0],
	        "108": [0, 0.61111, 0, 0],
	        "109": [0, 0.43056, 0, 0],
	        "110": [0, 0.43056, 0, 0],
	        "111": [0, 0.43056, 0, 0],
	        "112": [0.22222, 0.43056, 0, 0],
	        "113": [0.22222, 0.43056, 0, 0],
	        "114": [0, 0.43056, 0, 0],
	        "115": [0, 0.43056, 0, 0],
	        "116": [0, 0.55358, 0, 0],
	        "117": [0, 0.43056, 0, 0],
	        "118": [0, 0.43056, 0, 0],
	        "119": [0, 0.43056, 0, 0],
	        "120": [0, 0.43056, 0, 0],
	        "121": [0.22222, 0.43056, 0, 0],
	        "122": [0, 0.43056, 0, 0],
	        "123": [0.08333, 0.69444, 0, 0],
	        "124": [0.08333, 0.69444, 0, 0],
	        "125": [0.08333, 0.69444, 0, 0],
	        "126": [0, 0.61111, 0, 0],
	        "127": [0, 0.61111, 0, 0],
	        "305": [0, 0.43056, 0, 0],
	        "567": [0.22222, 0.43056, 0, 0],
	        "768": [0, 0.61111, 0, 0],
	        "769": [0, 0.61111, 0, 0],
	        "770": [0, 0.61111, 0, 0],
	        "771": [0, 0.61111, 0, 0],
	        "772": [0, 0.56555, 0, 0],
	        "774": [0, 0.61111, 0, 0],
	        "776": [0, 0.61111, 0, 0],
	        "778": [0, 0.61111, 0, 0],
	        "780": [0, 0.56597, 0, 0],
	        "915": [0, 0.61111, 0, 0],
	        "916": [0, 0.61111, 0, 0],
	        "920": [0, 0.61111, 0, 0],
	        "923": [0, 0.61111, 0, 0],
	        "926": [0, 0.61111, 0, 0],
	        "928": [0, 0.61111, 0, 0],
	        "931": [0, 0.61111, 0, 0],
	        "933": [0, 0.61111, 0, 0],
	        "934": [0, 0.61111, 0, 0],
	        "936": [0, 0.61111, 0, 0],
	        "937": [0, 0.61111, 0, 0],
	        "2018": [0, 0.61111, 0, 0],
	        "2019": [0, 0.61111, 0, 0],
	        "8242": [0, 0.61111, 0, 0]
	    }
	};


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-console:0 */
	/**
	 * This module contains general functions that can be used for building
	 * different kinds of domTree nodes in a consistent manner.
	 */
	
	var domTree = __webpack_require__(114);
	var fontMetrics = __webpack_require__(110);
	var symbols = __webpack_require__(116);
	var utils = __webpack_require__(115);
	
	var greekCapitals = [
	    "\\Gamma",
	    "\\Delta",
	    "\\Theta",
	    "\\Lambda",
	    "\\Xi",
	    "\\Pi",
	    "\\Sigma",
	    "\\Upsilon",
	    "\\Phi",
	    "\\Psi",
	    "\\Omega"
	];
	
	// The following have to be loaded from Main-Italic font, using class mainit
	var mainitLetters = [
	    "\u0131",   // dotless i, \imath
	    "\u0237",   // dotless j, \jmath
	    "\u00a3"   // \pounds
	];
	
	/**
	 * Makes a symbolNode after translation via the list of symbols in symbols.js.
	 * Correctly pulls out metrics for the character, and optionally takes a list of
	 * classes to be attached to the node.
	 *
	 * TODO: make argument order closer to makeSpan
	 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
	 * should if present come first in `classes`.
	 */
	var makeSymbol = function(value, fontFamily, mode, options, classes) {
	    // Replace the value with its replaced value from symbol.js
	    if (symbols[mode][value] && symbols[mode][value].replace) {
	        value = symbols[mode][value].replace;
	    }
	
	    var metrics = fontMetrics.getCharacterMetrics(value, fontFamily);
	
	    var symbolNode;
	    if (metrics) {
	        var italic = metrics.italic;
	        if (mode === "text") {
	            italic = 0;
	        }
	        symbolNode = new domTree.symbolNode(
	            value, metrics.height, metrics.depth, italic, metrics.skew,
	            classes);
	    } else {
	        // TODO(emily): Figure out a good way to only print this in development
	        typeof console !== "undefined" && console.warn(
	            "No character metrics for '" + value + "' in style '" +
	                fontFamily + "'");
	        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);
	    }
	
	    if (options) {
	        if (options.style.isTight()) {
	            symbolNode.classes.push("mtight");
	        }
	        if (options.getColor()) {
	            symbolNode.style.color = options.getColor();
	        }
	    }
	
	    return symbolNode;
	};
	
	/**
	 * Makes a symbol in Main-Regular or AMS-Regular.
	 * Used for rel, bin, open, close, inner, and punct.
	 */
	var mathsym = function(value, mode, options, classes) {
	    // Decide what font to render the symbol in by its entry in the symbols
	    // table.
	    // Have a special case for when the value = \ because the \ is used as a
	    // textord in unsupported command errors but cannot be parsed as a regular
	    // text ordinal and is therefore not present as a symbol in the symbols
	    // table for text
	    if (value === "\\" || symbols[mode][value].font === "main") {
	        return makeSymbol(value, "Main-Regular", mode, options, classes);
	    } else {
	        return makeSymbol(
	            value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
	    }
	};
	
	/**
	 * Makes a symbol in the default font for mathords and textords.
	 */
	var mathDefault = function(value, mode, options, classes, type) {
	    if (type === "mathord") {
	        return mathit(value, mode, options, classes);
	    } else if (type === "textord") {
	        return makeSymbol(
	            value, "Main-Regular", mode, options, classes.concat(["mathrm"]));
	    } else {
	        throw new Error("unexpected type: " + type + " in mathDefault");
	    }
	};
	
	/**
	 * Makes a symbol in the italic math font.
	 */
	var mathit = function(value, mode, options, classes) {
	    if (/[0-9]/.test(value.charAt(0)) ||
	            // glyphs for \imath and \jmath do not exist in Math-Italic so we
	            // need to use Main-Italic instead
	            utils.contains(mainitLetters, value) ||
	            utils.contains(greekCapitals, value)) {
	        return makeSymbol(
	            value, "Main-Italic", mode, options, classes.concat(["mainit"]));
	    } else {
	        return makeSymbol(
	            value, "Math-Italic", mode, options, classes.concat(["mathit"]));
	    }
	};
	
	/**
	 * Makes either a mathord or textord in the correct font and color.
	 */
	var makeOrd = function(group, options, type) {
	    var mode = group.mode;
	    var value = group.value;
	    if (symbols[mode][value] && symbols[mode][value].replace) {
	        value = symbols[mode][value].replace;
	    }
	
	    var classes = ["mord"];
	
	    var font = options.font;
	    if (font) {
	        if (font === "mathit" || utils.contains(mainitLetters, value)) {
	            return mathit(value, mode, options, classes);
	        } else {
	            var fontName = fontMap[font].fontName;
	            if (fontMetrics.getCharacterMetrics(value, fontName)) {
	                return makeSymbol(
	                    value, fontName, mode, options, classes.concat([font]));
	            } else {
	                return mathDefault(value, mode, options, classes, type);
	            }
	        }
	    } else {
	        return mathDefault(value, mode, options, classes, type);
	    }
	};
	
	/**
	 * Calculate the height, depth, and maxFontSize of an element based on its
	 * children.
	 */
	var sizeElementFromChildren = function(elem) {
	    var height = 0;
	    var depth = 0;
	    var maxFontSize = 0;
	
	    if (elem.children) {
	        for (var i = 0; i < elem.children.length; i++) {
	            if (elem.children[i].height > height) {
	                height = elem.children[i].height;
	            }
	            if (elem.children[i].depth > depth) {
	                depth = elem.children[i].depth;
	            }
	            if (elem.children[i].maxFontSize > maxFontSize) {
	                maxFontSize = elem.children[i].maxFontSize;
	            }
	        }
	    }
	
	    elem.height = height;
	    elem.depth = depth;
	    elem.maxFontSize = maxFontSize;
	};
	
	/**
	 * Makes a span with the given list of classes, list of children, and options.
	 *
	 * TODO: Ensure that `options` is always provided (currently some call sites
	 * don't pass it).
	 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
	 * should if present come first in `classes`.
	 */
	var makeSpan = function(classes, children, options) {
	    var span = new domTree.span(classes, children, options);
	
	    sizeElementFromChildren(span);
	
	    return span;
	};
	
	/**
	 * Prepends the given children to the given span, updating height, depth, and
	 * maxFontSize.
	 */
	var prependChildren = function(span, children) {
	    span.children = children.concat(span.children);
	
	    sizeElementFromChildren(span);
	};
	
	/**
	 * Makes a document fragment with the given list of children.
	 */
	var makeFragment = function(children) {
	    var fragment = new domTree.documentFragment(children);
	
	    sizeElementFromChildren(fragment);
	
	    return fragment;
	};
	
	/**
	 * Makes an element placed in each of the vlist elements to ensure that each
	 * element has the same max font size. To do this, we create a zero-width space
	 * with the correct font size.
	 */
	var makeFontSizer = function(options, fontSize) {
	    var fontSizeInner = makeSpan([], [new domTree.symbolNode("\u200b")]);
	    fontSizeInner.style.fontSize =
	        (fontSize / options.style.sizeMultiplier) + "em";
	
	    var fontSizer = makeSpan(
	        ["fontsize-ensurer", "reset-" + options.size, "size5"],
	        [fontSizeInner]);
	
	    return fontSizer;
	};
	
	/**
	 * Makes a vertical list by stacking elements and kerns on top of each other.
	 * Allows for many different ways of specifying the positioning method.
	 *
	 * Arguments:
	 *  - children: A list of child or kern nodes to be stacked on top of each other
	 *              (i.e. the first element will be at the bottom, and the last at
	 *              the top). Element nodes are specified as
	 *                {type: "elem", elem: node}
	 *              while kern nodes are specified as
	 *                {type: "kern", size: size}
	 *  - positionType: The method by which the vlist should be positioned. Valid
	 *                  values are:
	 *                   - "individualShift": The children list only contains elem
	 *                                        nodes, and each node contains an extra
	 *                                        "shift" value of how much it should be
	 *                                        shifted (note that shifting is always
	 *                                        moving downwards). positionData is
	 *                                        ignored.
	 *                   - "top": The positionData specifies the topmost point of
	 *                            the vlist (note this is expected to be a height,
	 *                            so positive values move up)
	 *                   - "bottom": The positionData specifies the bottommost point
	 *                               of the vlist (note this is expected to be a
	 *                               depth, so positive values move down
	 *                   - "shift": The vlist will be positioned such that its
	 *                              baseline is positionData away from the baseline
	 *                              of the first child. Positive values move
	 *                              downwards.
	 *                   - "firstBaseline": The vlist will be positioned such that
	 *                                      its baseline is aligned with the
	 *                                      baseline of the first child.
	 *                                      positionData is ignored. (this is
	 *                                      equivalent to "shift" with
	 *                                      positionData=0)
	 *  - positionData: Data used in different ways depending on positionType
	 *  - options: An Options object
	 *
	 */
	var makeVList = function(children, positionType, positionData, options) {
	    var depth;
	    var currPos;
	    var i;
	    if (positionType === "individualShift") {
	        var oldChildren = children;
	        children = [oldChildren[0]];
	
	        // Add in kerns to the list of children to get each element to be
	        // shifted to the correct specified shift
	        depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
	        currPos = depth;
	        for (i = 1; i < oldChildren.length; i++) {
	            var diff = -oldChildren[i].shift - currPos -
	                oldChildren[i].elem.depth;
	            var size = diff -
	                (oldChildren[i - 1].elem.height +
	                 oldChildren[i - 1].elem.depth);
	
	            currPos = currPos + diff;
	
	            children.push({type: "kern", size: size});
	            children.push(oldChildren[i]);
	        }
	    } else if (positionType === "top") {
	        // We always start at the bottom, so calculate the bottom by adding up
	        // all the sizes
	        var bottom = positionData;
	        for (i = 0; i < children.length; i++) {
	            if (children[i].type === "kern") {
	                bottom -= children[i].size;
	            } else {
	                bottom -= children[i].elem.height + children[i].elem.depth;
	            }
	        }
	        depth = bottom;
	    } else if (positionType === "bottom") {
	        depth = -positionData;
	    } else if (positionType === "shift") {
	        depth = -children[0].elem.depth - positionData;
	    } else if (positionType === "firstBaseline") {
	        depth = -children[0].elem.depth;
	    } else {
	        depth = 0;
	    }
	
	    // Make the fontSizer
	    var maxFontSize = 0;
	    for (i = 0; i < children.length; i++) {
	        if (children[i].type === "elem") {
	            maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);
	        }
	    }
	    var fontSizer = makeFontSizer(options, maxFontSize);
	
	    // Create a new list of actual children at the correct offsets
	    var realChildren = [];
	    currPos = depth;
	    for (i = 0; i < children.length; i++) {
	        if (children[i].type === "kern") {
	            currPos += children[i].size;
	        } else {
	            var child = children[i].elem;
	
	            var shift = -child.depth - currPos;
	            currPos += child.height + child.depth;
	
	            var childWrap = makeSpan([], [fontSizer, child]);
	            childWrap.height -= shift;
	            childWrap.depth += shift;
	            childWrap.style.top = shift + "em";
	
	            realChildren.push(childWrap);
	        }
	    }
	
	    // Add in an element at the end with no offset to fix the calculation of
	    // baselines in some browsers (namely IE, sometimes safari)
	    var baselineFix = makeSpan(
	        ["baseline-fix"], [fontSizer, new domTree.symbolNode("\u200b")]);
	    realChildren.push(baselineFix);
	
	    var vlist = makeSpan(["vlist"], realChildren);
	    // Fix the final height and depth, in case there were kerns at the ends
	    // since the makeSpan calculation won't take that in to account.
	    vlist.height = Math.max(currPos, vlist.height);
	    vlist.depth = Math.max(-depth, vlist.depth);
	    return vlist;
	};
	
	// A table of size -> font size for the different sizing functions
	var sizingMultiplier = {
	    size1: 0.5,
	    size2: 0.7,
	    size3: 0.8,
	    size4: 0.9,
	    size5: 1.0,
	    size6: 1.2,
	    size7: 1.44,
	    size8: 1.73,
	    size9: 2.07,
	    size10: 2.49
	};
	
	// A map of spacing functions to their attributes, like size and corresponding
	// CSS class
	var spacingFunctions = {
	    "\\qquad": {
	        size: "2em",
	        className: "qquad"
	    },
	    "\\quad": {
	        size: "1em",
	        className: "quad"
	    },
	    "\\enspace": {
	        size: "0.5em",
	        className: "enspace"
	    },
	    "\\;": {
	        size: "0.277778em",
	        className: "thickspace"
	    },
	    "\\:": {
	        size: "0.22222em",
	        className: "mediumspace"
	    },
	    "\\,": {
	        size: "0.16667em",
	        className: "thinspace"
	    },
	    "\\!": {
	        size: "-0.16667em",
	        className: "negativethinspace"
	    }
	};
	
	/**
	 * Maps TeX font commands to objects containing:
	 * - variant: string used for "mathvariant" attribute in buildMathML.js
	 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
	 */
	// A map between tex font commands an MathML mathvariant attribute values
	var fontMap = {
	    // styles
	    "mathbf": {
	        variant: "bold",
	        fontName: "Main-Bold"
	    },
	    "mathrm": {
	        variant: "normal",
	        fontName: "Main-Regular"
	    },
	    "textit": {
	        variant: "italic",
	        fontName: "Main-Italic"
	    },
	
	    // "mathit" is missing because it requires the use of two fonts: Main-Italic
	    // and Math-Italic.  This is handled by a special case in makeOrd which ends
	    // up calling mathit.
	
	    // families
	    "mathbb": {
	        variant: "double-struck",
	        fontName: "AMS-Regular"
	    },
	    "mathcal": {
	        variant: "script",
	        fontName: "Caligraphic-Regular"
	    },
	    "mathfrak": {
	        variant: "fraktur",
	        fontName: "Fraktur-Regular"
	    },
	    "mathscr": {
	        variant: "script",
	        fontName: "Script-Regular"
	    },
	    "mathsf": {
	        variant: "sans-serif",
	        fontName: "SansSerif-Regular"
	    },
	    "mathtt": {
	        variant: "monospace",
	        fontName: "Typewriter-Regular"
	    }
	};
	
	module.exports = {
	    fontMap: fontMap,
	    makeSymbol: makeSymbol,
	    mathsym: mathsym,
	    makeSpan: makeSpan,
	    makeFragment: makeFragment,
	    makeVList: makeVList,
	    makeOrd: makeOrd,
	    prependChildren: prependChildren,
	    sizingMultiplier: sizingMultiplier,
	    spacingFunctions: spacingFunctions
	};


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * These objects store the data about the DOM nodes we create, as well as some
	 * extra data. They can then be transformed into real DOM nodes with the
	 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
	 * storing extra properties on the nodes, as well as providing a way to easily
	 * work with the DOM.
	 *
	 * Similar functions for working with MathML nodes exist in mathMLTree.js.
	 */
	var unicodeRegexes = __webpack_require__(111);
	var utils = __webpack_require__(115);
	
	/**
	 * Create an HTML className based on a list of classes. In addition to joining
	 * with spaces, we also remove null or empty classes.
	 */
	var createClass = function(classes) {
	    classes = classes.slice();
	    for (var i = classes.length - 1; i >= 0; i--) {
	        if (!classes[i]) {
	            classes.splice(i, 1);
	        }
	    }
	
	    return classes.join(" ");
	};
	
	/**
	 * This node represents a span node, with a className, a list of children, and
	 * an inline style. It also contains information about its height, depth, and
	 * maxFontSize.
	 */
	function span(classes, children, options) {
	    this.classes = classes || [];
	    this.children = children || [];
	    this.height = 0;
	    this.depth = 0;
	    this.maxFontSize = 0;
	    this.style = {};
	    this.attributes = {};
	    if (options) {
	        if (options.style.isTight()) {
	            this.classes.push("mtight");
	        }
	        if (options.getColor()) {
	            this.style.color = options.getColor();
	        }
	    }
	}
	
	/**
	 * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all
	 * browsers support attributes the same, and having too many custom attributes
	 * is probably bad.
	 */
	span.prototype.setAttribute = function(attribute, value) {
	    this.attributes[attribute] = value;
	};
	
	span.prototype.tryCombine = function(sibling) {
	    return false;
	};
	
	/**
	 * Convert the span into an HTML node
	 */
	span.prototype.toNode = function() {
	    var span = document.createElement("span");
	
	    // Apply the class
	    span.className = createClass(this.classes);
	
	    // Apply inline styles
	    for (var style in this.style) {
	        if (Object.prototype.hasOwnProperty.call(this.style, style)) {
	            span.style[style] = this.style[style];
	        }
	    }
	
	    // Apply attributes
	    for (var attr in this.attributes) {
	        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
	            span.setAttribute(attr, this.attributes[attr]);
	        }
	    }
	
	    // Append the children, also as HTML nodes
	    for (var i = 0; i < this.children.length; i++) {
	        span.appendChild(this.children[i].toNode());
	    }
	
	    return span;
	};
	
	/**
	 * Convert the span into an HTML markup string
	 */
	span.prototype.toMarkup = function() {
	    var markup = "<span";
	
	    // Add the class
	    if (this.classes.length) {
	        markup += " class=\"";
	        markup += utils.escape(createClass(this.classes));
	        markup += "\"";
	    }
	
	    var styles = "";
	
	    // Add the styles, after hyphenation
	    for (var style in this.style) {
	        if (this.style.hasOwnProperty(style)) {
	            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
	        }
	    }
	
	    if (styles) {
	        markup += " style=\"" + utils.escape(styles) + "\"";
	    }
	
	    // Add the attributes
	    for (var attr in this.attributes) {
	        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
	            markup += " " + attr + "=\"";
	            markup += utils.escape(this.attributes[attr]);
	            markup += "\"";
	        }
	    }
	
	    markup += ">";
	
	    // Add the markup of the children, also as markup
	    for (var i = 0; i < this.children.length; i++) {
	        markup += this.children[i].toMarkup();
	    }
	
	    markup += "</span>";
	
	    return markup;
	};
	
	/**
	 * This node represents a document fragment, which contains elements, but when
	 * placed into the DOM doesn't have any representation itself. Thus, it only
	 * contains children and doesn't have any HTML properties. It also keeps track
	 * of a height, depth, and maxFontSize.
	 */
	function documentFragment(children) {
	    this.children = children || [];
	    this.height = 0;
	    this.depth = 0;
	    this.maxFontSize = 0;
	}
	
	/**
	 * Convert the fragment into a node
	 */
	documentFragment.prototype.toNode = function() {
	    // Create a fragment
	    var frag = document.createDocumentFragment();
	
	    // Append the children
	    for (var i = 0; i < this.children.length; i++) {
	        frag.appendChild(this.children[i].toNode());
	    }
	
	    return frag;
	};
	
	/**
	 * Convert the fragment into HTML markup
	 */
	documentFragment.prototype.toMarkup = function() {
	    var markup = "";
	
	    // Simply concatenate the markup for the children together
	    for (var i = 0; i < this.children.length; i++) {
	        markup += this.children[i].toMarkup();
	    }
	
	    return markup;
	};
	
	var iCombinations = {
	    '': '\u0131\u0302',
	    '': '\u0131\u0308',
	    '': '\u0131\u0301',
	    // '': '\u0131\u0304', // enable when we add Extended Latin
	    '': '\u0131\u0300'
	};
	
	/**
	 * A symbol node contains information about a single symbol. It either renders
	 * to a single text node, or a span with a single text node in it, depending on
	 * whether it has CSS classes, styles, or needs italic correction.
	 */
	function symbolNode(value, height, depth, italic, skew, classes, style) {
	    this.value = value || "";
	    this.height = height || 0;
	    this.depth = depth || 0;
	    this.italic = italic || 0;
	    this.skew = skew || 0;
	    this.classes = classes || [];
	    this.style = style || {};
	    this.maxFontSize = 0;
	
	    // Mark CJK characters with specific classes so that we can specify which
	    // fonts to use.  This allows us to render these characters with a serif
	    // font in situations where the browser would either default to a sans serif
	    // or render a placeholder character.
	    if (unicodeRegexes.cjkRegex.test(value)) {
	        // I couldn't find any fonts that contained Hangul as well as all of
	        // the other characters we wanted to test there for it gets its own
	        // CSS class.
	        if (unicodeRegexes.hangulRegex.test(value)) {
	            this.classes.push('hangul_fallback');
	        } else {
	            this.classes.push('cjk_fallback');
	        }
	    }
	
	    if (/[]/.test(this.value)) {    // add  when we add Extended Latin
	        this.value = iCombinations[this.value];
	    }
	}
	
	symbolNode.prototype.tryCombine = function(sibling) {
	    if (!sibling
	        || !(sibling instanceof symbolNode)
	        || this.italic > 0
	        || createClass(this.classes) !== createClass(sibling.classes)
	        || this.skew !== sibling.skew
	        || this.maxFontSize !== sibling.maxFontSize) {
	        return false;
	    }
	    for (var style in this.style) {
	        if (this.style.hasOwnProperty(style)
	            && this.style[style] !== sibling.style[style]) {
	            return false;
	        }
	    }
	    for (style in sibling.style) {
	        if (sibling.style.hasOwnProperty(style)
	            && this.style[style] !== sibling.style[style]) {
	            return false;
	        }
	    }
	    this.value += sibling.value;
	    this.height = Math.max(this.height, sibling.height);
	    this.depth = Math.max(this.depth, sibling.depth);
	    this.italic = sibling.italic;
	    return true;
	};
	
	/**
	 * Creates a text node or span from a symbol node. Note that a span is only
	 * created if it is needed.
	 */
	symbolNode.prototype.toNode = function() {
	    var node = document.createTextNode(this.value);
	    var span = null;
	
	    if (this.italic > 0) {
	        span = document.createElement("span");
	        span.style.marginRight = this.italic + "em";
	    }
	
	    if (this.classes.length > 0) {
	        span = span || document.createElement("span");
	        span.className = createClass(this.classes);
	    }
	
	    for (var style in this.style) {
	        if (this.style.hasOwnProperty(style)) {
	            span = span || document.createElement("span");
	            span.style[style] = this.style[style];
	        }
	    }
	
	    if (span) {
	        span.appendChild(node);
	        return span;
	    } else {
	        return node;
	    }
	};
	
	/**
	 * Creates markup for a symbol node.
	 */
	symbolNode.prototype.toMarkup = function() {
	    // TODO(alpert): More duplication than I'd like from
	    // span.prototype.toMarkup and symbolNode.prototype.toNode...
	    var needsSpan = false;
	
	    var markup = "<span";
	
	    if (this.classes.length) {
	        needsSpan = true;
	        markup += " class=\"";
	        markup += utils.escape(createClass(this.classes));
	        markup += "\"";
	    }
	
	    var styles = "";
	
	    if (this.italic > 0) {
	        styles += "margin-right:" + this.italic + "em;";
	    }
	    for (var style in this.style) {
	        if (this.style.hasOwnProperty(style)) {
	            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
	        }
	    }
	
	    if (styles) {
	        needsSpan = true;
	        markup += " style=\"" + utils.escape(styles) + "\"";
	    }
	
	    var escaped = utils.escape(this.value);
	    if (needsSpan) {
	        markup += ">";
	        markup += escaped;
	        markup += "</span>";
	        return markup;
	    } else {
	        return escaped;
	    }
	};
	
	module.exports = {
	    span: span,
	    documentFragment: documentFragment,
	    symbolNode: symbolNode
	};


/***/ }),
/* 115 */
/***/ (function(module, exports) {

	/**
	 * This file contains a list of utility functions which are useful in other
	 * files.
	 */
	
	/**
	 * Provide an `indexOf` function which works in IE8, but defers to native if
	 * possible.
	 */
	var nativeIndexOf = Array.prototype.indexOf;
	var indexOf = function(list, elem) {
	    if (list == null) {
	        return -1;
	    }
	    if (nativeIndexOf && list.indexOf === nativeIndexOf) {
	        return list.indexOf(elem);
	    }
	    var i = 0;
	    var l = list.length;
	    for (; i < l; i++) {
	        if (list[i] === elem) {
	            return i;
	        }
	    }
	    return -1;
	};
	
	/**
	 * Return whether an element is contained in a list
	 */
	var contains = function(list, elem) {
	    return indexOf(list, elem) !== -1;
	};
	
	/**
	 * Provide a default value if a setting is undefined
	 */
	var deflt = function(setting, defaultIfUndefined) {
	    return setting === undefined ? defaultIfUndefined : setting;
	};
	
	// hyphenate and escape adapted from Facebook's React under Apache 2 license
	
	var uppercase = /([A-Z])/g;
	var hyphenate = function(str) {
	    return str.replace(uppercase, "-$1").toLowerCase();
	};
	
	var ESCAPE_LOOKUP = {
	    "&": "&amp;",
	    ">": "&gt;",
	    "<": "&lt;",
	    "\"": "&quot;",
	    "'": "&#x27;"
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	    return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escape(text) {
	    return ("" + text).replace(ESCAPE_REGEX, escaper);
	}
	
	/**
	 * A function to set the text content of a DOM element in all supported
	 * browsers. Note that we don't define this if there is no document.
	 */
	var setTextContent;
	if (typeof document !== "undefined") {
	    var testNode = document.createElement("span");
	    if ("textContent" in testNode) {
	        setTextContent = function(node, text) {
	            node.textContent = text;
	        };
	    } else {
	        setTextContent = function(node, text) {
	            node.innerText = text;
	        };
	    }
	}
	
	/**
	 * A function to clear a node.
	 */
	function clearNode(node) {
	    setTextContent(node, "");
	}
	
	module.exports = {
	    contains: contains,
	    deflt: deflt,
	    escape: escape,
	    hyphenate: hyphenate,
	    indexOf: indexOf,
	    setTextContent: setTextContent,
	    clearNode: clearNode
	};


/***/ }),
/* 116 */
/***/ (function(module, exports) {

	/**
	 * This file holds a list of all no-argument functions and single-character
	 * symbols (like 'a' or ';').
	 *
	 * For each of the symbols, there are three properties they can have:
	 * - font (required): the font to be used for this symbol. Either "main" (the
	     normal font), or "ams" (the ams fonts).
	 * - group (required): the ParseNode group type the symbol should have (i.e.
	     "textord", "mathord", etc).
	     See https://github.com/Khan/KaTeX/wiki/Examining-TeX#group-types
	 * - replace: the character that this symbol or function should be
	 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
	 *   character in the main font).
	 *
	 * The outermost map in the table indicates what mode the symbols should be
	 * accepted in (e.g. "math" or "text").
	 */
	
	module.exports = {
	    math: {},
	    text: {}
	};
	
	function defineSymbol(mode, font, group, replace, name) {
	    module.exports[mode][name] = {
	        font: font,
	        group: group,
	        replace: replace
	    };
	}
	
	// Some abbreviations for commonly used strings.
	// This helps minify the code, and also spotting typos using jshint.
	
	// modes:
	var math = "math";
	var text = "text";
	
	// fonts:
	var main = "main";
	var ams = "ams";
	
	// groups:
	var accent = "accent";
	var bin = "bin";
	var close = "close";
	var inner = "inner";
	var mathord = "mathord";
	var op = "op";
	var open = "open";
	var punct = "punct";
	var rel = "rel";
	var spacing = "spacing";
	var textord = "textord";
	
	// Now comes the symbol table
	
	// Relation Symbols
	defineSymbol(math, main, rel, "\u2261", "\\equiv");
	defineSymbol(math, main, rel, "\u227a", "\\prec");
	defineSymbol(math, main, rel, "\u227b", "\\succ");
	defineSymbol(math, main, rel, "\u223c", "\\sim");
	defineSymbol(math, main, rel, "\u22a5", "\\perp");
	defineSymbol(math, main, rel, "\u2aaf", "\\preceq");
	defineSymbol(math, main, rel, "\u2ab0", "\\succeq");
	defineSymbol(math, main, rel, "\u2243", "\\simeq");
	defineSymbol(math, main, rel, "\u2223", "\\mid");
	defineSymbol(math, main, rel, "\u226a", "\\ll");
	defineSymbol(math, main, rel, "\u226b", "\\gg");
	defineSymbol(math, main, rel, "\u224d", "\\asymp");
	defineSymbol(math, main, rel, "\u2225", "\\parallel");
	defineSymbol(math, main, rel, "\u22c8", "\\bowtie");
	defineSymbol(math, main, rel, "\u2323", "\\smile");
	defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq");
	defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq");
	defineSymbol(math, main, rel, "\u2250", "\\doteq");
	defineSymbol(math, main, rel, "\u2322", "\\frown");
	defineSymbol(math, main, rel, "\u220b", "\\ni");
	defineSymbol(math, main, rel, "\u221d", "\\propto");
	defineSymbol(math, main, rel, "\u22a2", "\\vdash");
	defineSymbol(math, main, rel, "\u22a3", "\\dashv");
	defineSymbol(math, main, rel, "\u220b", "\\owns");
	
	// Punctuation
	defineSymbol(math, main, punct, "\u002e", "\\ldotp");
	defineSymbol(math, main, punct, "\u22c5", "\\cdotp");
	
	// Misc Symbols
	defineSymbol(math, main, textord, "\u0023", "\\#");
	defineSymbol(text, main, textord, "\u0023", "\\#");
	defineSymbol(math, main, textord, "\u0026", "\\&");
	defineSymbol(text, main, textord, "\u0026", "\\&");
	defineSymbol(math, main, textord, "\u2135", "\\aleph");
	defineSymbol(math, main, textord, "\u2200", "\\forall");
	defineSymbol(math, main, textord, "\u210f", "\\hbar");
	defineSymbol(math, main, textord, "\u2203", "\\exists");
	defineSymbol(math, main, textord, "\u2207", "\\nabla");
	defineSymbol(math, main, textord, "\u266d", "\\flat");
	defineSymbol(math, main, textord, "\u2113", "\\ell");
	defineSymbol(math, main, textord, "\u266e", "\\natural");
	defineSymbol(math, main, textord, "\u2663", "\\clubsuit");
	defineSymbol(math, main, textord, "\u2118", "\\wp");
	defineSymbol(math, main, textord, "\u266f", "\\sharp");
	defineSymbol(math, main, textord, "\u2662", "\\diamondsuit");
	defineSymbol(math, main, textord, "\u211c", "\\Re");
	defineSymbol(math, main, textord, "\u2661", "\\heartsuit");
	defineSymbol(math, main, textord, "\u2111", "\\Im");
	defineSymbol(math, main, textord, "\u2660", "\\spadesuit");
	
	// Math and Text
	defineSymbol(math, main, textord, "\u2020", "\\dag");
	defineSymbol(math, main, textord, "\u2021", "\\ddag");
	
	// Large Delimiters
	defineSymbol(math, main, close, "\u23b1", "\\rmoustache");
	defineSymbol(math, main, open, "\u23b0", "\\lmoustache");
	defineSymbol(math, main, close, "\u27ef", "\\rgroup");
	defineSymbol(math, main, open, "\u27ee", "\\lgroup");
	
	// Binary Operators
	defineSymbol(math, main, bin, "\u2213", "\\mp");
	defineSymbol(math, main, bin, "\u2296", "\\ominus");
	defineSymbol(math, main, bin, "\u228e", "\\uplus");
	defineSymbol(math, main, bin, "\u2293", "\\sqcap");
	defineSymbol(math, main, bin, "\u2217", "\\ast");
	defineSymbol(math, main, bin, "\u2294", "\\sqcup");
	defineSymbol(math, main, bin, "\u25ef", "\\bigcirc");
	defineSymbol(math, main, bin, "\u2219", "\\bullet");
	defineSymbol(math, main, bin, "\u2021", "\\ddagger");
	defineSymbol(math, main, bin, "\u2240", "\\wr");
	defineSymbol(math, main, bin, "\u2a3f", "\\amalg");
	
	// Arrow Symbols
	defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow");
	defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow");
	defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow");
	defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow");
	defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow");
	defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow");
	defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow");
	defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow");
	defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow");
	defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow");
	defineSymbol(math, main, rel, "\u21a6", "\\mapsto");
	defineSymbol(math, main, rel, "\u27fc", "\\longmapsto");
	defineSymbol(math, main, rel, "\u2197", "\\nearrow");
	defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow");
	defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow");
	defineSymbol(math, main, rel, "\u2198", "\\searrow");
	defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup");
	defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup");
	defineSymbol(math, main, rel, "\u2199", "\\swarrow");
	defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown");
	defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown");
	defineSymbol(math, main, rel, "\u2196", "\\nwarrow");
	defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons");
	
	// AMS Negated Binary Relations
	defineSymbol(math, ams, rel, "\u226e", "\\nless");
	defineSymbol(math, ams, rel, "\ue010", "\\nleqslant");
	defineSymbol(math, ams, rel, "\ue011", "\\nleqq");
	defineSymbol(math, ams, rel, "\u2a87", "\\lneq");
	defineSymbol(math, ams, rel, "\u2268", "\\lneqq");
	defineSymbol(math, ams, rel, "\ue00c", "\\lvertneqq");
	defineSymbol(math, ams, rel, "\u22e6", "\\lnsim");
	defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox");
	defineSymbol(math, ams, rel, "\u2280", "\\nprec");
	defineSymbol(math, ams, rel, "\u22e0", "\\npreceq");
	defineSymbol(math, ams, rel, "\u22e8", "\\precnsim");
	defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox");
	defineSymbol(math, ams, rel, "\u2241", "\\nsim");
	defineSymbol(math, ams, rel, "\ue006", "\\nshortmid");
	defineSymbol(math, ams, rel, "\u2224", "\\nmid");
	defineSymbol(math, ams, rel, "\u22ac", "\\nvdash");
	defineSymbol(math, ams, rel, "\u22ad", "\\nvDash");
	defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
	defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq");
	defineSymbol(math, ams, rel, "\u228a", "\\subsetneq");
	defineSymbol(math, ams, rel, "\ue01a", "\\varsubsetneq");
	defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq");
	defineSymbol(math, ams, rel, "\ue017", "\\varsubsetneqq");
	defineSymbol(math, ams, rel, "\u226f", "\\ngtr");
	defineSymbol(math, ams, rel, "\ue00f", "\\ngeqslant");
	defineSymbol(math, ams, rel, "\ue00e", "\\ngeqq");
	defineSymbol(math, ams, rel, "\u2a88", "\\gneq");
	defineSymbol(math, ams, rel, "\u2269", "\\gneqq");
	defineSymbol(math, ams, rel, "\ue00d", "\\gvertneqq");
	defineSymbol(math, ams, rel, "\u22e7", "\\gnsim");
	defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox");
	defineSymbol(math, ams, rel, "\u2281", "\\nsucc");
	defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq");
	defineSymbol(math, ams, rel, "\u22e9", "\\succnsim");
	defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox");
	defineSymbol(math, ams, rel, "\u2246", "\\ncong");
	defineSymbol(math, ams, rel, "\ue007", "\\nshortparallel");
	defineSymbol(math, ams, rel, "\u2226", "\\nparallel");
	defineSymbol(math, ams, rel, "\u22af", "\\nVDash");
	defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
	defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq");
	defineSymbol(math, ams, rel, "\ue018", "\\nsupseteqq");
	defineSymbol(math, ams, rel, "\u228b", "\\supsetneq");
	defineSymbol(math, ams, rel, "\ue01b", "\\varsupsetneq");
	defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq");
	defineSymbol(math, ams, rel, "\ue019", "\\varsupsetneqq");
	defineSymbol(math, ams, rel, "\u22ae", "\\nVdash");
	defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq");
	defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq");
	defineSymbol(math, ams, rel, "\ue016", "\\nsubseteqq");
	defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
	defineSymbol(math, ams, bin, "\u22b5", "\\unrhd");
	
	// AMS Negated Arrows
	defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow");
	defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow");
	defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow");
	defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow");
	defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow");
	defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow");
	
	// AMS Misc
	defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
	defineSymbol(math, ams, textord, "\u210f", "\\hslash");
	defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
	defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
	defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
	defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
	defineSymbol(math, ams, textord, "\u2221", "\\measuredangle");
	defineSymbol(math, ams, textord, "\u2204", "\\nexists");
	defineSymbol(math, ams, textord, "\u2127", "\\mho");
	defineSymbol(math, ams, textord, "\u2132", "\\Finv");
	defineSymbol(math, ams, textord, "\u2141", "\\Game");
	defineSymbol(math, ams, textord, "\u006b", "\\Bbbk");
	defineSymbol(math, ams, textord, "\u2035", "\\backprime");
	defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
	defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
	defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
	defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
	defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
	defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle");
	defineSymbol(math, ams, textord, "\u2201", "\\complement");
	defineSymbol(math, ams, textord, "\u00f0", "\\eth");
	defineSymbol(math, ams, textord, "\u2571", "\\diagup");
	defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
	defineSymbol(math, ams, textord, "\u25a1", "\\square");
	defineSymbol(math, ams, textord, "\u25a1", "\\Box");
	defineSymbol(math, ams, textord, "\u25ca", "\\Diamond");
	defineSymbol(math, ams, textord, "\u00a5", "\\yen");
	defineSymbol(math, ams, textord, "\u2713", "\\checkmark");
	
	// AMS Hebrew
	defineSymbol(math, ams, textord, "\u2136", "\\beth");
	defineSymbol(math, ams, textord, "\u2138", "\\daleth");
	defineSymbol(math, ams, textord, "\u2137", "\\gimel");
	
	// AMS Greek
	defineSymbol(math, ams, textord, "\u03dd", "\\digamma");
	defineSymbol(math, ams, textord, "\u03f0", "\\varkappa");
	
	// AMS Delimiters
	defineSymbol(math, ams, open, "\u250c", "\\ulcorner");
	defineSymbol(math, ams, close, "\u2510", "\\urcorner");
	defineSymbol(math, ams, open, "\u2514", "\\llcorner");
	defineSymbol(math, ams, close, "\u2518", "\\lrcorner");
	
	// AMS Binary Relations
	defineSymbol(math, ams, rel, "\u2266", "\\leqq");
	defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant");
	defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless");
	defineSymbol(math, ams, rel, "\u2272", "\\lesssim");
	defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox");
	defineSymbol(math, ams, rel, "\u224a", "\\approxeq");
	defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
	defineSymbol(math, ams, rel, "\u22d8", "\\lll");
	defineSymbol(math, ams, rel, "\u2276", "\\lessgtr");
	defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr");
	defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr");
	defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
	defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq");
	defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq");
	defineSymbol(math, ams, rel, "\u223d", "\\backsim");
	defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq");
	defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq");
	defineSymbol(math, ams, rel, "\u22d0", "\\Subset");
	defineSymbol(math, ams, rel, "\u228f", "\\sqsubset");
	defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq");
	defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec");
	defineSymbol(math, ams, rel, "\u227e", "\\precsim");
	defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox");
	defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
	defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
	defineSymbol(math, ams, rel, "\u22a8", "\\vDash");
	defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash");
	defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
	defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
	defineSymbol(math, ams, rel, "\u224f", "\\bumpeq");
	defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq");
	defineSymbol(math, ams, rel, "\u2267", "\\geqq");
	defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant");
	defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr");
	defineSymbol(math, ams, rel, "\u2273", "\\gtrsim");
	defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox");
	defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
	defineSymbol(math, ams, rel, "\u22d9", "\\ggg");
	defineSymbol(math, ams, rel, "\u2277", "\\gtrless");
	defineSymbol(math, ams, rel, "\u22db", "\\gtreqless");
	defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless");
	defineSymbol(math, ams, rel, "\u2256", "\\eqcirc");
	defineSymbol(math, ams, rel, "\u2257", "\\circeq");
	defineSymbol(math, ams, rel, "\u225c", "\\triangleq");
	defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
	defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
	defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq");
	defineSymbol(math, ams, rel, "\u22d1", "\\Supset");
	defineSymbol(math, ams, rel, "\u2290", "\\sqsupset");
	defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq");
	defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc");
	defineSymbol(math, ams, rel, "\u227f", "\\succsim");
	defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox");
	defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
	defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
	defineSymbol(math, ams, rel, "\u22a9", "\\Vdash");
	defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
	defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
	defineSymbol(math, ams, rel, "\u226c", "\\between");
	defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork");
	defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
	defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft");
	defineSymbol(math, ams, rel, "\u2234", "\\therefore");
	defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
	defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright");
	defineSymbol(math, ams, rel, "\u2235", "\\because");
	defineSymbol(math, ams, rel, "\u22d8", "\\llless");
	defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
	defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
	defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
	defineSymbol(math, ams, rel, "\u2242", "\\eqsim");
	defineSymbol(math, main, rel, "\u22c8", "\\Join");
	defineSymbol(math, ams, rel, "\u2251", "\\Doteq");
	
	// AMS Binary Operators
	defineSymbol(math, ams, bin, "\u2214", "\\dotplus");
	defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
	defineSymbol(math, ams, bin, "\u22d2", "\\Cap");
	defineSymbol(math, ams, bin, "\u22d3", "\\Cup");
	defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge");
	defineSymbol(math, ams, bin, "\u229f", "\\boxminus");
	defineSymbol(math, ams, bin, "\u229e", "\\boxplus");
	defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes");
	defineSymbol(math, ams, bin, "\u22c9", "\\ltimes");
	defineSymbol(math, ams, bin, "\u22ca", "\\rtimes");
	defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes");
	defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes");
	defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge");
	defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee");
	defineSymbol(math, ams, bin, "\u229d", "\\circleddash");
	defineSymbol(math, ams, bin, "\u229b", "\\circledast");
	defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
	defineSymbol(math, ams, bin, "\u22ba", "\\intercal");
	defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
	defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
	defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes");
	
	// AMS Arrows
	defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow");
	defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow");
	defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows");
	defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows");
	defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow");
	defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow");
	defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail");
	defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft");
	defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons");
	defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft");
	defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft");
	defineSymbol(math, ams, rel, "\u21b0", "\\Lsh");
	defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows");
	defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft");
	defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft");
	defineSymbol(math, ams, rel, "\u22b8", "\\multimap");
	defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow");
	defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows");
	defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows");
	defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow");
	defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail");
	defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright");
	defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright");
	defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright");
	defineSymbol(math, ams, rel, "\u21b1", "\\Rsh");
	defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows");
	defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright");
	defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright");
	defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow");
	defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
	defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow");
	defineSymbol(math, ams, rel, "\u21be", "\\restriction");
	
	defineSymbol(math, main, textord, "\u2018", "`");
	defineSymbol(math, main, textord, "$", "\\$");
	defineSymbol(text, main, textord, "$", "\\$");
	defineSymbol(math, main, textord, "%", "\\%");
	defineSymbol(text, main, textord, "%", "\\%");
	defineSymbol(math, main, textord, "_", "\\_");
	defineSymbol(text, main, textord, "_", "\\_");
	defineSymbol(math, main, textord, "\u2220", "\\angle");
	defineSymbol(math, main, textord, "\u221e", "\\infty");
	defineSymbol(math, main, textord, "\u2032", "\\prime");
	defineSymbol(math, main, textord, "\u25b3", "\\triangle");
	defineSymbol(math, main, textord, "\u0393", "\\Gamma");
	defineSymbol(math, main, textord, "\u0394", "\\Delta");
	defineSymbol(math, main, textord, "\u0398", "\\Theta");
	defineSymbol(math, main, textord, "\u039b", "\\Lambda");
	defineSymbol(math, main, textord, "\u039e", "\\Xi");
	defineSymbol(math, main, textord, "\u03a0", "\\Pi");
	defineSymbol(math, main, textord, "\u03a3", "\\Sigma");
	defineSymbol(math, main, textord, "\u03a5", "\\Upsilon");
	defineSymbol(math, main, textord, "\u03a6", "\\Phi");
	defineSymbol(math, main, textord, "\u03a8", "\\Psi");
	defineSymbol(math, main, textord, "\u03a9", "\\Omega");
	defineSymbol(math, main, textord, "\u00ac", "\\neg");
	defineSymbol(math, main, textord, "\u00ac", "\\lnot");
	defineSymbol(math, main, textord, "\u22a4", "\\top");
	defineSymbol(math, main, textord, "\u22a5", "\\bot");
	defineSymbol(math, main, textord, "\u2205", "\\emptyset");
	defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
	defineSymbol(math, main, mathord, "\u03b1", "\\alpha");
	defineSymbol(math, main, mathord, "\u03b2", "\\beta");
	defineSymbol(math, main, mathord, "\u03b3", "\\gamma");
	defineSymbol(math, main, mathord, "\u03b4", "\\delta");
	defineSymbol(math, main, mathord, "\u03f5", "\\epsilon");
	defineSymbol(math, main, mathord, "\u03b6", "\\zeta");
	defineSymbol(math, main, mathord, "\u03b7", "\\eta");
	defineSymbol(math, main, mathord, "\u03b8", "\\theta");
	defineSymbol(math, main, mathord, "\u03b9", "\\iota");
	defineSymbol(math, main, mathord, "\u03ba", "\\kappa");
	defineSymbol(math, main, mathord, "\u03bb", "\\lambda");
	defineSymbol(math, main, mathord, "\u03bc", "\\mu");
	defineSymbol(math, main, mathord, "\u03bd", "\\nu");
	defineSymbol(math, main, mathord, "\u03be", "\\xi");
	defineSymbol(math, main, mathord, "o", "\\omicron");
	defineSymbol(math, main, mathord, "\u03c0", "\\pi");
	defineSymbol(math, main, mathord, "\u03c1", "\\rho");
	defineSymbol(math, main, mathord, "\u03c3", "\\sigma");
	defineSymbol(math, main, mathord, "\u03c4", "\\tau");
	defineSymbol(math, main, mathord, "\u03c5", "\\upsilon");
	defineSymbol(math, main, mathord, "\u03d5", "\\phi");
	defineSymbol(math, main, mathord, "\u03c7", "\\chi");
	defineSymbol(math, main, mathord, "\u03c8", "\\psi");
	defineSymbol(math, main, mathord, "\u03c9", "\\omega");
	defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon");
	defineSymbol(math, main, mathord, "\u03d1", "\\vartheta");
	defineSymbol(math, main, mathord, "\u03d6", "\\varpi");
	defineSymbol(math, main, mathord, "\u03f1", "\\varrho");
	defineSymbol(math, main, mathord, "\u03c2", "\\varsigma");
	defineSymbol(math, main, mathord, "\u03c6", "\\varphi");
	defineSymbol(math, main, bin, "\u2217", "*");
	defineSymbol(math, main, bin, "+", "+");
	defineSymbol(math, main, bin, "\u2212", "-");
	defineSymbol(math, main, bin, "\u22c5", "\\cdot");
	defineSymbol(math, main, bin, "\u2218", "\\circ");
	defineSymbol(math, main, bin, "\u00f7", "\\div");
	defineSymbol(math, main, bin, "\u00b1", "\\pm");
	defineSymbol(math, main, bin, "\u00d7", "\\times");
	defineSymbol(math, main, bin, "\u2229", "\\cap");
	defineSymbol(math, main, bin, "\u222a", "\\cup");
	defineSymbol(math, main, bin, "\u2216", "\\setminus");
	defineSymbol(math, main, bin, "\u2227", "\\land");
	defineSymbol(math, main, bin, "\u2228", "\\lor");
	defineSymbol(math, main, bin, "\u2227", "\\wedge");
	defineSymbol(math, main, bin, "\u2228", "\\vee");
	defineSymbol(math, main, textord, "\u221a", "\\surd");
	defineSymbol(math, main, open, "(", "(");
	defineSymbol(math, main, open, "[", "[");
	defineSymbol(math, main, open, "\u27e8", "\\langle");
	defineSymbol(math, main, open, "\u2223", "\\lvert");
	defineSymbol(math, main, open, "\u2225", "\\lVert");
	defineSymbol(math, main, close, ")", ")");
	defineSymbol(math, main, close, "]", "]");
	defineSymbol(math, main, close, "?", "?");
	defineSymbol(math, main, close, "!", "!");
	defineSymbol(math, main, close, "\u27e9", "\\rangle");
	defineSymbol(math, main, close, "\u2223", "\\rvert");
	defineSymbol(math, main, close, "\u2225", "\\rVert");
	defineSymbol(math, main, rel, "=", "=");
	defineSymbol(math, main, rel, "<", "<");
	defineSymbol(math, main, rel, ">", ">");
	defineSymbol(math, main, rel, ":", ":");
	defineSymbol(math, main, rel, "\u2248", "\\approx");
	defineSymbol(math, main, rel, "\u2245", "\\cong");
	defineSymbol(math, main, rel, "\u2265", "\\ge");
	defineSymbol(math, main, rel, "\u2265", "\\geq");
	defineSymbol(math, main, rel, "\u2190", "\\gets");
	defineSymbol(math, main, rel, ">", "\\gt");
	defineSymbol(math, main, rel, "\u2208", "\\in");
	defineSymbol(math, main, rel, "\u2209", "\\notin");
	defineSymbol(math, main, rel, "\u2282", "\\subset");
	defineSymbol(math, main, rel, "\u2283", "\\supset");
	defineSymbol(math, main, rel, "\u2286", "\\subseteq");
	defineSymbol(math, main, rel, "\u2287", "\\supseteq");
	defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq");
	defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq");
	defineSymbol(math, main, rel, "\u22a8", "\\models");
	defineSymbol(math, main, rel, "\u2190", "\\leftarrow");
	defineSymbol(math, main, rel, "\u2264", "\\le");
	defineSymbol(math, main, rel, "\u2264", "\\leq");
	defineSymbol(math, main, rel, "<", "\\lt");
	defineSymbol(math, main, rel, "\u2260", "\\ne");
	defineSymbol(math, main, rel, "\u2260", "\\neq");
	defineSymbol(math, main, rel, "\u2192", "\\rightarrow");
	defineSymbol(math, main, rel, "\u2192", "\\to");
	defineSymbol(math, ams, rel, "\u2271", "\\ngeq");
	defineSymbol(math, ams, rel, "\u2270", "\\nleq");
	defineSymbol(math, main, spacing, null, "\\!");
	defineSymbol(math, main, spacing, "\u00a0", "\\ ");
	defineSymbol(math, main, spacing, "\u00a0", "~");
	defineSymbol(math, main, spacing, null, "\\,");
	defineSymbol(math, main, spacing, null, "\\:");
	defineSymbol(math, main, spacing, null, "\\;");
	defineSymbol(math, main, spacing, null, "\\enspace");
	defineSymbol(math, main, spacing, null, "\\qquad");
	defineSymbol(math, main, spacing, null, "\\quad");
	defineSymbol(math, main, spacing, "\u00a0", "\\space");
	defineSymbol(math, main, punct, ",", ",");
	defineSymbol(math, main, punct, ";", ";");
	defineSymbol(math, main, punct, ":", "\\colon");
	defineSymbol(math, ams, bin, "\u22bc", "\\barwedge");
	defineSymbol(math, ams, bin, "\u22bb", "\\veebar");
	defineSymbol(math, main, bin, "\u2299", "\\odot");
	defineSymbol(math, main, bin, "\u2295", "\\oplus");
	defineSymbol(math, main, bin, "\u2297", "\\otimes");
	defineSymbol(math, main, textord, "\u2202", "\\partial");
	defineSymbol(math, main, bin, "\u2298", "\\oslash");
	defineSymbol(math, ams, bin, "\u229a", "\\circledcirc");
	defineSymbol(math, ams, bin, "\u22a1", "\\boxdot");
	defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
	defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
	defineSymbol(math, main, bin, "\u2020", "\\dagger");
	defineSymbol(math, main, bin, "\u22c4", "\\diamond");
	defineSymbol(math, main, bin, "\u22c6", "\\star");
	defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
	defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
	defineSymbol(math, main, open, "{", "\\{");
	defineSymbol(text, main, textord, "{", "\\{");
	defineSymbol(math, main, close, "}", "\\}");
	defineSymbol(text, main, textord, "}", "\\}");
	defineSymbol(math, main, open, "{", "\\lbrace");
	defineSymbol(math, main, close, "}", "\\rbrace");
	defineSymbol(math, main, open, "[", "\\lbrack");
	defineSymbol(math, main, close, "]", "\\rbrack");
	defineSymbol(math, main, open, "\u230a", "\\lfloor");
	defineSymbol(math, main, close, "\u230b", "\\rfloor");
	defineSymbol(math, main, open, "\u2308", "\\lceil");
	defineSymbol(math, main, close, "\u2309", "\\rceil");
	defineSymbol(math, main, textord, "\\", "\\backslash");
	defineSymbol(math, main, textord, "\u2223", "|");
	defineSymbol(math, main, textord, "\u2223", "\\vert");
	defineSymbol(math, main, textord, "\u2225", "\\|");
	defineSymbol(math, main, textord, "\u2225", "\\Vert");
	defineSymbol(math, main, rel, "\u2191", "\\uparrow");
	defineSymbol(math, main, rel, "\u21d1", "\\Uparrow");
	defineSymbol(math, main, rel, "\u2193", "\\downarrow");
	defineSymbol(math, main, rel, "\u21d3", "\\Downarrow");
	defineSymbol(math, main, rel, "\u2195", "\\updownarrow");
	defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow");
	defineSymbol(math, math, op, "\u2210", "\\coprod");
	defineSymbol(math, math, op, "\u22c1", "\\bigvee");
	defineSymbol(math, math, op, "\u22c0", "\\bigwedge");
	defineSymbol(math, math, op, "\u2a04", "\\biguplus");
	defineSymbol(math, math, op, "\u22c2", "\\bigcap");
	defineSymbol(math, math, op, "\u22c3", "\\bigcup");
	defineSymbol(math, math, op, "\u222b", "\\int");
	defineSymbol(math, math, op, "\u222b", "\\intop");
	defineSymbol(math, math, op, "\u222c", "\\iint");
	defineSymbol(math, math, op, "\u222d", "\\iiint");
	defineSymbol(math, math, op, "\u220f", "\\prod");
	defineSymbol(math, math, op, "\u2211", "\\sum");
	defineSymbol(math, math, op, "\u2a02", "\\bigotimes");
	defineSymbol(math, math, op, "\u2a01", "\\bigoplus");
	defineSymbol(math, math, op, "\u2a00", "\\bigodot");
	defineSymbol(math, math, op, "\u222e", "\\oint");
	defineSymbol(math, math, op, "\u2a06", "\\bigsqcup");
	defineSymbol(math, math, op, "\u222b", "\\smallint");
	defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
	defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
	defineSymbol(text, main, inner, "\u2026", "\\ldots");
	defineSymbol(math, main, inner, "\u2026", "\\ldots");
	defineSymbol(math, main, inner, "\u22ef", "\\cdots");
	defineSymbol(math, main, inner, "\u22f1", "\\ddots");
	defineSymbol(math, main, textord, "\u22ee", "\\vdots");
	defineSymbol(math, main, accent, "\u00b4", "\\acute");
	defineSymbol(math, main, accent, "\u0060", "\\grave");
	defineSymbol(math, main, accent, "\u00a8", "\\ddot");
	defineSymbol(math, main, accent, "\u007e", "\\tilde");
	defineSymbol(math, main, accent, "\u00af", "\\bar");
	defineSymbol(math, main, accent, "\u02d8", "\\breve");
	defineSymbol(math, main, accent, "\u02c7", "\\check");
	defineSymbol(math, main, accent, "\u005e", "\\hat");
	defineSymbol(math, main, accent, "\u20d7", "\\vec");
	defineSymbol(math, main, accent, "\u02d9", "\\dot");
	defineSymbol(math, main, mathord, "\u0131", "\\imath");
	defineSymbol(math, main, mathord, "\u0237", "\\jmath");
	
	defineSymbol(text, main, textord, "\u2013", "--");
	defineSymbol(text, main, textord, "\u2014", "---");
	defineSymbol(text, main, textord, "\u2018", "`");
	defineSymbol(text, main, textord, "\u2019", "'");
	defineSymbol(text, main, textord, "\u201c", "``");
	defineSymbol(text, main, textord, "\u201d", "''");
	defineSymbol(math, main, textord, "\u00b0", "\\degree");
	defineSymbol(text, main, textord, "\u00b0", "\\degree");
	defineSymbol(math, main, mathord, "\u00a3", "\\pounds");
	defineSymbol(math, ams, textord, "\u2720", "\\maltese");
	defineSymbol(text, ams, textord, "\u2720", "\\maltese");
	
	defineSymbol(text, main, spacing, "\u00a0", "\\ ");
	defineSymbol(text, main, spacing, "\u00a0", " ");
	defineSymbol(text, main, spacing, "\u00a0", "~");
	
	// There are lots of symbols which are the same, so we add them in afterwards.
	var i;
	var ch;
	
	// All of these are textords in math mode
	var mathTextSymbols = "0123456789/@.\"";
	for (i = 0; i < mathTextSymbols.length; i++) {
	    ch = mathTextSymbols.charAt(i);
	    defineSymbol(math, main, textord, ch, ch);
	}
	
	// All of these are textords in text mode
	var textSymbols = "0123456789!@*()-=+[]\";:?/.,";
	for (i = 0; i < textSymbols.length; i++) {
	    ch = textSymbols.charAt(i);
	    defineSymbol(text, main, textord, ch, ch);
	}
	
	// All of these are textords in text mode, and mathords in math mode
	var letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	for (i = 0; i < letters.length; i++) {
	    ch = letters.charAt(i);
	    defineSymbol(math, main, mathord, ch, ch);
	    defineSymbol(text, main, textord, ch, ch);
	}
	
	// Latin-1 letters
	for (i = 0x00C0; i <= 0x00D6; i++) {
	    ch = String.fromCharCode(i);
	    defineSymbol(text, main, textord, ch, ch);
	}
	
	for (i = 0x00D8; i <= 0x00F6; i++) {
	    ch = String.fromCharCode(i);
	    defineSymbol(text, main, textord, ch, ch);
	}
	
	for (i = 0x00F8; i <= 0x00FF; i++) {
	    ch = String.fromCharCode(i);
	    defineSymbol(text, main, textord, ch, ch);
	}
	
	// Cyrillic
	for (i = 0x0410; i <= 0x044F; i++) {
	    ch = String.fromCharCode(i);
	    defineSymbol(text, main, textord, ch, ch);
	}
	
	// Unicode versions of existing characters
	defineSymbol(text, main, textord, "\u2013", "");
	defineSymbol(text, main, textord, "\u2014", "");
	defineSymbol(text, main, textord, "\u2018", "");
	defineSymbol(text, main, textord, "\u2019", "");
	defineSymbol(text, main, textord, "\u201c", "");
	defineSymbol(text, main, textord, "\u201d", "");


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This file deals with creating delimiters of various sizes. The TeXbook
	 * discusses these routines on page 441-442, in the "Another subroutine sets box
	 * x to a specified variable delimiter" paragraph.
	 *
	 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
	 * normal font, but in either text, script, or scriptscript style.
	 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
	 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
	 * smaller pieces that are stacked on top of one another.
	 *
	 * The functions take a parameter `center`, which determines if the delimiter
	 * should be centered around the axis.
	 *
	 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
	 * one of the given sizes. This is used for things like `\bigl`.
	 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
	 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
	 * delimiter which surrounds an expression of a given height an depth. It is
	 * used in `\left` and `\right`.
	 */
	
	var ParseError = __webpack_require__(105);
	var Style = __webpack_require__(109);
	
	var buildCommon = __webpack_require__(113);
	var fontMetrics = __webpack_require__(110);
	var symbols = __webpack_require__(116);
	var utils = __webpack_require__(115);
	
	var makeSpan = buildCommon.makeSpan;
	
	/**
	 * Get the metrics for a given symbol and font, after transformation (i.e.
	 * after following replacement from symbols.js)
	 */
	var getMetrics = function(symbol, font) {
	    if (symbols.math[symbol] && symbols.math[symbol].replace) {
	        return fontMetrics.getCharacterMetrics(
	            symbols.math[symbol].replace, font);
	    } else {
	        return fontMetrics.getCharacterMetrics(
	            symbol, font);
	    }
	};
	
	/**
	 * Builds a symbol in the given font size (note size is an integer)
	 */
	var mathrmSize = function(value, size, mode, options) {
	    return buildCommon.makeSymbol(value, "Size" + size + "-Regular",
	        mode, options);
	};
	
	/**
	 * Puts a delimiter span in a given style, and adds appropriate height, depth,
	 * and maxFontSizes.
	 */
	var styleWrap = function(delim, toStyle, options, classes) {
	    classes = classes || [];
	    var span = makeSpan(
	        classes.concat(["style-wrap", options.style.reset(), toStyle.cls()]),
	        [delim], options);
	
	    var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;
	
	    span.height *= multiplier;
	    span.depth *= multiplier;
	    span.maxFontSize = toStyle.sizeMultiplier;
	
	    return span;
	};
	
	/**
	 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
	 * font, but is restyled to either be in textstyle, scriptstyle, or
	 * scriptscriptstyle.
	 */
	var makeSmallDelim = function(delim, style, center, options, mode, classes) {
	    var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
	
	    var span = styleWrap(text, style, options, classes);
	
	    if (center) {
	        var shift =
	            (1 - options.style.sizeMultiplier / style.sizeMultiplier) *
	            options.style.metrics.axisHeight;
	
	        span.style.top = shift + "em";
	        span.height -= shift;
	        span.depth += shift;
	    }
	
	    return span;
	};
	
	/**
	 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
	 * Size3, or Size4 fonts. It is always rendered in textstyle.
	 */
	var makeLargeDelim = function(delim, size, center, options, mode, classes) {
	    var inner = mathrmSize(delim, size, mode, options);
	
	    var span = styleWrap(
	        makeSpan(["delimsizing", "size" + size], [inner], options),
	        Style.TEXT, options, classes);
	
	    if (center) {
	        var shift = (1 - options.style.sizeMultiplier) *
	            options.style.metrics.axisHeight;
	
	        span.style.top = shift + "em";
	        span.height -= shift;
	        span.depth += shift;
	    }
	
	    return span;
	};
	
	/**
	 * Make an inner span with the given offset and in the given font. This is used
	 * in `makeStackedDelim` to make the stacking pieces for the delimiter.
	 */
	var makeInner = function(symbol, font, mode) {
	    var sizeClass;
	    // Apply the correct CSS class to choose the right font.
	    if (font === "Size1-Regular") {
	        sizeClass = "delim-size1";
	    } else if (font === "Size4-Regular") {
	        sizeClass = "delim-size4";
	    }
	
	    var inner = makeSpan(
	        ["delimsizinginner", sizeClass],
	        [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
	
	    // Since this will be passed into `makeVList` in the end, wrap the element
	    // in the appropriate tag that VList uses.
	    return {type: "elem", elem: inner};
	};
	
	/**
	 * Make a stacked delimiter out of a given delimiter, with the total height at
	 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
	 */
	var makeStackedDelim = function(delim, heightTotal, center, options, mode,
	                                classes) {
	    // There are four parts, the top, an optional middle, a repeated part, and a
	    // bottom.
	    var top;
	    var middle;
	    var repeat;
	    var bottom;
	    top = repeat = bottom = delim;
	    middle = null;
	    // Also keep track of what font the delimiters are in
	    var font = "Size1-Regular";
	
	    // We set the parts and font based on the symbol. Note that we use
	    // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
	    // repeats of the arrows
	    if (delim === "\\uparrow") {
	        repeat = bottom = "\u23d0";
	    } else if (delim === "\\Uparrow") {
	        repeat = bottom = "\u2016";
	    } else if (delim === "\\downarrow") {
	        top = repeat = "\u23d0";
	    } else if (delim === "\\Downarrow") {
	        top = repeat = "\u2016";
	    } else if (delim === "\\updownarrow") {
	        top = "\\uparrow";
	        repeat = "\u23d0";
	        bottom = "\\downarrow";
	    } else if (delim === "\\Updownarrow") {
	        top = "\\Uparrow";
	        repeat = "\u2016";
	        bottom = "\\Downarrow";
	    } else if (delim === "[" || delim === "\\lbrack") {
	        top = "\u23a1";
	        repeat = "\u23a2";
	        bottom = "\u23a3";
	        font = "Size4-Regular";
	    } else if (delim === "]" || delim === "\\rbrack") {
	        top = "\u23a4";
	        repeat = "\u23a5";
	        bottom = "\u23a6";
	        font = "Size4-Regular";
	    } else if (delim === "\\lfloor") {
	        repeat = top = "\u23a2";
	        bottom = "\u23a3";
	        font = "Size4-Regular";
	    } else if (delim === "\\lceil") {
	        top = "\u23a1";
	        repeat = bottom = "\u23a2";
	        font = "Size4-Regular";
	    } else if (delim === "\\rfloor") {
	        repeat = top = "\u23a5";
	        bottom = "\u23a6";
	        font = "Size4-Regular";
	    } else if (delim === "\\rceil") {
	        top = "\u23a4";
	        repeat = bottom = "\u23a5";
	        font = "Size4-Regular";
	    } else if (delim === "(") {
	        top = "\u239b";
	        repeat = "\u239c";
	        bottom = "\u239d";
	        font = "Size4-Regular";
	    } else if (delim === ")") {
	        top = "\u239e";
	        repeat = "\u239f";
	        bottom = "\u23a0";
	        font = "Size4-Regular";
	    } else if (delim === "\\{" || delim === "\\lbrace") {
	        top = "\u23a7";
	        middle = "\u23a8";
	        bottom = "\u23a9";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\}" || delim === "\\rbrace") {
	        top = "\u23ab";
	        middle = "\u23ac";
	        bottom = "\u23ad";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\lgroup") {
	        top = "\u23a7";
	        bottom = "\u23a9";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\rgroup") {
	        top = "\u23ab";
	        bottom = "\u23ad";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\lmoustache") {
	        top = "\u23a7";
	        bottom = "\u23ad";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\rmoustache") {
	        top = "\u23ab";
	        bottom = "\u23a9";
	        repeat = "\u23aa";
	        font = "Size4-Regular";
	    } else if (delim === "\\surd") {
	        top = "\ue001";
	        bottom = "\u23b7";
	        repeat = "\ue000";
	        font = "Size4-Regular";
	    }
	
	    // Get the metrics of the four sections
	    var topMetrics = getMetrics(top, font);
	    var topHeightTotal = topMetrics.height + topMetrics.depth;
	    var repeatMetrics = getMetrics(repeat, font);
	    var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
	    var bottomMetrics = getMetrics(bottom, font);
	    var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
	    var middleHeightTotal = 0;
	    var middleFactor = 1;
	    if (middle !== null) {
	        var middleMetrics = getMetrics(middle, font);
	        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
	        middleFactor = 2; // repeat symmetrically above and below middle
	    }
	
	    // Calcuate the minimal height that the delimiter can have.
	    // It is at least the size of the top, bottom, and optional middle combined.
	    var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
	
	    // Compute the number of copies of the repeat symbol we will need
	    var repeatCount = Math.ceil(
	        (heightTotal - minHeight) / (middleFactor * repeatHeightTotal));
	
	    // Compute the total height of the delimiter including all the symbols
	    var realHeightTotal =
	        minHeight + repeatCount * middleFactor * repeatHeightTotal;
	
	    // The center of the delimiter is placed at the center of the axis. Note
	    // that in this context, "center" means that the delimiter should be
	    // centered around the axis in the current style, while normally it is
	    // centered around the axis in textstyle.
	    var axisHeight = options.style.metrics.axisHeight;
	    if (center) {
	        axisHeight *= options.style.sizeMultiplier;
	    }
	    // Calculate the depth
	    var depth = realHeightTotal / 2 - axisHeight;
	
	    // Now, we start building the pieces that will go into the vlist
	
	    // Keep a list of the inner pieces
	    var inners = [];
	
	    // Add the bottom symbol
	    inners.push(makeInner(bottom, font, mode));
	
	    var i;
	    if (middle === null) {
	        // Add that many symbols
	        for (i = 0; i < repeatCount; i++) {
	            inners.push(makeInner(repeat, font, mode));
	        }
	    } else {
	        // When there is a middle bit, we need the middle part and two repeated
	        // sections
	        for (i = 0; i < repeatCount; i++) {
	            inners.push(makeInner(repeat, font, mode));
	        }
	        inners.push(makeInner(middle, font, mode));
	        for (i = 0; i < repeatCount; i++) {
	            inners.push(makeInner(repeat, font, mode));
	        }
	    }
	
	    // Add the top symbol
	    inners.push(makeInner(top, font, mode));
	
	    // Finally, build the vlist
	    var inner = buildCommon.makeVList(inners, "bottom", depth, options);
	
	    return styleWrap(
	        makeSpan(["delimsizing", "mult"], [inner], options),
	        Style.TEXT, options, classes);
	};
	
	// There are three kinds of delimiters, delimiters that stack when they become
	// too large
	var stackLargeDelimiters = [
	    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
	    "\\{", "\\lbrace", "\\}", "\\rbrace",
	    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
	    "\\surd"
	];
	
	// delimiters that always stack
	var stackAlwaysDelimiters = [
	    "\\uparrow", "\\downarrow", "\\updownarrow",
	    "\\Uparrow", "\\Downarrow", "\\Updownarrow",
	    "|", "\\|", "\\vert", "\\Vert",
	    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
	    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache"
	];
	
	// and delimiters that never stack
	var stackNeverDelimiters = [
	    "<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"
	];
	
	// Metrics of the different sizes. Found by looking at TeX's output of
	// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
	// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
	var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];
	
	/**
	 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
	 */
	var makeSizedDelim = function(delim, size, options, mode, classes) {
	    // < and > turn into \langle and \rangle in delimiters
	    if (delim === "<" || delim === "\\lt") {
	        delim = "\\langle";
	    } else if (delim === ">" || delim === "\\gt") {
	        delim = "\\rangle";
	    }
	
	    // Sized delimiters are never centered.
	    if (utils.contains(stackLargeDelimiters, delim) ||
	        utils.contains(stackNeverDelimiters, delim)) {
	        return makeLargeDelim(delim, size, false, options, mode, classes);
	    } else if (utils.contains(stackAlwaysDelimiters, delim)) {
	        return makeStackedDelim(
	            delim, sizeToMaxHeight[size], false, options, mode, classes);
	    } else {
	        throw new ParseError("Illegal delimiter: '" + delim + "'");
	    }
	};
	
	/**
	 * There are three different sequences of delimiter sizes that the delimiters
	 * follow depending on the kind of delimiter. This is used when creating custom
	 * sized delimiters to decide whether to create a small, large, or stacked
	 * delimiter.
	 *
	 * In real TeX, these sequences aren't explicitly defined, but are instead
	 * defined inside the font metrics. Since there are only three sequences that
	 * are possible for the delimiters that TeX defines, it is easier to just encode
	 * them explicitly here.
	 */
	
	// Delimiters that never stack try small delimiters and large delimiters only
	var stackNeverDelimiterSequence = [
	    {type: "small", style: Style.SCRIPTSCRIPT},
	    {type: "small", style: Style.SCRIPT},
	    {type: "small", style: Style.TEXT},
	    {type: "large", size: 1},
	    {type: "large", size: 2},
	    {type: "large", size: 3},
	    {type: "large", size: 4}
	];
	
	// Delimiters that always stack try the small delimiters first, then stack
	var stackAlwaysDelimiterSequence = [
	    {type: "small", style: Style.SCRIPTSCRIPT},
	    {type: "small", style: Style.SCRIPT},
	    {type: "small", style: Style.TEXT},
	    {type: "stack"}
	];
	
	// Delimiters that stack when large try the small and then large delimiters, and
	// stack afterwards
	var stackLargeDelimiterSequence = [
	    {type: "small", style: Style.SCRIPTSCRIPT},
	    {type: "small", style: Style.SCRIPT},
	    {type: "small", style: Style.TEXT},
	    {type: "large", size: 1},
	    {type: "large", size: 2},
	    {type: "large", size: 3},
	    {type: "large", size: 4},
	    {type: "stack"}
	];
	
	/**
	 * Get the font used in a delimiter based on what kind of delimiter it is.
	 */
	var delimTypeToFont = function(type) {
	    if (type.type === "small") {
	        return "Main-Regular";
	    } else if (type.type === "large") {
	        return "Size" + type.size + "-Regular";
	    } else if (type.type === "stack") {
	        return "Size4-Regular";
	    }
	};
	
	/**
	 * Traverse a sequence of types of delimiters to decide what kind of delimiter
	 * should be used to create a delimiter of the given height+depth.
	 */
	var traverseSequence = function(delim, height, sequence, options) {
	    // Here, we choose the index we should start at in the sequences. In smaller
	    // sizes (which correspond to larger numbers in style.size) we start earlier
	    // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
	    // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
	    var start = Math.min(2, 3 - options.style.size);
	    for (var i = start; i < sequence.length; i++) {
	        if (sequence[i].type === "stack") {
	            // This is always the last delimiter, so we just break the loop now.
	            break;
	        }
	
	        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));
	        var heightDepth = metrics.height + metrics.depth;
	
	        // Small delimiters are scaled down versions of the same font, so we
	        // account for the style change size.
	
	        if (sequence[i].type === "small") {
	            heightDepth *= sequence[i].style.sizeMultiplier;
	        }
	
	        // Check if the delimiter at this size works for the given height.
	        if (heightDepth > height) {
	            return sequence[i];
	        }
	    }
	
	    // If we reached the end of the sequence, return the last sequence element.
	    return sequence[sequence.length - 1];
	};
	
	/**
	 * Make a delimiter of a given height+depth, with optional centering. Here, we
	 * traverse the sequences, and create a delimiter that the sequence tells us to.
	 */
	var makeCustomSizedDelim = function(delim, height, center, options, mode,
	                                    classes) {
	    if (delim === "<" || delim === "\\lt") {
	        delim = "\\langle";
	    } else if (delim === ">" || delim === "\\gt") {
	        delim = "\\rangle";
	    }
	
	    // Decide what sequence to use
	    var sequence;
	    if (utils.contains(stackNeverDelimiters, delim)) {
	        sequence = stackNeverDelimiterSequence;
	    } else if (utils.contains(stackLargeDelimiters, delim)) {
	        sequence = stackLargeDelimiterSequence;
	    } else {
	        sequence = stackAlwaysDelimiterSequence;
	    }
	
	    // Look through the sequence
	    var delimType = traverseSequence(delim, height, sequence, options);
	
	    // Depending on the sequence element we decided on, call the appropriate
	    // function.
	    if (delimType.type === "small") {
	        return makeSmallDelim(delim, delimType.style, center, options, mode,
	                              classes);
	    } else if (delimType.type === "large") {
	        return makeLargeDelim(delim, delimType.size, center, options, mode,
	                              classes);
	    } else if (delimType.type === "stack") {
	        return makeStackedDelim(delim, height, center, options, mode, classes);
	    }
	};
	
	/**
	 * Make a delimiter for use with `\left` and `\right`, given a height and depth
	 * of an expression that the delimiters surround.
	 */
	var makeLeftRightDelim = function(delim, height, depth, options, mode,
	                                  classes) {
	    // We always center \left/\right delimiters, so the axis is always shifted
	    var axisHeight =
	        options.style.metrics.axisHeight * options.style.sizeMultiplier;
	
	    // Taken from TeX source, tex.web, function make_left_right
	    var delimiterFactor = 901;
	    var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;
	
	    var maxDistFromAxis = Math.max(
	        height - axisHeight, depth + axisHeight);
	
	    var totalHeight = Math.max(
	        // In real TeX, calculations are done using integral values which are
	        // 65536 per pt, or 655360 per em. So, the division here truncates in
	        // TeX but doesn't here, producing different results. If we wanted to
	        // exactly match TeX's calculation, we could do
	        //   Math.floor(655360 * maxDistFromAxis / 500) *
	        //    delimiterFactor / 655360
	        // (To see the difference, compare
	        //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
	        // in TeX and KaTeX)
	        maxDistFromAxis / 500 * delimiterFactor,
	        2 * maxDistFromAxis - delimiterExtend);
	
	    // Finally, we defer to `makeCustomSizedDelim` with our calculated total
	    // height
	    return makeCustomSizedDelim(delim, totalHeight, true, options, mode,
	                                classes);
	};
	
	module.exports = {
	    sizedDelim: makeSizedDelim,
	    customSizedDelim: makeCustomSizedDelim,
	    leftRightDelim: makeLeftRightDelim
	};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This file converts a parse tree into a cooresponding MathML tree. The main
	 * entry point is the `buildMathML` function, which takes a parse tree from the
	 * parser.
	 */
	
	var buildCommon = __webpack_require__(113);
	var fontMetrics = __webpack_require__(110);
	var mathMLTree = __webpack_require__(119);
	var ParseError = __webpack_require__(105);
	var symbols = __webpack_require__(116);
	var utils = __webpack_require__(115);
	
	var makeSpan = buildCommon.makeSpan;
	var fontMap = buildCommon.fontMap;
	
	/**
	 * Takes a symbol and converts it into a MathML text node after performing
	 * optional replacement from symbols.js.
	 */
	var makeText = function(text, mode) {
	    if (symbols[mode][text] && symbols[mode][text].replace) {
	        text = symbols[mode][text].replace;
	    }
	
	    return new mathMLTree.TextNode(text);
	};
	
	/**
	 * Returns the math variant as a string or null if none is required.
	 */
	var getVariant = function(group, options) {
	    var font = options.font;
	    if (!font) {
	        return null;
	    }
	
	    var mode = group.mode;
	    if (font === "mathit") {
	        return "italic";
	    }
	
	    var value = group.value;
	    if (utils.contains(["\\imath", "\\jmath"], value)) {
	        return null;
	    }
	
	    if (symbols[mode][value] && symbols[mode][value].replace) {
	        value = symbols[mode][value].replace;
	    }
	
	    var fontName = fontMap[font].fontName;
	    if (fontMetrics.getCharacterMetrics(value, fontName)) {
	        return fontMap[options.font].variant;
	    }
	
	    return null;
	};
	
	/**
	 * Functions for handling the different types of groups found in the parse
	 * tree. Each function should take a parse group and return a MathML node.
	 */
	var groupTypes = {};
	
	groupTypes.mathord = function(group, options) {
	    var node = new mathMLTree.MathNode(
	        "mi",
	        [makeText(group.value, group.mode)]);
	
	    var variant = getVariant(group, options);
	    if (variant) {
	        node.setAttribute("mathvariant", variant);
	    }
	    return node;
	};
	
	groupTypes.textord = function(group, options) {
	    var text = makeText(group.value, group.mode);
	
	    var variant = getVariant(group, options) || "normal";
	
	    var node;
	    if (/[0-9]/.test(group.value)) {
	        // TODO(kevinb) merge adjacent <mn> nodes
	        // do it as a post processing step
	        node = new mathMLTree.MathNode("mn", [text]);
	        if (options.font) {
	            node.setAttribute("mathvariant", variant);
	        }
	    } else {
	        node = new mathMLTree.MathNode("mi", [text]);
	        node.setAttribute("mathvariant", variant);
	    }
	
	    return node;
	};
	
	groupTypes.bin = function(group) {
	    var node = new mathMLTree.MathNode(
	        "mo", [makeText(group.value, group.mode)]);
	
	    return node;
	};
	
	groupTypes.rel = function(group) {
	    var node = new mathMLTree.MathNode(
	        "mo", [makeText(group.value, group.mode)]);
	
	    return node;
	};
	
	groupTypes.open = function(group) {
	    var node = new mathMLTree.MathNode(
	        "mo", [makeText(group.value, group.mode)]);
	
	    return node;
	};
	
	groupTypes.close = function(group) {
	    var node = new mathMLTree.MathNode(
	        "mo", [makeText(group.value, group.mode)]);
	
	    return node;
	};
	
	groupTypes.inner = function(group) {
	    var node = new mathMLTree.MathNode(
	        "mo", [makeText(group.value, group.mode)]);
	
	    return node;
	};
	
	groupTypes.punct = function(group) {
	    var node = new mathMLTree.MathNode(
	        "mo", [makeText(group.value, group.mode)]);
	
	    node.setAttribute("separator", "true");
	
	    return node;
	};
	
	groupTypes.ordgroup = function(group, options) {
	    var inner = buildExpression(group.value, options);
	
	    var node = new mathMLTree.MathNode("mrow", inner);
	
	    return node;
	};
	
	groupTypes.text = function(group, options) {
	    var inner = buildExpression(group.value.body, options);
	
	    var node = new mathMLTree.MathNode("mtext", inner);
	
	    return node;
	};
	
	groupTypes.color = function(group, options) {
	    var inner = buildExpression(group.value.value, options);
	
	    var node = new mathMLTree.MathNode("mstyle", inner);
	
	    node.setAttribute("mathcolor", group.value.color);
	
	    return node;
	};
	
	groupTypes.supsub = function(group, options) {
	    var children = [buildGroup(group.value.base, options)];
	
	    if (group.value.sub) {
	        children.push(buildGroup(group.value.sub, options));
	    }
	
	    if (group.value.sup) {
	        children.push(buildGroup(group.value.sup, options));
	    }
	
	    var nodeType;
	    if (!group.value.sub) {
	        nodeType = "msup";
	    } else if (!group.value.sup) {
	        nodeType = "msub";
	    } else {
	        nodeType = "msubsup";
	    }
	
	    var node = new mathMLTree.MathNode(nodeType, children);
	
	    return node;
	};
	
	groupTypes.genfrac = function(group, options) {
	    var node = new mathMLTree.MathNode(
	        "mfrac",
	        [buildGroup(group.value.numer, options),
	            buildGroup(group.value.denom, options)]);
	
	    if (!group.value.hasBarLine) {
	        node.setAttribute("linethickness", "0px");
	    }
	
	    if (group.value.leftDelim != null || group.value.rightDelim != null) {
	        var withDelims = [];
	
	        if (group.value.leftDelim != null) {
	            var leftOp = new mathMLTree.MathNode(
	                "mo", [new mathMLTree.TextNode(group.value.leftDelim)]);
	
	            leftOp.setAttribute("fence", "true");
	
	            withDelims.push(leftOp);
	        }
	
	        withDelims.push(node);
	
	        if (group.value.rightDelim != null) {
	            var rightOp = new mathMLTree.MathNode(
	                "mo", [new mathMLTree.TextNode(group.value.rightDelim)]);
	
	            rightOp.setAttribute("fence", "true");
	
	            withDelims.push(rightOp);
	        }
	
	        var outerNode = new mathMLTree.MathNode("mrow", withDelims);
	
	        return outerNode;
	    }
	
	    return node;
	};
	
	groupTypes.array = function(group, options) {
	    return new mathMLTree.MathNode(
	        "mtable", group.value.body.map(function(row) {
	            return new mathMLTree.MathNode(
	                "mtr", row.map(function(cell) {
	                    return new mathMLTree.MathNode(
	                        "mtd", [buildGroup(cell, options)]);
	                }));
	        }));
	};
	
	groupTypes.sqrt = function(group, options) {
	    var node;
	    if (group.value.index) {
	        node = new mathMLTree.MathNode(
	            "mroot", [
	                buildGroup(group.value.body, options),
	                buildGroup(group.value.index, options)
	            ]);
	    } else {
	        node = new mathMLTree.MathNode(
	            "msqrt", [buildGroup(group.value.body, options)]);
	    }
	
	    return node;
	};
	
	groupTypes.leftright = function(group, options) {
	    var inner = buildExpression(group.value.body, options);
	
	    if (group.value.left !== ".") {
	        var leftNode = new mathMLTree.MathNode(
	            "mo", [makeText(group.value.left, group.mode)]);
	
	        leftNode.setAttribute("fence", "true");
	
	        inner.unshift(leftNode);
	    }
	
	    if (group.value.right !== ".") {
	        var rightNode = new mathMLTree.MathNode(
	            "mo", [makeText(group.value.right, group.mode)]);
	
	        rightNode.setAttribute("fence", "true");
	
	        inner.push(rightNode);
	    }
	
	    var outerNode = new mathMLTree.MathNode("mrow", inner);
	
	    return outerNode;
	};
	
	groupTypes.middle = function(group, options) {
	    var middleNode = new mathMLTree.MathNode(
	        "mo", [makeText(group.value.middle, group.mode)]);
	    middleNode.setAttribute("fence", "true");
	    return middleNode;
	};
	
	groupTypes.accent = function(group, options) {
	    var accentNode = new mathMLTree.MathNode(
	        "mo", [makeText(group.value.accent, group.mode)]);
	
	    var node = new mathMLTree.MathNode(
	        "mover",
	        [buildGroup(group.value.base, options),
	            accentNode]);
	
	    node.setAttribute("accent", "true");
	
	    return node;
	};
	
	groupTypes.spacing = function(group) {
	    var node;
	
	    if (group.value === "\\ " || group.value === "\\space" ||
	        group.value === " " || group.value === "~") {
	        node = new mathMLTree.MathNode(
	            "mtext", [new mathMLTree.TextNode("\u00a0")]);
	    } else {
	        node = new mathMLTree.MathNode("mspace");
	
	        node.setAttribute(
	            "width", buildCommon.spacingFunctions[group.value].size);
	    }
	
	    return node;
	};
	
	groupTypes.op = function(group, options) {
	    var node;
	
	    // TODO(emily): handle big operators using the `largeop` attribute
	
	    if (group.value.symbol) {
	        // This is a symbol. Just add the symbol.
	        node = new mathMLTree.MathNode(
	            "mo", [makeText(group.value.body, group.mode)]);
	    } else if (group.value.value) {
	        // This is an operator with children. Add them.
	        node = new mathMLTree.MathNode(
	            "mo", buildExpression(group.value.value, options));
	    } else {
	        // This is a text operator. Add all of the characters from the
	        // operator's name.
	        // TODO(emily): Add a space in the middle of some of these
	        // operators, like \limsup.
	        node = new mathMLTree.MathNode(
	            "mi", [new mathMLTree.TextNode(group.value.body.slice(1))]);
	    }
	
	    return node;
	};
	
	groupTypes.mod = function(group, options) {
	    var inner = [];
	
	    if (group.value.modType === "pod" || group.value.modType === "pmod") {
	        inner.push(new mathMLTree.MathNode(
	            "mo", [makeText("(", group.mode)]));
	    }
	    if (group.value.modType !== "pod") {
	        inner.push(new mathMLTree.MathNode(
	            "mo", [makeText("mod", group.mode)]));
	    }
	    if (group.value.value) {
	        var space = new mathMLTree.MathNode("mspace");
	        space.setAttribute("width", "0.333333em");
	        inner.push(space);
	        inner = inner.concat(buildExpression(group.value.value, options));
	    }
	    if (group.value.modType === "pod" || group.value.modType === "pmod") {
	        inner.push(new mathMLTree.MathNode(
	            "mo", [makeText(")", group.mode)]));
	    }
	
	    return new mathMLTree.MathNode("mo", inner);
	};
	
	groupTypes.katex = function(group) {
	    var node = new mathMLTree.MathNode(
	        "mtext", [new mathMLTree.TextNode("KaTeX")]);
	
	    return node;
	};
	
	groupTypes.font = function(group, options) {
	    var font = group.value.font;
	    return buildGroup(group.value.body, options.withFont(font));
	};
	
	groupTypes.delimsizing = function(group) {
	    var children = [];
	
	    if (group.value.value !== ".") {
	        children.push(makeText(group.value.value, group.mode));
	    }
	
	    var node = new mathMLTree.MathNode("mo", children);
	
	    if (group.value.mclass === "mopen" ||
	        group.value.mclass === "mclose") {
	        // Only some of the delimsizing functions act as fences, and they
	        // return "mopen" or "mclose" mclass.
	        node.setAttribute("fence", "true");
	    } else {
	        // Explicitly disable fencing if it's not a fence, to override the
	        // defaults.
	        node.setAttribute("fence", "false");
	    }
	
	    return node;
	};
	
	groupTypes.styling = function(group, options) {
	    var inner = buildExpression(group.value.value, options);
	
	    var node = new mathMLTree.MathNode("mstyle", inner);
	
	    var styleAttributes = {
	        "display": ["0", "true"],
	        "text": ["0", "false"],
	        "script": ["1", "false"],
	        "scriptscript": ["2", "false"]
	    };
	
	    var attr = styleAttributes[group.value.style];
	
	    node.setAttribute("scriptlevel", attr[0]);
	    node.setAttribute("displaystyle", attr[1]);
	
	    return node;
	};
	
	groupTypes.sizing = function(group, options) {
	    var inner = buildExpression(group.value.value, options);
	
	    var node = new mathMLTree.MathNode("mstyle", inner);
	
	    // TODO(emily): This doesn't produce the correct size for nested size
	    // changes, because we don't keep state of what style we're currently
	    // in, so we can't reset the size to normal before changing it.  Now
	    // that we're passing an options parameter we should be able to fix
	    // this.
	    node.setAttribute(
	        "mathsize", buildCommon.sizingMultiplier[group.value.size] + "em");
	
	    return node;
	};
	
	groupTypes.overline = function(group, options) {
	    var operator = new mathMLTree.MathNode(
	        "mo", [new mathMLTree.TextNode("\u203e")]);
	    operator.setAttribute("stretchy", "true");
	
	    var node = new mathMLTree.MathNode(
	        "mover",
	        [buildGroup(group.value.body, options),
	            operator]);
	    node.setAttribute("accent", "true");
	
	    return node;
	};
	
	groupTypes.underline = function(group, options) {
	    var operator = new mathMLTree.MathNode(
	        "mo", [new mathMLTree.TextNode("\u203e")]);
	    operator.setAttribute("stretchy", "true");
	
	    var node = new mathMLTree.MathNode(
	        "munder",
	        [buildGroup(group.value.body, options),
	            operator]);
	    node.setAttribute("accentunder", "true");
	
	    return node;
	};
	
	groupTypes.rule = function(group) {
	    // TODO(emily): Figure out if there's an actual way to draw black boxes
	    // in MathML.
	    var node = new mathMLTree.MathNode("mrow");
	
	    return node;
	};
	
	groupTypes.kern = function(group) {
	    // TODO(kevin): Figure out if there's a way to add space in MathML
	    var node = new mathMLTree.MathNode("mrow");
	
	    return node;
	};
	
	groupTypes.llap = function(group, options) {
	    var node = new mathMLTree.MathNode(
	        "mpadded", [buildGroup(group.value.body, options)]);
	
	    node.setAttribute("lspace", "-1width");
	    node.setAttribute("width", "0px");
	
	    return node;
	};
	
	groupTypes.rlap = function(group, options) {
	    var node = new mathMLTree.MathNode(
	        "mpadded", [buildGroup(group.value.body, options)]);
	
	    node.setAttribute("width", "0px");
	
	    return node;
	};
	
	groupTypes.phantom = function(group, options) {
	    var inner = buildExpression(group.value.value, options);
	    return new mathMLTree.MathNode("mphantom", inner);
	};
	
	groupTypes.mclass = function(group, options) {
	    var inner = buildExpression(group.value.value, options);
	    return new mathMLTree.MathNode("mstyle", inner);
	};
	
	/**
	 * Takes a list of nodes, builds them, and returns a list of the generated
	 * MathML nodes. A little simpler than the HTML version because we don't do any
	 * previous-node handling.
	 */
	var buildExpression = function(expression, options) {
	    var groups = [];
	    for (var i = 0; i < expression.length; i++) {
	        var group = expression[i];
	        groups.push(buildGroup(group, options));
	    }
	    return groups;
	};
	
	/**
	 * Takes a group from the parser and calls the appropriate groupTypes function
	 * on it to produce a MathML node.
	 */
	var buildGroup = function(group, options) {
	    if (!group) {
	        return new mathMLTree.MathNode("mrow");
	    }
	
	    if (groupTypes[group.type]) {
	        // Call the groupTypes function
	        return groupTypes[group.type](group, options);
	    } else {
	        throw new ParseError(
	            "Got group of unknown type: '" + group.type + "'");
	    }
	};
	
	/**
	 * Takes a full parse tree and settings and builds a MathML representation of
	 * it. In particular, we put the elements from building the parse tree into a
	 * <semantics> tag so we can also include that TeX source as an annotation.
	 *
	 * Note that we actually return a domTree element with a `<math>` inside it so
	 * we can do appropriate styling.
	 */
	var buildMathML = function(tree, texExpression, options) {
	    var expression = buildExpression(tree, options);
	
	    // Wrap up the expression in an mrow so it is presented in the semantics
	    // tag correctly.
	    var wrapper = new mathMLTree.MathNode("mrow", expression);
	
	    // Build a TeX annotation of the source
	    var annotation = new mathMLTree.MathNode(
	        "annotation", [new mathMLTree.TextNode(texExpression)]);
	
	    annotation.setAttribute("encoding", "application/x-tex");
	
	    var semantics = new mathMLTree.MathNode(
	        "semantics", [wrapper, annotation]);
	
	    var math = new mathMLTree.MathNode("math", [semantics]);
	
	    // You can't style <math> nodes, so we wrap the node in a span.
	    return makeSpan(["katex-mathml"], [math]);
	};
	
	module.exports = buildMathML;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * These objects store data about MathML nodes. This is the MathML equivalent
	 * of the types in domTree.js. Since MathML handles its own rendering, and
	 * since we're mainly using MathML to improve accessibility, we don't manage
	 * any of the styling state that the plain DOM nodes do.
	 *
	 * The `toNode` and `toMarkup` functions work simlarly to how they do in
	 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
	 */
	
	var utils = __webpack_require__(115);
	
	/**
	 * This node represents a general purpose MathML node of any type. The
	 * constructor requires the type of node to create (for example, `"mo"` or
	 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
	 */
	function MathNode(type, children) {
	    this.type = type;
	    this.attributes = {};
	    this.children = children || [];
	}
	
	/**
	 * Sets an attribute on a MathML node. MathML depends on attributes to convey a
	 * semantic content, so this is used heavily.
	 */
	MathNode.prototype.setAttribute = function(name, value) {
	    this.attributes[name] = value;
	};
	
	/**
	 * Converts the math node into a MathML-namespaced DOM element.
	 */
	MathNode.prototype.toNode = function() {
	    var node = document.createElementNS(
	        "http://www.w3.org/1998/Math/MathML", this.type);
	
	    for (var attr in this.attributes) {
	        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
	            node.setAttribute(attr, this.attributes[attr]);
	        }
	    }
	
	    for (var i = 0; i < this.children.length; i++) {
	        node.appendChild(this.children[i].toNode());
	    }
	
	    return node;
	};
	
	/**
	 * Converts the math node into an HTML markup string.
	 */
	MathNode.prototype.toMarkup = function() {
	    var markup = "<" + this.type;
	
	    // Add the attributes
	    for (var attr in this.attributes) {
	        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
	            markup += " " + attr + "=\"";
	            markup += utils.escape(this.attributes[attr]);
	            markup += "\"";
	        }
	    }
	
	    markup += ">";
	
	    for (var i = 0; i < this.children.length; i++) {
	        markup += this.children[i].toMarkup();
	    }
	
	    markup += "</" + this.type + ">";
	
	    return markup;
	};
	
	/**
	 * This node represents a piece of text.
	 */
	function TextNode(text) {
	    this.text = text;
	}
	
	/**
	 * Converts the text node into a DOM text node.
	 */
	TextNode.prototype.toNode = function() {
	    return document.createTextNode(this.text);
	};
	
	/**
	 * Converts the text node into HTML markup (which is just the text itself).
	 */
	TextNode.prototype.toMarkup = function() {
	    return utils.escape(this.text);
	};
	
	module.exports = {
	    MathNode: MathNode,
	    TextNode: TextNode
	};


/***/ }),
/* 120 */
/***/ (function(module, exports) {

	/**
	 * This file contains information about the options that the Parser carries
	 * around with it while parsing. Data is held in an `Options` object, and when
	 * recursing, a new `Options` object can be created with the `.with*` and
	 * `.reset` functions.
	 */
	
	/**
	 * This is the main options class. It contains the style, size, color, and font
	 * of the current parse level. It also contains the style and size of the parent
	 * parse level, so size changes can be handled efficiently.
	 *
	 * Each of the `.with*` and `.reset` functions passes its current style and size
	 * as the parentStyle and parentSize of the new options class, so parent
	 * handling is taken care of automatically.
	 */
	function Options(data) {
	    this.style = data.style;
	    this.color = data.color;
	    this.size = data.size;
	    this.phantom = data.phantom;
	    this.font = data.font;
	
	    if (data.parentStyle === undefined) {
	        this.parentStyle = data.style;
	    } else {
	        this.parentStyle = data.parentStyle;
	    }
	
	    if (data.parentSize === undefined) {
	        this.parentSize = data.size;
	    } else {
	        this.parentSize = data.parentSize;
	    }
	}
	
	/**
	 * Returns a new options object with the same properties as "this".  Properties
	 * from "extension" will be copied to the new options object.
	 */
	Options.prototype.extend = function(extension) {
	    var data = {
	        style: this.style,
	        size: this.size,
	        color: this.color,
	        parentStyle: this.style,
	        parentSize: this.size,
	        phantom: this.phantom,
	        font: this.font
	    };
	
	    for (var key in extension) {
	        if (extension.hasOwnProperty(key)) {
	            data[key] = extension[key];
	        }
	    }
	
	    return new Options(data);
	};
	
	/**
	 * Create a new options object with the given style.
	 */
	Options.prototype.withStyle = function(style) {
	    return this.extend({
	        style: style
	    });
	};
	
	/**
	 * Create a new options object with the given size.
	 */
	Options.prototype.withSize = function(size) {
	    return this.extend({
	        size: size
	    });
	};
	
	/**
	 * Create a new options object with the given color.
	 */
	Options.prototype.withColor = function(color) {
	    return this.extend({
	        color: color
	    });
	};
	
	/**
	 * Create a new options object with "phantom" set to true.
	 */
	Options.prototype.withPhantom = function() {
	    return this.extend({
	        phantom: true
	    });
	};
	
	/**
	 * Create a new options objects with the give font.
	 */
	Options.prototype.withFont = function(font) {
	    return this.extend({
	        font: font || this.font
	    });
	};
	
	/**
	 * Create a new options object with the same style, size, and color. This is
	 * used so that parent style and size changes are handled correctly.
	 */
	Options.prototype.reset = function() {
	    return this.extend({});
	};
	
	/**
	 * A map of color names to CSS colors.
	 * TODO(emily): Remove this when we have real macros
	 */
	var colorMap = {
	    "katex-blue": "#6495ed",
	    "katex-orange": "#ffa500",
	    "katex-pink": "#ff00af",
	    "katex-red": "#df0030",
	    "katex-green": "#28ae7b",
	    "katex-gray": "gray",
	    "katex-purple": "#9d38bd",
	    "katex-blueA": "#ccfaff",
	    "katex-blueB": "#80f6ff",
	    "katex-blueC": "#63d9ea",
	    "katex-blueD": "#11accd",
	    "katex-blueE": "#0c7f99",
	    "katex-tealA": "#94fff5",
	    "katex-tealB": "#26edd5",
	    "katex-tealC": "#01d1c1",
	    "katex-tealD": "#01a995",
	    "katex-tealE": "#208170",
	    "katex-greenA": "#b6ffb0",
	    "katex-greenB": "#8af281",
	    "katex-greenC": "#74cf70",
	    "katex-greenD": "#1fab54",
	    "katex-greenE": "#0d923f",
	    "katex-goldA": "#ffd0a9",
	    "katex-goldB": "#ffbb71",
	    "katex-goldC": "#ff9c39",
	    "katex-goldD": "#e07d10",
	    "katex-goldE": "#a75a05",
	    "katex-redA": "#fca9a9",
	    "katex-redB": "#ff8482",
	    "katex-redC": "#f9685d",
	    "katex-redD": "#e84d39",
	    "katex-redE": "#bc2612",
	    "katex-maroonA": "#ffbde0",
	    "katex-maroonB": "#ff92c6",
	    "katex-maroonC": "#ed5fa6",
	    "katex-maroonD": "#ca337c",
	    "katex-maroonE": "#9e034e",
	    "katex-purpleA": "#ddd7ff",
	    "katex-purpleB": "#c6b9fc",
	    "katex-purpleC": "#aa87ff",
	    "katex-purpleD": "#7854ab",
	    "katex-purpleE": "#543b78",
	    "katex-mintA": "#f5f9e8",
	    "katex-mintB": "#edf2df",
	    "katex-mintC": "#e0e5cc",
	    "katex-grayA": "#f6f7f7",
	    "katex-grayB": "#f0f1f2",
	    "katex-grayC": "#e3e5e6",
	    "katex-grayD": "#d6d8da",
	    "katex-grayE": "#babec2",
	    "katex-grayF": "#888d93",
	    "katex-grayG": "#626569",
	    "katex-grayH": "#3b3e40",
	    "katex-grayI": "#21242c",
	    "katex-kaBlue": "#314453",
	    "katex-kaGreen": "#71B307"
	};
	
	/**
	 * Gets the CSS color of the current options object, accounting for the
	 * `colorMap`.
	 */
	Options.prototype.getColor = function() {
	    if (this.phantom) {
	        return "transparent";
	    } else {
	        return colorMap[this.color] || this.color;
	    }
	};
	
	module.exports = Options;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Provides a single function for parsing an expression using a Parser
	 * TODO(emily): Remove this
	 */
	
	var Parser = __webpack_require__(122);
	
	/**
	 * Parses an expression using a Parser, then returns the parsed result.
	 */
	var parseTree = function(toParse, settings) {
	    if (!(typeof toParse === 'string' || toParse instanceof String)) {
	        throw new TypeError('KaTeX can only parse string typed expression');
	    }
	    var parser = new Parser(toParse, settings);
	
	    return parser.parse();
	};
	
	module.exports = parseTree;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-constant-condition:0 */
	var functions = __webpack_require__(123);
	var environments = __webpack_require__(125);
	var MacroExpander = __webpack_require__(126);
	var symbols = __webpack_require__(116);
	var utils = __webpack_require__(115);
	var cjkRegex = __webpack_require__(111).cjkRegex;
	
	var parseData = __webpack_require__(124);
	var ParseError = __webpack_require__(105);
	
	/**
	 * This file contains the parser used to parse out a TeX expression from the
	 * input. Since TeX isn't context-free, standard parsers don't work particularly
	 * well.
	 *
	 * The strategy of this parser is as such:
	 *
	 * The main functions (the `.parse...` ones) take a position in the current
	 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
	 * this.lexer) also supports pulling out tokens at arbitrary places. When
	 * individual tokens are needed at a position, the lexer is called to pull out a
	 * token, which is then used.
	 *
	 * The parser has a property called "mode" indicating the mode that
	 * the parser is currently in. Currently it has to be one of "math" or
	 * "text", which denotes whether the current environment is a math-y
	 * one or a text-y one (e.g. inside \text). Currently, this serves to
	 * limit the functions which can be used in text mode.
	 *
	 * The main functions then return an object which contains the useful data that
	 * was parsed at its given point, and a new position at the end of the parsed
	 * data. The main functions can call each other and continue the parsing by
	 * using the returned position as a new starting point.
	 *
	 * There are also extra `.handle...` functions, which pull out some reused
	 * functionality into self-contained functions.
	 *
	 * The earlier functions return ParseNodes.
	 * The later functions (which are called deeper in the parse) sometimes return
	 * ParseFuncOrArgument, which contain a ParseNode as well as some data about
	 * whether the parsed object is a function which is missing some arguments, or a
	 * standalone object which can be used as an argument to another function.
	 */
	
	/**
	 * Main Parser class
	 */
	function Parser(input, settings) {
	    // Create a new macro expander (gullet) and (indirectly via that) also a
	    // new lexer (mouth) for this parser (stomach, in the language of TeX)
	    this.gullet = new MacroExpander(input, settings.macros);
	    // Store the settings for use in parsing
	    this.settings = settings;
	    // Count leftright depth (for \middle errors)
	    this.leftrightDepth = 0;
	}
	
	var ParseNode = parseData.ParseNode;
	
	/**
	 * An initial function (without its arguments), or an argument to a function.
	 * The `result` argument should be a ParseNode.
	 */
	function ParseFuncOrArgument(result, isFunction, token) {
	    this.result = result;
	    // Is this a function (i.e. is it something defined in functions.js)?
	    this.isFunction = isFunction;
	    this.token = token;
	}
	
	/**
	 * Checks a result to make sure it has the right type, and throws an
	 * appropriate error otherwise.
	 *
	 * @param {boolean=} consume whether to consume the expected token,
	 *                           defaults to true
	 */
	Parser.prototype.expect = function(text, consume) {
	    if (this.nextToken.text !== text) {
	        throw new ParseError(
	            "Expected '" + text + "', got '" + this.nextToken.text + "'",
	            this.nextToken
	        );
	    }
	    if (consume !== false) {
	        this.consume();
	    }
	};
	
	/**
	 * Considers the current look ahead token as consumed,
	 * and fetches the one after that as the new look ahead.
	 */
	Parser.prototype.consume = function() {
	    this.nextToken = this.gullet.get(this.mode === "math");
	};
	
	Parser.prototype.switchMode = function(newMode) {
	    this.gullet.unget(this.nextToken);
	    this.mode = newMode;
	    this.consume();
	};
	
	/**
	 * Main parsing function, which parses an entire input.
	 *
	 * @return {?Array.<ParseNode>}
	 */
	Parser.prototype.parse = function() {
	    // Try to parse the input
	    this.mode = "math";
	    this.consume();
	    var parse = this.parseInput();
	    return parse;
	};
	
	/**
	 * Parses an entire input tree.
	 */
	Parser.prototype.parseInput = function() {
	    // Parse an expression
	    var expression = this.parseExpression(false);
	    // If we succeeded, make sure there's an EOF at the end
	    this.expect("EOF", false);
	    return expression;
	};
	
	var endOfExpression = ["}", "\\end", "\\right", "&", "\\\\", "\\cr"];
	
	/**
	 * Parses an "expression", which is a list of atoms.
	 *
	 * @param {boolean} breakOnInfix  Should the parsing stop when we hit infix
	 *                  nodes? This happens when functions have higher precendence
	 *                  than infix nodes in implicit parses.
	 *
	 * @param {?string} breakOnTokenText  The text of the token that the expression
	 *                  should end with, or `null` if something else should end the
	 *                  expression.
	 *
	 * @return {ParseNode}
	 */
	Parser.prototype.parseExpression = function(breakOnInfix, breakOnTokenText) {
	    var body = [];
	    // Keep adding atoms to the body until we can't parse any more atoms (either
	    // we reached the end, a }, or a \right)
	    while (true) {
	        var lex = this.nextToken;
	        if (endOfExpression.indexOf(lex.text) !== -1) {
	            break;
	        }
	        if (breakOnTokenText && lex.text === breakOnTokenText) {
	            break;
	        }
	        if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
	            break;
	        }
	        var atom = this.parseAtom();
	        if (!atom) {
	            if (!this.settings.throwOnError && lex.text[0] === "\\") {
	                var errorNode = this.handleUnsupportedCmd();
	                body.push(errorNode);
	                continue;
	            }
	
	            break;
	        }
	        body.push(atom);
	    }
	    return this.handleInfixNodes(body);
	};
	
	/**
	 * Rewrites infix operators such as \over with corresponding commands such
	 * as \frac.
	 *
	 * There can only be one infix operator per group.  If there's more than one
	 * then the expression is ambiguous.  This can be resolved by adding {}.
	 *
	 * @returns {Array}
	 */
	Parser.prototype.handleInfixNodes = function(body) {
	    var overIndex = -1;
	    var funcName;
	
	    for (var i = 0; i < body.length; i++) {
	        var node = body[i];
	        if (node.type === "infix") {
	            if (overIndex !== -1) {
	                throw new ParseError(
	                    "only one infix operator per group",
	                    node.value.token);
	            }
	            overIndex = i;
	            funcName = node.value.replaceWith;
	        }
	    }
	
	    if (overIndex !== -1) {
	        var numerNode;
	        var denomNode;
	
	        var numerBody = body.slice(0, overIndex);
	        var denomBody = body.slice(overIndex + 1);
	
	        if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
	            numerNode = numerBody[0];
	        } else {
	            numerNode = new ParseNode("ordgroup", numerBody, this.mode);
	        }
	
	        if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
	            denomNode = denomBody[0];
	        } else {
	            denomNode = new ParseNode("ordgroup", denomBody, this.mode);
	        }
	
	        var value = this.callFunction(
	            funcName, [numerNode, denomNode], null);
	        return [new ParseNode(value.type, value, this.mode)];
	    } else {
	        return body;
	    }
	};
	
	// The greediness of a superscript or subscript
	var SUPSUB_GREEDINESS = 1;
	
	/**
	 * Handle a subscript or superscript with nice errors.
	 */
	Parser.prototype.handleSupSubscript = function(name) {
	    var symbolToken = this.nextToken;
	    var symbol = symbolToken.text;
	    this.consume();
	    var group = this.parseGroup();
	
	    if (!group) {
	        if (!this.settings.throwOnError && this.nextToken.text[0] === "\\") {
	            return this.handleUnsupportedCmd();
	        } else {
	            throw new ParseError(
	                "Expected group after '" + symbol + "'",
	                symbolToken
	            );
	        }
	    } else if (group.isFunction) {
	        // ^ and _ have a greediness, so handle interactions with functions'
	        // greediness
	        var funcGreediness = functions[group.result].greediness;
	        if (funcGreediness > SUPSUB_GREEDINESS) {
	            return this.parseFunction(group);
	        } else {
	            throw new ParseError(
	                "Got function '" + group.result + "' with no arguments " +
	                    "as " + name, symbolToken);
	        }
	    } else {
	        return group.result;
	    }
	};
	
	/**
	 * Converts the textual input of an unsupported command into a text node
	 * contained within a color node whose color is determined by errorColor
	 */
	Parser.prototype.handleUnsupportedCmd = function() {
	    var text = this.nextToken.text;
	    var textordArray = [];
	
	    for (var i = 0; i < text.length; i++) {
	        textordArray.push(new ParseNode("textord", text[i], "text"));
	    }
	
	    var textNode = new ParseNode(
	        "text",
	        {
	            body: textordArray,
	            type: "text"
	        },
	        this.mode);
	
	    var colorNode = new ParseNode(
	        "color",
	        {
	            color: this.settings.errorColor,
	            value: [textNode],
	            type: "color"
	        },
	        this.mode);
	
	    this.consume();
	    return colorNode;
	};
	
	/**
	 * Parses a group with optional super/subscripts.
	 *
	 * @return {?ParseNode}
	 */
	Parser.prototype.parseAtom = function() {
	    // The body of an atom is an implicit group, so that things like
	    // \left(x\right)^2 work correctly.
	    var base = this.parseImplicitGroup();
	
	    // In text mode, we don't have superscripts or subscripts
	    if (this.mode === "text") {
	        return base;
	    }
	
	    // Note that base may be empty (i.e. null) at this point.
	
	    var superscript;
	    var subscript;
	    while (true) {
	        // Lex the first token
	        var lex = this.nextToken;
	
	        if (lex.text === "\\limits" || lex.text === "\\nolimits") {
	            // We got a limit control
	            if (!base || base.type !== "op") {
	                throw new ParseError(
	                    "Limit controls must follow a math operator",
	                    lex);
	            } else {
	                var limits = lex.text === "\\limits";
	                base.value.limits = limits;
	                base.value.alwaysHandleSupSub = true;
	            }
	            this.consume();
	        } else if (lex.text === "^") {
	            // We got a superscript start
	            if (superscript) {
	                throw new ParseError("Double superscript", lex);
	            }
	            superscript = this.handleSupSubscript("superscript");
	        } else if (lex.text === "_") {
	            // We got a subscript start
	            if (subscript) {
	                throw new ParseError("Double subscript", lex);
	            }
	            subscript = this.handleSupSubscript("subscript");
	        } else if (lex.text === "'") {
	            // We got a prime
	            var prime = new ParseNode("textord", "\\prime", this.mode);
	
	            // Many primes can be grouped together, so we handle this here
	            var primes = [prime];
	            this.consume();
	            // Keep lexing tokens until we get something that's not a prime
	            while (this.nextToken.text === "'") {
	                // For each one, add another prime to the list
	                primes.push(prime);
	                this.consume();
	            }
	            // Put them into an ordgroup as the superscript
	            superscript = new ParseNode("ordgroup", primes, this.mode);
	        } else {
	            // If it wasn't ^, _, or ', stop parsing super/subscripts
	            break;
	        }
	    }
	
	    if (superscript || subscript) {
	        // If we got either a superscript or subscript, create a supsub
	        return new ParseNode("supsub", {
	            base: base,
	            sup: superscript,
	            sub: subscript
	        }, this.mode);
	    } else {
	        // Otherwise return the original body
	        return base;
	    }
	};
	
	// A list of the size-changing functions, for use in parseImplicitGroup
	var sizeFuncs = [
	    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize",
	    "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
	];
	
	// A list of the style-changing functions, for use in parseImplicitGroup
	var styleFuncs = [
	    "\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"
	];
	
	/**
	 * Parses an implicit group, which is a group that starts at the end of a
	 * specified, and ends right before a higher explicit group ends, or at EOL. It
	 * is used for functions that appear to affect the current style, like \Large or
	 * \textrm, where instead of keeping a style we just pretend that there is an
	 * implicit grouping after it until the end of the group. E.g.
	 *   small text {\Large large text} small text again
	 * It is also used for \left and \right to get the correct grouping.
	 *
	 * @return {?ParseNode}
	 */
	Parser.prototype.parseImplicitGroup = function() {
	    var start = this.parseSymbol();
	
	    if (start == null) {
	        // If we didn't get anything we handle, fall back to parseFunction
	        return this.parseFunction();
	    }
	
	    var func = start.result;
	    var body;
	
	    if (func === "\\left") {
	        // If we see a left:
	        // Parse the entire left function (including the delimiter)
	        var left = this.parseFunction(start);
	        // Parse out the implicit body
	        ++this.leftrightDepth;
	        body = this.parseExpression(false);
	        --this.leftrightDepth;
	        // Check the next token
	        this.expect("\\right", false);
	        var right = this.parseFunction();
	        return new ParseNode("leftright", {
	            body: body,
	            left: left.value.value,
	            right: right.value.value
	        }, this.mode);
	    } else if (func === "\\begin") {
	        // begin...end is similar to left...right
	        var begin = this.parseFunction(start);
	        var envName = begin.value.name;
	        if (!environments.hasOwnProperty(envName)) {
	            throw new ParseError(
	                "No such environment: " + envName, begin.value.nameGroup);
	        }
	        // Build the environment object. Arguments and other information will
	        // be made available to the begin and end methods using properties.
	        var env = environments[envName];
	        var args = this.parseArguments("\\begin{" + envName + "}", env);
	        var context = {
	            mode: this.mode,
	            envName: envName,
	            parser: this,
	            positions: args.pop()
	        };
	        var result = env.handler(context, args);
	        this.expect("\\end", false);
	        var endNameToken = this.nextToken;
	        var end = this.parseFunction();
	        if (end.value.name !== envName) {
	            throw new ParseError(
	                "Mismatch: \\begin{" + envName + "} matched " +
	                "by \\end{" + end.value.name + "}",
	                endNameToken);
	        }
	        result.position = end.position;
	        return result;
	    } else if (utils.contains(sizeFuncs, func)) {
	        // If we see a sizing function, parse out the implict body
	        body = this.parseExpression(false);
	        return new ParseNode("sizing", {
	            // Figure out what size to use based on the list of functions above
	            size: "size" + (utils.indexOf(sizeFuncs, func) + 1),
	            value: body
	        }, this.mode);
	    } else if (utils.contains(styleFuncs, func)) {
	        // If we see a styling function, parse out the implict body
	        body = this.parseExpression(true);
	        return new ParseNode("styling", {
	            // Figure out what style to use by pulling out the style from
	            // the function name
	            style: func.slice(1, func.length - 5),
	            value: body
	        }, this.mode);
	    } else {
	        // Defer to parseFunction if it's not a function we handle
	        return this.parseFunction(start);
	    }
	};
	
	/**
	 * Parses an entire function, including its base and all of its arguments.
	 * The base might either have been parsed already, in which case
	 * it is provided as an argument, or it's the next group in the input.
	 *
	 * @param {ParseFuncOrArgument=} baseGroup optional as described above
	 * @return {?ParseNode}
	 */
	Parser.prototype.parseFunction = function(baseGroup) {
	    if (!baseGroup) {
	        baseGroup = this.parseGroup();
	    }
	
	    if (baseGroup) {
	        if (baseGroup.isFunction) {
	            var func = baseGroup.result;
	            var funcData = functions[func];
	            if (this.mode === "text" && !funcData.allowedInText) {
	                throw new ParseError(
	                    "Can't use function '" + func + "' in text mode",
	                    baseGroup.token);
	            }
	
	            var args = this.parseArguments(func, funcData);
	            var token = baseGroup.token;
	            var result = this.callFunction(func, args, args.pop(), token);
	            return new ParseNode(result.type, result, this.mode);
	        } else {
	            return baseGroup.result;
	        }
	    } else {
	        return null;
	    }
	};
	
	/**
	 * Call a function handler with a suitable context and arguments.
	 */
	Parser.prototype.callFunction = function(name, args, positions, token) {
	    var context = {
	        funcName: name,
	        parser: this,
	        positions: positions,
	        token: token
	    };
	    return functions[name].handler(context, args);
	};
	
	/**
	 * Parses the arguments of a function or environment
	 *
	 * @param {string} func  "\name" or "\begin{name}"
	 * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData
	 * @return the array of arguments, with the list of positions as last element
	 */
	Parser.prototype.parseArguments = function(func, funcData) {
	    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
	    if (totalArgs === 0) {
	        return [[this.pos]];
	    }
	
	    var baseGreediness = funcData.greediness;
	    var positions = [this.pos];
	    var args = [];
	
	    for (var i = 0; i < totalArgs; i++) {
	        var nextToken = this.nextToken;
	        var argType = funcData.argTypes && funcData.argTypes[i];
	        var arg;
	        if (i < funcData.numOptionalArgs) {
	            if (argType) {
	                arg = this.parseGroupOfType(argType, true);
	            } else {
	                arg = this.parseGroup(true);
	            }
	            if (!arg) {
	                args.push(null);
	                positions.push(this.pos);
	                continue;
	            }
	        } else {
	            if (argType) {
	                arg = this.parseGroupOfType(argType);
	            } else {
	                arg = this.parseGroup();
	            }
	            if (!arg) {
	                if (!this.settings.throwOnError &&
	                    this.nextToken.text[0] === "\\") {
	                    arg = new ParseFuncOrArgument(
	                        this.handleUnsupportedCmd(this.nextToken.text),
	                        false);
	                } else {
	                    throw new ParseError(
	                        "Expected group after '" + func + "'", nextToken);
	                }
	            }
	        }
	        var argNode;
	        if (arg.isFunction) {
	            var argGreediness =
	                functions[arg.result].greediness;
	            if (argGreediness > baseGreediness) {
	                argNode = this.parseFunction(arg);
	            } else {
	                throw new ParseError(
	                    "Got function '" + arg.result + "' as " +
	                    "argument to '" + func + "'", nextToken);
	            }
	        } else {
	            argNode = arg.result;
	        }
	        args.push(argNode);
	        positions.push(this.pos);
	    }
	
	    args.push(positions);
	
	    return args;
	};
	
	
	/**
	 * Parses a group when the mode is changing.
	 *
	 * @return {?ParseFuncOrArgument}
	 */
	Parser.prototype.parseGroupOfType = function(innerMode, optional) {
	    var outerMode = this.mode;
	    // Handle `original` argTypes
	    if (innerMode === "original") {
	        innerMode = outerMode;
	    }
	
	    if (innerMode === "color") {
	        return this.parseColorGroup(optional);
	    }
	    if (innerMode === "size") {
	        return this.parseSizeGroup(optional);
	    }
	
	    this.switchMode(innerMode);
	    if (innerMode === "text") {
	        // text mode is special because it should ignore the whitespace before
	        // it
	        while (this.nextToken.text === " ") {
	            this.consume();
	        }
	    }
	    // By the time we get here, innerMode is one of "text" or "math".
	    // We switch the mode of the parser, recurse, then restore the old mode.
	    var res = this.parseGroup(optional);
	    this.switchMode(outerMode);
	    return res;
	};
	
	/**
	 * Parses a group, essentially returning the string formed by the
	 * brace-enclosed tokens plus some position information.
	 *
	 * @param {string} modeName  Used to describe the mode in error messages
	 * @param {boolean=} optional  Whether the group is optional or required
	 */
	Parser.prototype.parseStringGroup = function(modeName, optional) {
	    if (optional && this.nextToken.text !== "[") {
	        return null;
	    }
	    var outerMode = this.mode;
	    this.mode = "text";
	    this.expect(optional ? "[" : "{");
	    var str = "";
	    var firstToken = this.nextToken;
	    var lastToken = firstToken;
	    while (this.nextToken.text !== (optional ? "]" : "}")) {
	        if (this.nextToken.text === "EOF") {
	            throw new ParseError(
	                "Unexpected end of input in " + modeName,
	                firstToken.range(this.nextToken, str));
	        }
	        lastToken = this.nextToken;
	        str += lastToken.text;
	        this.consume();
	    }
	    this.mode = outerMode;
	    this.expect(optional ? "]" : "}");
	    return firstToken.range(lastToken, str);
	};
	
	/**
	 * Parses a regex-delimited group: the largest sequence of tokens
	 * whose concatenated strings match `regex`. Returns the string
	 * formed by the tokens plus some position information.
	 *
	 * @param {RegExp} regex
	 * @param {string} modeName  Used to describe the mode in error messages
	 */
	Parser.prototype.parseRegexGroup = function(regex, modeName) {
	    var outerMode = this.mode;
	    this.mode = "text";
	    var firstToken = this.nextToken;
	    var lastToken = firstToken;
	    var str = "";
	    while (this.nextToken.text !== "EOF"
	           && regex.test(str + this.nextToken.text)) {
	        lastToken = this.nextToken;
	        str += lastToken.text;
	        this.consume();
	    }
	    if (str === "") {
	        throw new ParseError(
	            "Invalid " + modeName + ": '" + firstToken.text + "'",
	            firstToken);
	    }
	    this.mode = outerMode;
	    return firstToken.range(lastToken, str);
	};
	
	/**
	 * Parses a color description.
	 */
	Parser.prototype.parseColorGroup = function(optional) {
	    var res = this.parseStringGroup("color", optional);
	    if (!res) {
	        return null;
	    }
	    var match = (/^(#[a-z0-9]+|[a-z]+)$/i).exec(res.text);
	    if (!match) {
	        throw new ParseError("Invalid color: '" + res.text + "'", res);
	    }
	    return new ParseFuncOrArgument(
	        new ParseNode("color", match[0], this.mode),
	        false);
	};
	
	/**
	 * Parses a size specification, consisting of magnitude and unit.
	 */
	Parser.prototype.parseSizeGroup = function(optional) {
	    var res;
	    if (!optional && this.nextToken.text !== "{") {
	        res = this.parseRegexGroup(
	            /^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2}$/, "size");
	    } else {
	        res = this.parseStringGroup("size", optional);
	    }
	    if (!res) {
	        return null;
	    }
	    var match = (/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/).exec(res.text);
	    if (!match) {
	        throw new ParseError("Invalid size: '" + res.text + "'", res);
	    }
	    var data = {
	        number: +(match[1] + match[2]), // sign + magnitude, cast to number
	        unit: match[3]
	    };
	    if (data.unit !== "em" && data.unit !== "ex" && data.unit !== "mu") {
	        throw new ParseError("Invalid unit: '" + data.unit + "'", res);
	    }
	    return new ParseFuncOrArgument(
	        new ParseNode("color", data, this.mode),
	        false);
	};
	
	/**
	 * If the argument is false or absent, this parses an ordinary group,
	 * which is either a single nucleus (like "x") or an expression
	 * in braces (like "{x+y}").
	 * If the argument is true, it parses either a bracket-delimited expression
	 * (like "[x+y]") or returns null to indicate the absence of a
	 * bracket-enclosed group.
	 *
	 * @param {boolean=} optional  Whether the group is optional or required
	 * @return {?ParseFuncOrArgument}
	 */
	Parser.prototype.parseGroup = function(optional) {
	    var firstToken = this.nextToken;
	    // Try to parse an open brace
	    if (this.nextToken.text === (optional ? "[" : "{")) {
	        // If we get a brace, parse an expression
	        this.consume();
	        var expression = this.parseExpression(false, optional ? "]" : null);
	        var lastToken = this.nextToken;
	        // Make sure we get a close brace
	        this.expect(optional ? "]" : "}");
	        if (this.mode === "text") {
	            this.formLigatures(expression);
	        }
	        return new ParseFuncOrArgument(
	            new ParseNode("ordgroup", expression, this.mode,
	                          firstToken, lastToken),
	            false);
	    } else {
	        // Otherwise, just return a nucleus, or nothing for an optional group
	        return optional ? null : this.parseSymbol();
	    }
	};
	
	/**
	 * Form ligature-like combinations of characters for text mode.
	 * This includes inputs like "--", "---", "``" and "''".
	 * The result will simply replace multiple textord nodes with a single
	 * character in each value by a single textord node having multiple
	 * characters in its value.  The representation is still ASCII source.
	 *
	 * @param {Array.<ParseNode>} group  the nodes of this group,
	 *                                   list will be moified in place
	 */
	Parser.prototype.formLigatures = function(group) {
	    var i;
	    var n = group.length - 1;
	    for (i = 0; i < n; ++i) {
	        var a = group[i];
	        var v = a.value;
	        if (v === "-" && group[i + 1].value === "-") {
	            if (i + 1 < n && group[i + 2].value === "-") {
	                group.splice(i, 3, new ParseNode(
	                    "textord", "---", "text", a, group[i + 2]));
	                n -= 2;
	            } else {
	                group.splice(i, 2, new ParseNode(
	                    "textord", "--", "text", a, group[i + 1]));
	                n -= 1;
	            }
	        }
	        if ((v === "'" || v === "`") && group[i + 1].value === v) {
	            group.splice(i, 2, new ParseNode(
	                "textord", v + v, "text", a, group[i + 1]));
	            n -= 1;
	        }
	    }
	};
	
	/**
	 * Parse a single symbol out of the string. Here, we handle both the functions
	 * we have defined, as well as the single character symbols
	 *
	 * @return {?ParseFuncOrArgument}
	 */
	Parser.prototype.parseSymbol = function() {
	    var nucleus = this.nextToken;
	
	    if (functions[nucleus.text]) {
	        this.consume();
	        // If there exists a function with this name, we return the function and
	        // say that it is a function.
	        return new ParseFuncOrArgument(
	            nucleus.text,
	            true, nucleus);
	    } else if (symbols[this.mode][nucleus.text]) {
	        this.consume();
	        // Otherwise if this is a no-argument function, find the type it
	        // corresponds to in the symbols map
	        return new ParseFuncOrArgument(
	            new ParseNode(symbols[this.mode][nucleus.text].group,
	                          nucleus.text, this.mode, nucleus),
	            false, nucleus);
	    } else if (this.mode === "text" && cjkRegex.test(nucleus.text)) {
	        this.consume();
	        return new ParseFuncOrArgument(
	            new ParseNode("textord", nucleus.text, this.mode, nucleus),
	            false, nucleus);
	    } else {
	        return null;
	    }
	};
	
	Parser.prototype.ParseNode = ParseNode;
	
	module.exports = Parser;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(115);
	var ParseError = __webpack_require__(105);
	var parseData = __webpack_require__(124);
	var ParseNode = parseData.ParseNode;
	
	/* This file contains a list of functions that we parse, identified by
	 * the calls to defineFunction.
	 *
	 * The first argument to defineFunction is a single name or a list of names.
	 * All functions named in such a list will share a single implementation.
	 *
	 * Each declared function can have associated properties, which
	 * include the following:
	 *
	 *  - numArgs: The number of arguments the function takes.
	 *             If this is the only property, it can be passed as a number
	 *             instead of an element of a properties object.
	 *  - argTypes: (optional) An array corresponding to each argument of the
	 *              function, giving the type of argument that should be parsed. Its
	 *              length should be equal to `numArgs + numOptionalArgs`. Valid
	 *              types:
	 *               - "size": A size-like thing, such as "1em" or "5ex"
	 *               - "color": An html color, like "#abc" or "blue"
	 *               - "original": The same type as the environment that the
	 *                             function being parsed is in (e.g. used for the
	 *                             bodies of functions like \color where the first
	 *                             argument is special and the second argument is
	 *                             parsed normally)
	 *              Other possible types (probably shouldn't be used)
	 *               - "text": Text-like (e.g. \text)
	 *               - "math": Normal math
	 *              If undefined, this will be treated as an appropriate length
	 *              array of "original" strings
	 *  - greediness: (optional) The greediness of the function to use ungrouped
	 *                arguments.
	 *
	 *                E.g. if you have an expression
	 *                  \sqrt \frac 1 2
	 *                since \frac has greediness=2 vs \sqrt's greediness=1, \frac
	 *                will use the two arguments '1' and '2' as its two arguments,
	 *                then that whole function will be used as the argument to
	 *                \sqrt. On the other hand, the expressions
	 *                  \frac \frac 1 2 3
	 *                and
	 *                  \frac \sqrt 1 2
	 *                will fail because \frac and \frac have equal greediness
	 *                and \sqrt has a lower greediness than \frac respectively. To
	 *                make these parse, we would have to change them to:
	 *                  \frac {\frac 1 2} 3
	 *                and
	 *                  \frac {\sqrt 1} 2
	 *
	 *                The default value is `1`
	 *  - allowedInText: (optional) Whether or not the function is allowed inside
	 *                   text mode (default false)
	 *  - numOptionalArgs: (optional) The number of optional arguments the function
	 *                     should parse. If the optional arguments aren't found,
	 *                     `null` will be passed to the handler in their place.
	 *                     (default 0)
	 *  - infix: (optional) Must be true if the function is an infix operator.
	 *
	 * The last argument is that implementation, the handler for the function(s).
	 * It is called to handle these functions and their arguments.
	 * It receives two arguments:
	 *  - context contains information and references provided by the parser
	 *  - args is an array of arguments obtained from TeX input
	 * The context contains the following properties:
	 *  - funcName: the text (i.e. name) of the function, including \
	 *  - parser: the parser object
	 *  - lexer: the lexer object
	 *  - positions: the positions in the overall string of the function
	 *               and the arguments.
	 * The latter three should only be used to produce error messages.
	 *
	 * The function should return an object with the following keys:
	 *  - type: The type of element that this is. This is then used in
	 *          buildHTML/buildMathML to determine which function
	 *          should be called to build this node into a DOM node
	 * Any other data can be added to the object, which will be passed
	 * in to the function in buildHTML/buildMathML as `group.value`.
	 */
	
	function defineFunction(names, props, handler) {
	    if (typeof names === "string") {
	        names = [names];
	    }
	    if (typeof props === "number") {
	        props = { numArgs: props };
	    }
	    // Set default values of functions
	    var data = {
	        numArgs: props.numArgs,
	        argTypes: props.argTypes,
	        greediness: (props.greediness === undefined) ? 1 : props.greediness,
	        allowedInText: !!props.allowedInText,
	        numOptionalArgs: props.numOptionalArgs || 0,
	        infix: !!props.infix,
	        handler: handler
	    };
	    for (var i = 0; i < names.length; ++i) {
	        module.exports[names[i]] = data;
	    }
	}
	
	// Since the corresponding buildHTML/buildMathML function expects a
	// list of elements, we normalize for different kinds of arguments
	var ordargument = function(arg) {
	    if (arg.type === "ordgroup") {
	        return arg.value;
	    } else {
	        return [arg];
	    }
	};
	
	// A normal square root
	defineFunction("\\sqrt", {
	    numArgs: 1,
	    numOptionalArgs: 1
	}, function(context, args) {
	    var index = args[0];
	    var body = args[1];
	    return {
	        type: "sqrt",
	        body: body,
	        index: index
	    };
	});
	
	// Non-mathy text, possibly in a font
	var textFunctionStyles = {
	    "\\text": undefined, "\\textrm": "mathrm", "\\textsf": "mathsf",
	    "\\texttt": "mathtt", "\\textnormal": "mathrm", "\\textbf": "mathbf",
	    "\\textit": "textit"
	};
	
	defineFunction([
	    "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal",
	    "\\textbf", "\\textit"
	], {
	    numArgs: 1,
	    argTypes: ["text"],
	    greediness: 2,
	    allowedInText: true
	}, function(context, args) {
	    var body = args[0];
	    return {
	        type: "text",
	        body: ordargument(body),
	        style: textFunctionStyles[context.funcName]
	    };
	});
	
	// A two-argument custom color
	defineFunction("\\color", {
	    numArgs: 2,
	    allowedInText: true,
	    greediness: 3,
	    argTypes: ["color", "original"]
	}, function(context, args) {
	    var color = args[0];
	    var body = args[1];
	    return {
	        type: "color",
	        color: color.value,
	        value: ordargument(body)
	    };
	});
	
	// An overline
	defineFunction("\\overline", {
	    numArgs: 1
	}, function(context, args) {
	    var body = args[0];
	    return {
	        type: "overline",
	        body: body
	    };
	});
	
	// An underline
	defineFunction("\\underline", {
	    numArgs: 1
	}, function(context, args) {
	    var body = args[0];
	    return {
	        type: "underline",
	        body: body
	    };
	});
	
	// A box of the width and height
	defineFunction("\\rule", {
	    numArgs: 2,
	    numOptionalArgs: 1,
	    argTypes: ["size", "size", "size"]
	}, function(context, args) {
	    var shift = args[0];
	    var width = args[1];
	    var height = args[2];
	    return {
	        type: "rule",
	        shift: shift && shift.value,
	        width: width.value,
	        height: height.value
	    };
	});
	
	// TODO: In TeX, \mkern only accepts mu-units, and \kern does not accept
	// mu-units. In current KaTeX we relax this; both commands accept any unit.
	defineFunction(["\\kern", "\\mkern"], {
	    numArgs: 1,
	    argTypes: ["size"]
	}, function(context, args) {
	    return {
	        type: "kern",
	        dimension: args[0].value
	    };
	});
	
	// A KaTeX logo
	defineFunction("\\KaTeX", {
	    numArgs: 0
	}, function(context) {
	    return {
	        type: "katex"
	    };
	});
	
	defineFunction("\\phantom", {
	    numArgs: 1
	}, function(context, args) {
	    var body = args[0];
	    return {
	        type: "phantom",
	        value: ordargument(body)
	    };
	});
	
	// Math class commands except \mathop
	defineFunction([
	    "\\mathord", "\\mathbin", "\\mathrel", "\\mathopen",
	    "\\mathclose", "\\mathpunct", "\\mathinner"
	], {
	    numArgs: 1
	}, function(context, args) {
	    var body = args[0];
	    return {
	        type: "mclass",
	        mclass: "m" + context.funcName.substr(5),
	        value: ordargument(body)
	    };
	});
	
	// Build a relation by placing one symbol on top of another
	defineFunction("\\stackrel", {
	    numArgs: 2
	}, function(context, args) {
	    var top = args[0];
	    var bottom = args[1];
	
	    var bottomop = new ParseNode("op", {
	        type: "op",
	        limits: true,
	        alwaysHandleSupSub: true,
	        symbol: false,
	        value: ordargument(bottom)
	    }, bottom.mode);
	
	    var supsub = new ParseNode("supsub", {
	        base: bottomop,
	        sup: top,
	        sub: null
	    }, top.mode);
	
	    return {
	        type: "mclass",
	        mclass: "mrel",
	        value: [supsub]
	    };
	});
	
	// \mod-type functions
	defineFunction("\\bmod", {
	    numArgs: 0
	}, function(context, args) {
	    return {
	        type: "mod",
	        modType: "bmod",
	        value: null
	    };
	});
	
	defineFunction(["\\pod", "\\pmod", "\\mod"], {
	    numArgs: 1
	}, function(context, args) {
	    var body = args[0];
	    return {
	        type: "mod",
	        modType: context.funcName.substr(1),
	        value: ordargument(body)
	    };
	});
	
	// Extra data needed for the delimiter handler down below
	var delimiterSizes = {
	    "\\bigl" : {mclass: "mopen",    size: 1},
	    "\\Bigl" : {mclass: "mopen",    size: 2},
	    "\\biggl": {mclass: "mopen",    size: 3},
	    "\\Biggl": {mclass: "mopen",    size: 4},
	    "\\bigr" : {mclass: "mclose",   size: 1},
	    "\\Bigr" : {mclass: "mclose",   size: 2},
	    "\\biggr": {mclass: "mclose",   size: 3},
	    "\\Biggr": {mclass: "mclose",   size: 4},
	    "\\bigm" : {mclass: "mrel",     size: 1},
	    "\\Bigm" : {mclass: "mrel",     size: 2},
	    "\\biggm": {mclass: "mrel",     size: 3},
	    "\\Biggm": {mclass: "mrel",     size: 4},
	    "\\big"  : {mclass: "mord",     size: 1},
	    "\\Big"  : {mclass: "mord",     size: 2},
	    "\\bigg" : {mclass: "mord",     size: 3},
	    "\\Bigg" : {mclass: "mord",     size: 4}
	};
	
	var delimiters = [
	    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
	    "\\{", "\\lbrace", "\\}", "\\rbrace",
	    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
	    "<", ">", "\\langle", "\\rangle", "\\lt", "\\gt",
	    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
	    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache",
	    "/", "\\backslash",
	    "|", "\\vert", "\\|", "\\Vert",
	    "\\uparrow", "\\Uparrow",
	    "\\downarrow", "\\Downarrow",
	    "\\updownarrow", "\\Updownarrow",
	    "."
	];
	
	var fontAliases = {
	    "\\Bbb": "\\mathbb",
	    "\\bold": "\\mathbf",
	    "\\frak": "\\mathfrak"
	};
	
	// Single-argument color functions
	defineFunction([
	    "\\blue", "\\orange", "\\pink", "\\red",
	    "\\green", "\\gray", "\\purple",
	    "\\blueA", "\\blueB", "\\blueC", "\\blueD", "\\blueE",
	    "\\tealA", "\\tealB", "\\tealC", "\\tealD", "\\tealE",
	    "\\greenA", "\\greenB", "\\greenC", "\\greenD", "\\greenE",
	    "\\goldA", "\\goldB", "\\goldC", "\\goldD", "\\goldE",
	    "\\redA", "\\redB", "\\redC", "\\redD", "\\redE",
	    "\\maroonA", "\\maroonB", "\\maroonC", "\\maroonD", "\\maroonE",
	    "\\purpleA", "\\purpleB", "\\purpleC", "\\purpleD", "\\purpleE",
	    "\\mintA", "\\mintB", "\\mintC",
	    "\\grayA", "\\grayB", "\\grayC", "\\grayD", "\\grayE",
	    "\\grayF", "\\grayG", "\\grayH", "\\grayI",
	    "\\kaBlue", "\\kaGreen"
	], {
	    numArgs: 1,
	    allowedInText: true,
	    greediness: 3
	}, function(context, args) {
	    var body = args[0];
	    return {
	        type: "color",
	        color: "katex-" + context.funcName.slice(1),
	        value: ordargument(body)
	    };
	});
	
	// There are 2 flags for operators; whether they produce limits in
	// displaystyle, and whether they are symbols and should grow in
	// displaystyle. These four groups cover the four possible choices.
	
	// No limits, not symbols
	defineFunction([
	    "\\arcsin", "\\arccos", "\\arctan", "\\arg", "\\cos", "\\cosh",
	    "\\cot", "\\coth", "\\csc", "\\deg", "\\dim", "\\exp", "\\hom",
	    "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh",
	    "\\tan", "\\tanh"
	], {
	    numArgs: 0
	}, function(context) {
	    return {
	        type: "op",
	        limits: false,
	        symbol: false,
	        body: context.funcName
	    };
	});
	
	// Limits, not symbols
	defineFunction([
	    "\\det", "\\gcd", "\\inf", "\\lim", "\\liminf", "\\limsup", "\\max",
	    "\\min", "\\Pr", "\\sup"
	], {
	    numArgs: 0
	}, function(context) {
	    return {
	        type: "op",
	        limits: true,
	        symbol: false,
	        body: context.funcName
	    };
	});
	
	// No limits, symbols
	defineFunction([
	    "\\int", "\\iint", "\\iiint", "\\oint"
	], {
	    numArgs: 0
	}, function(context) {
	    return {
	        type: "op",
	        limits: false,
	        symbol: true,
	        body: context.funcName
	    };
	});
	
	// Limits, symbols
	defineFunction([
	    "\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap",
	    "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes",
	    "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint"
	], {
	    numArgs: 0
	}, function(context) {
	    return {
	        type: "op",
	        limits: true,
	        symbol: true,
	        body: context.funcName
	    };
	});
	
	// \mathop class command
	defineFunction("\\mathop", {
	    numArgs: 1
	}, function(context, args) {
	    var body = args[0];
	    return {
	        type: "op",
	        limits: false,
	        symbol: false,
	        value: ordargument(body)
	    };
	});
	
	// Fractions
	defineFunction([
	    "\\dfrac", "\\frac", "\\tfrac",
	    "\\dbinom", "\\binom", "\\tbinom",
	    "\\\\atopfrac" // cant be entered directly
	], {
	    numArgs: 2,
	    greediness: 2
	}, function(context, args) {
	    var numer = args[0];
	    var denom = args[1];
	    var hasBarLine;
	    var leftDelim = null;
	    var rightDelim = null;
	    var size = "auto";
	
	    switch (context.funcName) {
	        case "\\dfrac":
	        case "\\frac":
	        case "\\tfrac":
	            hasBarLine = true;
	            break;
	        case "\\\\atopfrac":
	            hasBarLine = false;
	            break;
	        case "\\dbinom":
	        case "\\binom":
	        case "\\tbinom":
	            hasBarLine = false;
	            leftDelim = "(";
	            rightDelim = ")";
	            break;
	        default:
	            throw new Error("Unrecognized genfrac command");
	    }
	
	    switch (context.funcName) {
	        case "\\dfrac":
	        case "\\dbinom":
	            size = "display";
	            break;
	        case "\\tfrac":
	        case "\\tbinom":
	            size = "text";
	            break;
	    }
	
	    return {
	        type: "genfrac",
	        numer: numer,
	        denom: denom,
	        hasBarLine: hasBarLine,
	        leftDelim: leftDelim,
	        rightDelim: rightDelim,
	        size: size
	    };
	});
	
	// Left and right overlap functions
	defineFunction(["\\llap", "\\rlap"], {
	    numArgs: 1,
	    allowedInText: true
	}, function(context, args) {
	    var body = args[0];
	    return {
	        type: context.funcName.slice(1),
	        body: body
	    };
	});
	
	// Delimiter functions
	var checkDelimiter = function(delim, context) {
	    if (utils.contains(delimiters, delim.value)) {
	        return delim;
	    } else {
	        throw new ParseError(
	            "Invalid delimiter: '" + delim.value + "' after '" +
	            context.funcName + "'", delim);
	    }
	};
	
	defineFunction([
	    "\\bigl", "\\Bigl", "\\biggl", "\\Biggl",
	    "\\bigr", "\\Bigr", "\\biggr", "\\Biggr",
	    "\\bigm", "\\Bigm", "\\biggm", "\\Biggm",
	    "\\big",  "\\Big",  "\\bigg",  "\\Bigg"
	], {
	    numArgs: 1
	}, function(context, args) {
	    var delim = checkDelimiter(args[0], context);
	
	    return {
	        type: "delimsizing",
	        size: delimiterSizes[context.funcName].size,
	        mclass: delimiterSizes[context.funcName].mclass,
	        value: delim.value
	    };
	});
	
	defineFunction([
	    "\\left", "\\right"
	], {
	    numArgs: 1
	}, function(context, args) {
	    var delim = checkDelimiter(args[0], context);
	
	    // \left and \right are caught somewhere in Parser.js, which is
	    // why this data doesn't match what is in buildHTML.
	    return {
	        type: "leftright",
	        value: delim.value
	    };
	});
	
	defineFunction("\\middle", {
	    numArgs: 1
	}, function(context, args) {
	    var delim = checkDelimiter(args[0], context);
	    if (!context.parser.leftrightDepth) {
	        throw new ParseError("\\middle without preceding \\left", delim);
	    }
	
	    return {
	        type: "middle",
	        value: delim.value
	    };
	});
	
	// Sizing functions (handled in Parser.js explicitly, hence no handler)
	defineFunction([
	    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small",
	    "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
	], 0, null);
	
	// Style changing functions (handled in Parser.js explicitly, hence no
	// handler)
	defineFunction([
	    "\\displaystyle", "\\textstyle", "\\scriptstyle",
	    "\\scriptscriptstyle"
	], 0, null);
	
	defineFunction([
	    // styles
	    "\\mathrm", "\\mathit", "\\mathbf",
	
	    // families
	    "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf",
	    "\\mathtt",
	
	    // aliases
	    "\\Bbb", "\\bold", "\\frak"
	], {
	    numArgs: 1,
	    greediness: 2
	}, function(context, args) {
	    var body = args[0];
	    var func = context.funcName;
	    if (func in fontAliases) {
	        func = fontAliases[func];
	    }
	    return {
	        type: "font",
	        font: func.slice(1),
	        body: body
	    };
	});
	
	// Accents
	defineFunction([
	    "\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve",
	    "\\check", "\\hat", "\\vec", "\\dot"
	    // We don't support expanding accents yet
	    // "\\widetilde", "\\widehat"
	], {
	    numArgs: 1
	}, function(context, args) {
	    var base = args[0];
	    return {
	        type: "accent",
	        accent: context.funcName,
	        base: base
	    };
	});
	
	// Infix generalized fractions
	defineFunction(["\\over", "\\choose", "\\atop"], {
	    numArgs: 0,
	    infix: true
	}, function(context) {
	    var replaceWith;
	    switch (context.funcName) {
	        case "\\over":
	            replaceWith = "\\frac";
	            break;
	        case "\\choose":
	            replaceWith = "\\binom";
	            break;
	        case "\\atop":
	            replaceWith = "\\\\atopfrac";
	            break;
	        default:
	            throw new Error("Unrecognized infix genfrac command");
	    }
	    return {
	        type: "infix",
	        replaceWith: replaceWith,
	        token: context.token
	    };
	});
	
	// Row breaks for aligned data
	defineFunction(["\\\\", "\\cr"], {
	    numArgs: 0,
	    numOptionalArgs: 1,
	    argTypes: ["size"]
	}, function(context, args) {
	    var size = args[0];
	    return {
	        type: "cr",
	        size: size
	    };
	});
	
	// Environment delimiters
	defineFunction(["\\begin", "\\end"], {
	    numArgs: 1,
	    argTypes: ["text"]
	}, function(context, args) {
	    var nameGroup = args[0];
	    if (nameGroup.type !== "ordgroup") {
	        throw new ParseError("Invalid environment name", nameGroup);
	    }
	    var name = "";
	    for (var i = 0; i < nameGroup.value.length; ++i) {
	        name += nameGroup.value[i].value;
	    }
	    return {
	        type: "environment",
	        name: name,
	        nameGroup: nameGroup
	    };
	});


/***/ }),
/* 124 */
/***/ (function(module, exports) {

	/**
	 * The resulting parse tree nodes of the parse tree.
	 *
	 * It is possible to provide position information, so that a ParseNode can
	 * fulfil a role similar to a Token in error reporting.
	 * For details on the corresponding properties see Token constructor.
	 * Providing such information can lead to better error reporting.
	 *
	 * @param {string}  type       type of node, like e.g. "ordgroup"
	 * @param {?object} value      type-specific representation of the node
	 * @param {string}  mode       parse mode in action for this node,
	 *                             "math" or "text"
	 * @param {Token=} firstToken  first token of the input for this node,
	 *                             will omit position information if unset
	 * @param {Token=} lastToken   last token of the input for this node,
	 *                             will default to firstToken if unset
	 */
	function ParseNode(type, value, mode, firstToken, lastToken) {
	    this.type = type;
	    this.value = value;
	    this.mode = mode;
	    if (firstToken && (!lastToken || lastToken.lexer === firstToken.lexer)) {
	        this.lexer = firstToken.lexer;
	        this.start = firstToken.start;
	        this.end = (lastToken || firstToken).end;
	    }
	}
	
	module.exports = {
	    ParseNode: ParseNode
	};
	


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint no-constant-condition:0 */
	var parseData = __webpack_require__(124);
	var ParseError = __webpack_require__(105);
	var Style = __webpack_require__(109);
	
	var ParseNode = parseData.ParseNode;
	
	/**
	 * Parse the body of the environment, with rows delimited by \\ and
	 * columns delimited by &, and create a nested list in row-major order
	 * with one group per cell.
	 */
	function parseArray(parser, result) {
	    var row = [];
	    var body = [row];
	    var rowGaps = [];
	    while (true) {
	        var cell = parser.parseExpression(false, null);
	        row.push(new ParseNode("ordgroup", cell, parser.mode));
	        var next = parser.nextToken.text;
	        if (next === "&") {
	            parser.consume();
	        } else if (next === "\\end") {
	            break;
	        } else if (next === "\\\\" || next === "\\cr") {
	            var cr = parser.parseFunction();
	            rowGaps.push(cr.value.size);
	            row = [];
	            body.push(row);
	        } else {
	            throw new ParseError("Expected & or \\\\ or \\end",
	                                 parser.nextToken);
	        }
	    }
	    result.body = body;
	    result.rowGaps = rowGaps;
	    return new ParseNode(result.type, result, parser.mode);
	}
	
	/*
	 * An environment definition is very similar to a function definition:
	 * it is declared with a name or a list of names, a set of properties
	 * and a handler containing the actual implementation.
	 *
	 * The properties include:
	 *  - numArgs: The number of arguments after the \begin{name} function.
	 *  - argTypes: (optional) Just like for a function
	 *  - allowedInText: (optional) Whether or not the environment is allowed inside
	 *                   text mode (default false) (not enforced yet)
	 *  - numOptionalArgs: (optional) Just like for a function
	 * A bare number instead of that object indicates the numArgs value.
	 *
	 * The handler function will receive two arguments
	 *  - context: information and references provided by the parser
	 *  - args: an array of arguments passed to \begin{name}
	 * The context contains the following properties:
	 *  - envName: the name of the environment, one of the listed names.
	 *  - parser: the parser object
	 *  - lexer: the lexer object
	 *  - positions: the positions associated with these arguments from args.
	 * The handler must return a ParseResult.
	 */
	
	function defineEnvironment(names, props, handler) {
	    if (typeof names === "string") {
	        names = [names];
	    }
	    if (typeof props === "number") {
	        props = { numArgs: props };
	    }
	    // Set default values of environments
	    var data = {
	        numArgs: props.numArgs || 0,
	        argTypes: props.argTypes,
	        greediness: 1,
	        allowedInText: !!props.allowedInText,
	        numOptionalArgs: props.numOptionalArgs || 0,
	        handler: handler
	    };
	    for (var i = 0; i < names.length; ++i) {
	        module.exports[names[i]] = data;
	    }
	}
	
	// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
	// is part of the source2e.pdf file of LaTeX2e source documentation.
	defineEnvironment("array", {
	    numArgs: 1
	}, function(context, args) {
	    var colalign = args[0];
	    colalign = colalign.value.map ? colalign.value : [colalign];
	    var cols = colalign.map(function(node) {
	        var ca = node.value;
	        if ("lcr".indexOf(ca) !== -1) {
	            return {
	                type: "align",
	                align: ca
	            };
	        } else if (ca === "|") {
	            return {
	                type: "separator",
	                separator: "|"
	            };
	        }
	        throw new ParseError(
	            "Unknown column alignment: " + node.value,
	            node);
	    });
	    var res = {
	        type: "array",
	        cols: cols,
	        hskipBeforeAndAfter: true // \@preamble in lttab.dtx
	    };
	    res = parseArray(context.parser, res);
	    return res;
	});
	
	// The matrix environments of amsmath builds on the array environment
	// of LaTeX, which is discussed above.
	defineEnvironment([
	    "matrix",
	    "pmatrix",
	    "bmatrix",
	    "Bmatrix",
	    "vmatrix",
	    "Vmatrix"
	], {
	}, function(context) {
	    var delimiters = {
	        "matrix": null,
	        "pmatrix": ["(", ")"],
	        "bmatrix": ["[", "]"],
	        "Bmatrix": ["\\{", "\\}"],
	        "vmatrix": ["|", "|"],
	        "Vmatrix": ["\\Vert", "\\Vert"]
	    }[context.envName];
	    var res = {
	        type: "array",
	        hskipBeforeAndAfter: false // \hskip -\arraycolsep in amsmath
	    };
	    res = parseArray(context.parser, res);
	    if (delimiters) {
	        res = new ParseNode("leftright", {
	            body: [res],
	            left: delimiters[0],
	            right: delimiters[1]
	        }, context.mode);
	    }
	    return res;
	});
	
	// A cases environment (in amsmath.sty) is almost equivalent to
	// \def\arraystretch{1.2}%
	// \left\{\begin{array}{@{}l@{\quad}l@{}}  \end{array}\right.
	defineEnvironment("cases", {
	}, function(context) {
	    var res = {
	        type: "array",
	        arraystretch: 1.2,
	        cols: [{
	            type: "align",
	            align: "l",
	            pregap: 0,
	            // TODO(kevinb) get the current style.
	            // For now we use the metrics for TEXT style which is what we were
	            // doing before.  Before attempting to get the current style we
	            // should look at TeX's behavior especially for \over and matrices.
	            postgap: Style.TEXT.metrics.quad
	        }, {
	            type: "align",
	            align: "l",
	            pregap: 0,
	            postgap: 0
	        }]
	    };
	    res = parseArray(context.parser, res);
	    res = new ParseNode("leftright", {
	        body: [res],
	        left: "\\{",
	        right: "."
	    }, context.mode);
	    return res;
	});
	
	// An aligned environment is like the align* environment
	// except it operates within math mode.
	// Note that we assume \nomallineskiplimit to be zero,
	// so that \strut@ is the same as \strut.
	defineEnvironment("aligned", {
	}, function(context) {
	    var res = {
	        type: "array",
	        cols: []
	    };
	    res = parseArray(context.parser, res);
	    var emptyGroup = new ParseNode("ordgroup", [], context.mode);
	    var numCols = 0;
	    res.value.body.forEach(function(row) {
	        var i;
	        for (i = 1; i < row.length; i += 2) {
	            row[i].value.unshift(emptyGroup);
	        }
	        if (numCols < row.length) {
	            numCols = row.length;
	        }
	    });
	    for (var i = 0; i < numCols; ++i) {
	        var align = "r";
	        var pregap = 0;
	        if (i % 2 === 1) {
	            align = "l";
	        } else if (i > 0) {
	            pregap = 2; // one \qquad between columns
	        }
	        res.value.cols[i] = {
	            type: "align",
	            align: align,
	            pregap: pregap,
	            postgap: 0
	        };
	    }
	    return res;
	});


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * This file contains the gullet where macros are expanded
	 * until only non-macro tokens remain.
	 */
	
	var Lexer = __webpack_require__(127);
	
	function MacroExpander(input, macros) {
	    this.lexer = new Lexer(input);
	    this.macros = macros;
	    this.stack = []; // contains tokens in REVERSE order
	    this.discardedWhiteSpace = [];
	}
	
	/**
	 * Recursively expand first token, then return first non-expandable token.
	 */
	MacroExpander.prototype.nextToken = function() {
	    for (;;) {
	        if (this.stack.length === 0) {
	            this.stack.push(this.lexer.lex());
	        }
	        var topToken = this.stack.pop();
	        var name = topToken.text;
	        if (!(name.charAt(0) === "\\" && this.macros.hasOwnProperty(name))) {
	            return topToken;
	        }
	        var expansion = this.macros[name];
	        if (typeof expansion === "string") {
	            var bodyLexer = new Lexer(expansion);
	            expansion = [];
	            var tok = bodyLexer.lex();
	            while (tok.text !== "EOF") {
	                expansion.push(tok);
	                tok = bodyLexer.lex();
	            }
	            expansion.reverse(); // to fit in with stack using push and pop
	            this.macros[name] = expansion;
	        }
	        this.stack = this.stack.concat(expansion);
	    }
	};
	
	MacroExpander.prototype.get = function(ignoreSpace) {
	    this.discardedWhiteSpace = [];
	    var token = this.nextToken();
	    if (ignoreSpace) {
	        while (token.text === " ") {
	            this.discardedWhiteSpace.push(token);
	            token = this.nextToken();
	        }
	    }
	    return token;
	};
	
	/**
	 * Undo the effect of the preceding call to the get method.
	 * A call to this method MUST be immediately preceded and immediately followed
	 * by a call to get.  Only used during mode switching, i.e. after one token
	 * was got in the old mode but should get got again in a new mode
	 * with possibly different whitespace handling.
	 */
	MacroExpander.prototype.unget = function(token) {
	    this.stack.push(token);
	    while (this.discardedWhiteSpace.length !== 0) {
	        this.stack.push(this.discardedWhiteSpace.pop());
	    }
	};
	
	module.exports = MacroExpander;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * The Lexer class handles tokenizing the input in various ways. Since our
	 * parser expects us to be able to backtrack, the lexer allows lexing from any
	 * given starting point.
	 *
	 * Its main exposed function is the `lex` function, which takes a position to
	 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
	 * function.
	 *
	 * The various `_innerLex` functions perform the actual lexing of different
	 * kinds.
	 */
	
	var matchAt = __webpack_require__(128);
	
	var ParseError = __webpack_require__(105);
	
	// The main lexer class
	function Lexer(input) {
	    this.input = input;
	    this.pos = 0;
	}
	
	/**
	 * The resulting token returned from `lex`.
	 *
	 * It consists of the token text plus some position information.
	 * The position information is essentially a range in an input string,
	 * but instead of referencing the bare input string, we refer to the lexer.
	 * That way it is possible to attach extra metadata to the input string,
	 * like for example a file name or similar.
	 *
	 * The position information (all three parameters) is optional,
	 * so it is OK to construct synthetic tokens if appropriate.
	 * Not providing available position information may lead to
	 * degraded error reporting, though.
	 *
	 * @param {string}  text   the text of this token
	 * @param {number=} start  the start offset, zero-based inclusive
	 * @param {number=} end    the end offset, zero-based exclusive
	 * @param {Lexer=}  lexer  the lexer which in turn holds the input string
	 */
	function Token(text, start, end, lexer) {
	    this.text = text;
	    this.start = start;
	    this.end = end;
	    this.lexer = lexer;
	}
	
	/**
	 * Given a pair of tokens (this and endToken), compute a Token encompassing
	 * the whole input range enclosed by these two.
	 *
	 * @param {Token}  endToken  last token of the range, inclusive
	 * @param {string} text      the text of the newly constructed token
	 */
	Token.prototype.range = function(endToken, text) {
	    if (endToken.lexer !== this.lexer) {
	        return new Token(text); // sorry, no position information available
	    }
	    return new Token(text, this.start, endToken.end, this.lexer);
	};
	
	/* The following tokenRegex
	 * - matches typical whitespace (but not NBSP etc.) using its first group
	 * - does not match any control character \x00-\x1f except whitespace
	 * - does not match a bare backslash
	 * - matches any ASCII character except those just mentioned
	 * - does not match the BMP private use area \uE000-\uF8FF
	 * - does not match bare surrogate code units
	 * - matches any BMP character except for those just described
	 * - matches any valid Unicode surrogate pair
	 * - matches a backslash followed by one or more letters
	 * - matches a backslash followed by any BMP character, including newline
	 * Just because the Lexer matches something doesn't mean it's valid input:
	 * If there is no matching function or symbol definition, the Parser will
	 * still reject the input.
	 */
	var tokenRegex = new RegExp(
	    "([ \r\n\t]+)|" +                                 // whitespace
	    "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" +  // single codepoint
	    "|[\uD800-\uDBFF][\uDC00-\uDFFF]" +               // surrogate pair
	    "|\\\\(?:[a-zA-Z]+|[^\uD800-\uDFFF])" +           // function name
	    ")"
	);
	
	/**
	 * This function lexes a single token.
	 */
	Lexer.prototype.lex = function() {
	    var input = this.input;
	    var pos = this.pos;
	    if (pos === input.length) {
	        return new Token("EOF", pos, pos, this);
	    }
	    var match = matchAt(tokenRegex, input, pos);
	    if (match === null) {
	        throw new ParseError(
	            "Unexpected character: '" + input[pos] + "'",
	            new Token(input[pos], pos, pos + 1, this));
	    }
	    var text = match[2] || " ";
	    var start = this.pos;
	    this.pos += match[0].length;
	    var end = this.pos;
	    return new Token(text, start, end, this);
	};
	
	module.exports = Lexer;


/***/ }),
/* 128 */
/***/ (function(module, exports) {

	/** @flow */
	
	"use strict";
	
	function getRelocatable(re) {
	  // In the future, this could use a WeakMap instead of an expando.
	  if (!re.__matchAtRelocatable) {
	    // Disjunctions are the lowest-precedence operator, so we can make any
	    // pattern match the empty string by appending `|()` to it:
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-patterns
	    var source = re.source + "|()";
	
	    // We always make the new regex global.
	    var flags = "g" + (re.ignoreCase ? "i" : "") + (re.multiline ? "m" : "") + (re.unicode ? "u" : "")
	    // sticky (/.../y) doesn't make sense in conjunction with our relocation
	    // logic, so we ignore it here.
	    ;
	
	    re.__matchAtRelocatable = new RegExp(source, flags);
	  }
	  return re.__matchAtRelocatable;
	}
	
	function matchAt(re, str, pos) {
	  if (re.global || re.sticky) {
	    throw new Error("matchAt(...): Only non-global regexes are supported");
	  }
	  var reloc = getRelocatable(re);
	  reloc.lastIndex = pos;
	  var match = reloc.exec(str);
	  // Last capturing group is our sentinel that indicates whether the regex
	  // matched at the given location.
	  if (match[match.length - 1] == null) {
	    // Original regex matched.
	    match.length = match.length - 1;
	    return match;
	  } else {
	    return null;
	  }
	}
	
	module.exports = matchAt;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var react_router_1 = __webpack_require__(5);
	var Breadcrumb = (function (_super) {
	    __extends(Breadcrumb, _super);
	    function Breadcrumb(props) {
	        return _super.call(this, props) || this;
	    }
	    Breadcrumb.prototype.render = function () {
	        var links;
	        var last;
	        if (this.props.routes) {
	            var build_1 = '';
	            links = this.props.routes.slice(0, -1).map(function (b, i) {
	                build_1 += '/' + b;
	                return (React.createElement(react_router_1.Link, { key: i, to: build_1 }, b));
	            });
	            last = (React.createElement("span", null, this.props.routes.slice(-1)[0]));
	        }
	        return (React.createElement("div", { className: "page-container flex no-grow" },
	            React.createElement("div", { className: "breadcrumb-container" },
	                React.createElement(react_router_1.IndexLink, { to: "/" }, "Home"),
	                links,
	                last)));
	    };
	    return Breadcrumb;
	}(React.Component));
	exports.Breadcrumb = Breadcrumb;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var react_router_1 = __webpack_require__(5);
	var commonmark_1 = __webpack_require__(83);
	var Katex = __webpack_require__(104);
	var es6_promise_1 = __webpack_require__(80);
	es6_promise_1.polyfill();
	var PageLayout_1 = __webpack_require__(72);
	var BlogArticle = (function (_super) {
	    __extends(BlogArticle, _super);
	    function BlogArticle(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            attributes: {
	                layout: '',
	                title: '',
	                date: '',
	                categories: '',
	                categoriesList: [],
	                author: '',
	            },
	            post: ''
	        };
	        _this.parser = new commonmark_1.Parser();
	        _this.renderer = new commonmark_1.HtmlRenderer();
	        _this.fetchPost("/api/v1/posts/" + _this.props.post);
	        return _this;
	    }
	    BlogArticle.prototype.componentDidUpdate = function (prevProp, prevState) {
	        var refs = this.refs;
	        if (prevState.post !== this.state.post) {
	            if (refs.post) {
	                for (var _i = 0, _a = refs.post.children; _i < _a.length; _i++) {
	                    var child = _a[_i];
	                    if (child.tagName === 'TEX')
	                        Katex.render(child.innerText, child);
	                    else {
	                        for (var _b = 0, _c = child.children; _b < _c.length; _b++) {
	                            var subchild = _c[_b];
	                            if (subchild.tagName === 'TEX')
	                                Katex.render(subchild.innerText, subchild);
	                        }
	                    }
	                }
	            }
	        }
	    };
	    BlogArticle.prototype.componentWillReceiveProps = function (nextProps) {
	        if (nextProps.post !== this.props.post) {
	            this.fetchPost("/api/v1/posts/" + nextProps.post);
	        }
	    };
	    BlogArticle.prototype.fetchPost = function (url) {
	        var _this = this;
	        fetch(url)
	            .then(function (r) { return r.json(); })
	            .then(function (r) {
	            var parsed = _this.parser.parse(r.body);
	            var rendered = _this.renderer.render(parsed);
	            r.attributes['dateFormatted'] = _this.formatDate(r.attributes.date, 'dag DD/MM/YY');
	            r.attributes['categoriesList'] = r.attributes.categories.split(' ');
	            _this.setState({
	                attributes: r.attributes,
	                post: rendered
	            });
	        })
	            .catch(function (err) { return console.error('Could not fetch file from: ' + url); });
	    };
	    BlogArticle.prototype.formatDate = function (date, format) {
	        if (!date.length)
	            return '';
	        if (typeof date === 'string') {
	            format = (typeof format === 'string' ? format : 'dag DD.MM.YYYY (HH:mm:SS)');
	            var dager = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
	            var d = new Date(date.replace(/-/g, '/').replace(/T/g, ' ').slice(0, 19));
	            var formatted = format.replace(new RegExp('da[gy]', 'ig'), dager[d.getDay()]);
	            for (var i = 5; i > 0; i--) {
	                formatted = formatted
	                    .replace(new RegExp("(^|\\W)Y{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getFullYear(), i) + "$2")
	                    .replace(new RegExp("(^|\\W)M{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getMonth() + 1, i) + "$2")
	                    .replace(new RegExp("(^|\\W)D{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getDate(), i) + "$2")
	                    .replace(new RegExp("(^|\\W)H{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getHours(), i) + "$2")
	                    .replace(new RegExp("(^|\\W)m{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getMinutes(), i) + "$2")
	                    .replace(new RegExp("(^|\\W)S{" + i + ",}($|\\W)", 'g'), "$1" + this.digits(d.getSeconds(), i) + "$2");
	            }
	            return formatted;
	        }
	        return '';
	    };
	    BlogArticle.prototype.digits = function (value, places) {
	        places = (typeof places === 'number' ? places : 2);
	        return (Array(places).join('0') + value).slice(-(places));
	    };
	    BlogArticle.prototype.render = function () {
	        var categories = this.state.attributes.categoriesList.map(function (cat, k) {
	            return (React.createElement(react_router_1.Link, { to: "/blog/tags/" + cat, className: "category", key: k }, cat));
	        });
	        return (React.createElement(PageLayout_1.Section, { className: "page-blog" },
	            React.createElement("h1", { className: "section-title" }, this.state.attributes.title),
	            React.createElement("div", { className: "blog-post-details" },
	                React.createElement("div", { className: "blog-post-author" }, this.state.attributes.author),
	                React.createElement("div", { className: "blog-post-date" }, this.state.attributes.dateFormatted),
	                React.createElement("div", { className: "blog-post-categories" },
	                    React.createElement("div", { className: "fb-share-button", "data-href": "https://ascendntnu.no/blog/" + this.props.post, "data-layout": "button_count", "data-size": "small", "data-mobile-iframe": "true" },
	                        React.createElement("a", { className: "fb-xfbml-parse-ignore", target: "_blank", href: encodeURIComponent("https://www.facebook.com/sharer/sharer.php?u=https://ascendntnu.no/blog/" + this.props.post + "&amp;src=sdkpreparse") })),
	                    categories)),
	            React.createElement("div", { className: "blog-post-content", ref: "post", dangerouslySetInnerHTML: { __html: this.state.post } })));
	    };
	    return BlogArticle;
	}(React.Component));
	exports.BlogArticle = BlogArticle;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var PageLayout_1 = __webpack_require__(72);
	var breadcrumb_1 = __webpack_require__(129);
	var DronePage = (function (_super) {
	    __extends(DronePage, _super);
	    function DronePage() {
	        var _this = _super.call(this) || this;
	        _this.drones = [
	            {
	                name: 'Drone 2.0',
	                version: 'v2.0',
	                model: {
	                    name: 'Drone 2',
	                    parts: ['/images/drones/drone2.stl', '/images/drones/propell.stl'],
	                },
	                imageCollection: [],
	                image: React.createElement("div", { className: "drone-image", style: { backgroundImage: 'url(/images/drones/drone2-minimized.jpg)' } }),
	                //image: <div className="drone-model"><ModelRenderer models={['/images/drones/drone2.stl', '/images/drones/propell.stl']} process={[-80, 160, 160]} /></div>,
	                content: [
	                    React.createElement("span", null, "Our second aerial robot is custom designed using carbon fiber and 3D-printed parts. It was build for the 2016 IARC and designed with Mission 7 in mind, and it is able to carry all the equipment we need to herd the target robots across the green line."),
	                    React.createElement("span", null,
	                        "The ",
	                        React.createElement("b", null, "sensors"),
	                        " it has for navigation, ground robot detection and collision avoidance is five cameras, one laser rangefinder, one 2D laser scanner, and an inertial measurement unit."),
	                    React.createElement("span", null,
	                        "The ",
	                        React.createElement("b", null, "data processing"),
	                        " is done using an on-board Intel NUC, in addition to an external computer communicating using WiFi. The flight controller is a Pixhawk connected to the NUC."),
	                    React.createElement("span", null,
	                        "Our ",
	                        React.createElement("b", null, "software"),
	                        " can recognize the lines and corners of the grid, detect target robots and decide when and how to interact with them."),
	                ],
	                testDrone: {
	                    name: 'Drone 0.0.1',
	                    version: 'v0.0.1',
	                    image: React.createElement("div", { className: "drone-image", style: { backgroundImage: 'url(/images/drones/drone1-flying-minimized.jpg)' } }),
	                    content: [
	                        React.createElement("span", null, "Our first aerial robot was born fall of 2015. Creating it, flying it and using it has been a great learning experience for the team. The drone is however quite small, and we needed an upgrade in order to carry all the desired equipment."),
	                    ]
	                }
	            },
	            {
	                name: 'Valkyrie',
	                version: 'v3.0',
	                image: React.createElement("div", { className: "drone-image", style: { backgroundImage: 'url(/images/drones/drone4-minimized.jpg)' } }),
	                content: [
	                    React.createElement("span", null, "Our third quadcopter was designed as a physically robust platform for testing new control software. The small size and low weight means that we can test new control strategies, including landing on ground robots, with less risk of damage to equipment."),
	                    React.createElement("span", null, "It has a Pixhawk flight controller and an Odroid XU4 onboard computer running Ubuntu Server with ROS. The custom made frame made of carbon fiber and 3D-printed parts allows compact placement of the hardware and even weight distribution, and well balanced motors from T-Motor minimize vibrations and yields high efficiency."),
	                ],
	                testDrone: {
	                    name: 'Drone 1.1',
	                    version: 'v1.1',
	                    image: React.createElement("div", { className: "drone-image", style: { backgroundImage: 'url(/images/drones/drone3-minimized.jpg)' } }),
	                    content: [
	                        React.createElement("span", null, "Our third quadcopter was designed as a physically robust platform for testing new control software. The small size and low weight means that we can test new control strategies, including landing on ground robots, with less risk of damage to equipment."),
	                        React.createElement("span", null, "It has a Pixhawk flight controller, an Odroid XU4 onboard computer running Ubuntu Server with ROS, and is used with an Optitrack tracking system. The custom made frame made of carbon fiber and 3D-printed parts allows compact placement of the hardware and even weight distribution, and well balanced motors from T-Motor minimize vibrations and yields high efficiency."),
	                    ]
	                }
	            }
	        ];
	        _this.years = [
	            {
	                year: 2016,
	                drone: _this.drones[0],
	            },
	            {
	                year: 2017,
	                drone: _this.drones[1],
	            },
	        ];
	        _this.years = _this.years.reverse();
	        return _this;
	    }
	    DronePage.prototype.render = function () {
	        var drones = this.years.map(function (yearContent, i) {
	            var year = yearContent.year;
	            var drone = yearContent.drone;
	            var testDrone = drone.testDrone;
	            var content = null;
	            if (drone.content) {
	                content = drone.content.map(function (e, n) { return React.createElement("p", { className: "drone-text", key: n }, e); });
	            }
	            var images = null;
	            if (drone.imageCollection) {
	                images = drone.imageCollection.map(function (e, n) {
	                    return React.createElement("div", { className: "drone-gallery-image" }, e);
	                });
	            }
	            var image;
	            if (typeof drone.image === "string") {
	                image = React.createElement("img", { src: drone.image });
	            }
	            else {
	                image = drone.image;
	            }
	            return (React.createElement(PageLayout_1.SubSection, { key: i, className: "drone-container" },
	                React.createElement("div", { className: "drone-main" },
	                    React.createElement("div", { className: "drone-image" }, drone.image),
	                    React.createElement("div", { className: "drone-title-container" },
	                        React.createElement("h1", { className: "drone-title" },
	                            yearContent.year,
	                            yearContent.year === 2016 ? React.createElement("span", { className: "fa fa-star birth" }) : ''),
	                        React.createElement("h2", { className: "drone-sub-title" }, drone.name))),
	                React.createElement("div", { className: "drone-more" },
	                    React.createElement("div", { className: "drone-content" }, content),
	                    React.createElement("div", { className: "drone-gallery" }, images))));
	        });
	        return (React.createElement("div", { className: "page page-drone" },
	            React.createElement(breadcrumb_1.Breadcrumb, { routes: ['drone'] }),
	            React.createElement(PageLayout_1.Section, { titleText: "Drones" },
	                React.createElement(PageLayout_1.SubSection, { className: "row" }, drones))));
	    };
	    return DronePage;
	}(React.Component));
	exports.DronePage = DronePage;
	exports.default = DronePage;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var react_router_1 = __webpack_require__(5);
	var es6_promise_1 = __webpack_require__(80);
	es6_promise_1.polyfill();
	var PageLayout_1 = __webpack_require__(72);
	/**
	 * This is the page for showing team members
	 *
	 * @export
	 * @class TeamPage
	 * @extends {React.Component<TeamPageProps, TeamPageState>}
	 */
	var TeamPage = (function (_super) {
	    __extends(TeamPage, _super);
	    function TeamPage(props) {
	        var _this = _super.call(this, props) || this;
	        var year = 2018;
	        _this.groupings = {
	            '2016': new RegExp('Admin|Control|Perception|AI', 'i'),
	            '2017': new RegExp('Admin|Control|Perception|AI|Hardware', 'i'),
	            '2018': new RegExp('Board|Coach|Marketing|Control|Perception|AI|Hardware', 'i'),
	        };
	        _this.groupTexts = {
	            'Admin': 'The board is responsible for the whole team. They make sure organization is moving forward and plan the future of Ascend.',
	            'Board': 'The board is responsible for the whole team. They make sure organization is moving forward and plan the future of Ascend.',
	            'Marketing': 'Marketing is the group responsible for making Ascend visible on campus and spreading Ascends vision to the world.',
	            'Coach': 'Former Ascend NTNU members eager to share their knowledge with the team.',
	            'Control': 'The control group takes care of all the physical aspects of the drone. Bridging the gap between commands and actions.',
	            'Perception': 'State estimation of the drone and beyond. The perception group converts sensor input to meaningful information about the drone and its environment.',
	            'Planning': 'Finding the optimal behaviour to solve the mission at hand. The Planning group takes the latest AI research from theory to practice.',
	            'AI': 'Finding the optimal behaviour to solve the mission at hand. The AI group takes the latest AI research from theory to practice.',
	            'Hardware': 'The hardware group is responsible for the design of the drone. Material choice, strength calculations, electrical, aerodynamics, propulsion and production.',
	        };
	        if (props.params && props.params.year)
	            year = props.params.year;
	        _this.state = {
	            year: year,
	            grouping: _this.groupings[year],
	            members: [],
	            groups: [],
	        };
	        _this.getMembers(year);
	        return _this;
	    }
	    /**
	     * Changing year if props.params has changed. This is to avoid a new route.
	     *
	     * @param {*} nextProps
	     *
	     * @memberOf TeamPage
	     */
	    TeamPage.prototype.componentWillReceiveProps = function (nextProps) {
	        var nextYear = parseInt(nextProps.params.year) || 2018;
	        var year = parseInt(this.props.params.year) || this.state.year;
	        if (nextYear != year) {
	            year = nextYear;
	            this.state = {
	                year: year,
	                grouping: this.groupings[year],
	                members: this.state.members,
	                groups: this.state.groups,
	            };
	            this.getMembers(year);
	        }
	    };
	    /**
	     * Change team based from a button with a year as a dataset.
	     *
	     * @private
	     * @param {*} evt The mouseevent from the button which executed the action.
	     *
	     * @memberOf TeamPage
	     */
	    TeamPage.prototype.changeTeam = function (evt) {
	        this.getMembers(parseInt(evt.target.dataset.year));
	    };
	    /**
	     * Fetch member data from the API based om a year.
	     *
	     * @param {number} year The year to fetch from.
	     *
	     * @memberOf TeamPage
	     */
	    TeamPage.prototype.getMembers = function (year) {
	        var _this = this;
	        fetch("/api/v1/members/" + year).then(function (r) { return r.json(); }).then(function (r) {
	            if (r !== null) {
	                var groups_1 = [];
	                r.forEach(function (m, i) {
	                    var g = m.group.split(/, ?/);
	                    for (var i_1 = 0; i_1 < g.length; i_1++) {
	                        if (groups_1.indexOf(g[i_1]) === -1)
	                            groups_1.push(g[i_1]);
	                    }
	                });
	                _this.setState({
	                    year: year,
	                    grouping: _this.groupings[year],
	                    members: r.sort(function (a, b) {
	                        return a.name > b.name ? 1 : -1;
	                    }),
	                    groups: groups_1.sort(function (a, b) {
	                        if (a.toLowerCase() == "board") {
	                            return -1;
	                        }
	                        if (a.toLowerCase() == "coach") {
	                            return 1;
	                        }
	                        return a.toLowerCase() > b.toLowerCase() ? 1 : -1;
	                    })
	                });
	            }
	            else {
	                _this.setState({
	                    year: year,
	                    grouping: _this.groupings[year],
	                    members: [],
	                    groups: [],
	                });
	            }
	        });
	    };
	    /**
	     * Transformes the mail address to avoid bots from reading the plain address.
	     * Since the user allways is going to hover the mouse over the mail, we transform the
	     * address according to that.
	     *
	     * @private
	     * @param {*} evt Should be a mouse over event.
	     * @returns
	     *
	     * @memberOf TeamPage
	     */
	    TeamPage.prototype.transformMailAddress = function (evt) {
	        if (evt.target.href)
	            evt.target.href = evt.target.href.replace(/\[at\]/g, '@');
	    };
	    TeamPage.prototype.render = function () {
	        var _this = this;
	        /**
	         * Creating team photo on top
	          */
	        var team_photo = (React.createElement("div", { className: "section page-container" },
	            React.createElement("img", { src: "/images/teams/" + this.state.year + "/ascend-group-" + this.state.year + ".jpg", className: "responsive-image fullscale-image" })));
	        /**
	         * Creating the groups to an array of elements.
	         */
	        var groups = this.state.groups
	            .filter(function (group) { return _this.state.grouping.test(group); })
	            .map(function (group, n) {
	            /**
	             * Adding leader(s) to an own list on each group.
	             */
	            var leader = _this.state.members
	                .filter(function (m) {
	                return m.group.indexOf(group) !== -1 && m.group.indexOf('Leader') !== -1;
	            })
	                .map(function (m, i) {
	                var mail;
	                if (m.mail && m.mail.length) {
	                    mail = (React.createElement("div", { className: "team-member-mail" },
	                        React.createElement("a", { href: 'mailto:' + m.mail, onMouseOver: _this.transformMailAddress },
	                            React.createElement("i", { className: "fa fa-envelope", "aria-hidden": "true" }))));
	                }
	                return (React.createElement("div", { key: i, className: "team-member team-leader" },
	                    React.createElement("div", { className: "team-member-image" },
	                        React.createElement("img", { src: m.image }),
	                        mail),
	                    React.createElement("div", { className: "team-member-name" }, m.name),
	                    React.createElement("div", { className: "team-member-role" }, m.role)));
	            });
	            /**
	             * Adding the rest of the members which is not a leader.
	             */
	            var members = _this.state.members
	                .filter(function (m) {
	                return m.group.indexOf(group) !== -1 && m.group.indexOf('Leader') == -1;
	            })
	                .map(function (m, i) {
	                var mail;
	                if (m.mail && m.mail.length) {
	                    mail = (React.createElement("div", { className: "team-member-mail" },
	                        React.createElement("a", { href: 'mailto:' + m.mail, onMouseOver: _this.transformMailAddress },
	                            React.createElement("i", { className: "fa fa-envelope", "aria-hidden": "true" }))));
	                }
	                return (React.createElement("div", { key: i, className: "team-member" },
	                    React.createElement("div", { className: "team-member-image" },
	                        React.createElement("img", { src: m.image }),
	                        mail),
	                    React.createElement("div", { className: "team-member-name" }, m.name),
	                    React.createElement("div", { className: "team-member-role" }, m.role)));
	            });
	            return (React.createElement(PageLayout_1.SubSection, { key: n, className: "teampage-team centered page-container-big", "data-group": group.toLowerCase() },
	                React.createElement("div", { className: "team-leaders" },
	                    leader,
	                    React.createElement("div", { className: "team-description" },
	                        React.createElement("div", { className: "team-title" }, group),
	                        React.createElement("div", { className: "team-text" }, _this.groupTexts[group]))),
	                React.createElement("div", { className: "team-members" }, members)));
	        });
	        return (React.createElement("div", { className: "page page-team" },
	            React.createElement(PageLayout_1.Section, { className: "page-container-big" },
	                React.createElement(PageLayout_1.SubSection, { className: "page-container-big" },
	                    React.createElement("div", { className: "team-page-header" },
	                        React.createElement("div", null,
	                            React.createElement("h1", null, "The Team")),
	                        React.createElement("div", null,
	                            React.createElement(react_router_1.Link, { to: "/team/2016", activeClassName: "active" },
	                                React.createElement("button", null, "2016")),
	                            React.createElement(react_router_1.Link, { to: "/team/2017", activeClassName: "active" },
	                                React.createElement("button", null, "2017")),
	                            React.createElement(react_router_1.IndexLink, { to: "/team/2018", activeClassName: "active" },
	                                React.createElement("button", { className: this.props.params.year ? '' : 'active' }, "2018"))))),
	                React.createElement(PageLayout_1.SubSection, { className: "page-container-big" }, team_photo),
	                React.createElement(PageLayout_1.SubSection, { titleText: "Groups", className: "page-container-big" },
	                    "We have five groups: Control, Perception, AI, Hardware and Admin. The board consists of the project manager, the deputy project manager, the technical leader and the group leaders. This means that we formally have a quite hierarchical stucture. However, in practice we have a very flat structure where everybody contributes within the areas they want and where attention is needed.",
	                    groups))));
	    };
	    return TeamPage;
	}(React.Component));
	exports.TeamPage = TeamPage;
	exports.default = TeamPage;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var PageLayout_1 = __webpack_require__(72);
	var breadcrumb_1 = __webpack_require__(129);
	var JoinPage = (function (_super) {
	    __extends(JoinPage, _super);
	    function JoinPage(props) {
	        var _this = _super.call(this, props) || this;
	        // This is for avoiding showing mails on GitHub in plaintext.
	        _this.emails = [
	            'brage.eikanger',
	            'vebjorn.isaksen',
	            'emilie.udnaes',
	            'simon.blindheim',
	            'matias.christensen',
	        ].map(function (e) { return e + "@"; });
	        _this.state = {
	            language: props.params.language || 'no'
	        };
	        return _this;
	    }
	    JoinPage.prototype.componentWillReceiveProps = function (nextProps) {
	        this.setState(Object.assign({}, this.state, {
	            language: nextProps.params.language || 'no'
	        }));
	    };
	    JoinPage.prototype.setAnchor = function (anchor) {
	        var top = document.getElementById(anchor).offsetTop - 150;
	        if (document.querySelector('body').scrollTop > 0) {
	            document.querySelector('body').scrollTop = top;
	        }
	        else {
	            document.querySelector('#app').scrollTop = top;
	        }
	    };
	    JoinPage.prototype.render = function () {
	        var _this = this;
	        var positions = {
	            'en': [
	                React.createElement("div", null)
	            ],
	            'no': [
	                React.createElement(PageLayout_1.SubSection, { titleText: "Stillinger", key: "1" },
	                    React.createElement("ul", { className: "anchor-list" },
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("hardware-gruppemedlem"); } },
	                            React.createElement("a", null, "Hardware gruppemedlem")),
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("teknisk-gruppeleder-hardware"); } },
	                            React.createElement("a", null, "Teknisk gruppeleder - Hardware")),
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("perception-gruppemedlem"); } },
	                            React.createElement("a", null, "Perception gruppemedlem")),
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("teknisk-gruppeleder-perception"); } },
	                            React.createElement("a", null, "Teknisk gruppeleder - Perception")),
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("control-gruppemedlem"); } },
	                            React.createElement("a", null, "Control gruppemedlem")),
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("ai-gruppemedlem"); } },
	                            React.createElement("a", null, "AI gruppemedlem")),
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("sponsorkontakt"); } },
	                            React.createElement("a", null, "Sponsorkontakt")),
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("grafisk-designer"); } },
	                            React.createElement("a", null, "Grafisk designer")),
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("event-manager"); } },
	                            React.createElement("a", null, "Event Manager")),
	                        React.createElement("li", { onClick: function () { return _this.setAnchor("webutvikler"); } },
	                            React.createElement("a", null, "Webutvikler"))),
	                    React.createElement("h3", null, "Hardware gruppemedlem"),
	                    React.createElement("p", { id: "hardware-gruppemedlem" },
	                        "Det er Hardware gruppen som designer og bygger selve dronene til Ascend, og her kan du jobbe med litt av hvert. Gruppen er en krysning mellom mekanisk ingeni\u00F8rvitenskap, produktdesign og elektronikk. Dette involverer \u00E5 kunne designe og produsere delene til dronen, designe det elektriske systemet ombord p\u00E5 dronen og samarbeide med de andre gruppene for \u00E5 integrere sensorikk og datamaskinene vi har ombord! Her trenger vi mange forskjellige talenter. Du vil bli kurset i slik teknologi om du ikke har erfaring med det fra f\u00F8r. ",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Mekanisk design, Produktdesign, Elektrisk design, Kretskortdesign, Styrkeberegning, Materialvalg, Aerodynamikk")),
	                    React.createElement("h3", null, "Teknisk gruppeleder - Hardware"),
	                    React.createElement("p", { id: "teknisk-gruppeleder-hardware" },
	                        "Som teknisk gruppeleder er det ditt ansvar \u00E5 holde oversikt over det tekniske arbeidet som m\u00E5 gj\u00F8res p\u00E5 gruppen din, s\u00F8rge for at alle har det de trenger, s\u00F8rge for at gruppen kommuniserer med de andre tekniske gruppene og at alle i Ascend er oppdatert. Du vil fordele arbeidsoppgaver samtidig som du selv blir \u00E5 gj\u00F8re like mye hands-on teknisk arbeid som gruppen din. Du vil ogs\u00E5 bli kurset i ledelse om du ikke har erfaring med det fra f\u00F8r. ",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Ledelse, Mekanisk design, Produktdesign, Elektrisk design, Kretskortdesign, Styrkeberegning, Materialvalg, Aerodynamikk.")),
	                    React.createElement("h3", null, "Perception gruppemedlem"),
	                    React.createElement("p", { id: "perception-gruppemedlem" },
	                        "Perception gruppen jobber med \u00E5 f\u00E5 dronen til \u00E5 oppfatte sine omgivelser, forst\u00E5 hva den ser og hvor den er til en hver tid. Dette er en av de store utfordringene n\u00E5r man driver med robotikk, og hele Ascend er avhengig av at Perception leverer smarte l\u00F8sninger. Dronen v\u00E5r skal samle inn video fra kamera og en rekke sensorer og kombinerer dette p\u00E5 en smart m\u00E5te for \u00E5 bygge et bilde av omverdenen som dronen mener er forst\u00E5elig. Som gruppemedlem i denne gruppen vil du jobbe med \u00E5 skrive kunstig intelligent programvare og smarte algoritmer som klarer \u00E5 ta slik kompleks r\u00E5 data og transformere det til noe enkelt. En kombinasjon av deep learning, transformasjoner og statistikk er sentralt. Vi trenger ogs\u00E5 en lur m\u00E5te \u00E5 fjerne signalst\u00F8y fra systemene v\u00E5re slik at de andre gruppene i Ascend kan f\u00E5 servert datasyn av h\u00F8y kvalitet. Du vil bli kurset i slik teknologi om du ikke har erfaring med det fra f\u00F8r. ",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Datasyn, Visuell databehandling, Deep Learning, Kunstig Intelligens programmering, filtrering, Kalmanfilter, Sensorikk.")),
	                    React.createElement("h3", null, "Teknisk gruppeleder - Perception"),
	                    React.createElement("p", { id: "teknisk-gruppeleder-perception" },
	                        "Som teknisk gruppeleder er det ditt ansvar \u00E5 holde oversikt over det tekniske arbeidet som m\u00E5 gj\u00F8res p\u00E5 gruppen din, s\u00F8rge for at alle har det de trenger, s\u00F8rge for at gruppen kommuniserer med de andre tekniske gruppene og at alle i Ascend er oppdatert. Du vil fordele arbeidsoppgaver samtidig som du selv blir \u00E5 gj\u00F8re like mye hands-on teknisk arbeid som gruppen din. Du vil ogs\u00E5 bli kurset i ledelse om du ikke har erfaring med dette fra f\u00F8r. ",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Ledelse, Datasyn, Visuell databehandling, Deep Learning, Kunstig Intelligens programmering, Sensorikk. ")),
	                    React.createElement("h3", null, "Control gruppemedlem"),
	                    React.createElement("p", { id: "control-gruppemedlem" },
	                        "Control har ansvaret for \u00E5 f\u00E5 dronen til \u00E5 utf\u00F8re kommandoer autonomt og p\u00E5 en p\u00E5litelig og robust m\u00E5te. I control vil du jobbe med systemene som skal f\u00E5 dronen til \u00E5 fly presist og stabilt rundt i rommet uten \u00E5 kollidere i hindringene p\u00E5 veien, gjerne raskt og effektivt! Alt skal foreg\u00E5 autonomt s\u00E5 dronen m\u00E5 selv finne ut hvilke handlinger den m\u00E5 gj\u00F8re for \u00E5 klare \u00E5 utf\u00F8re kommandoen den f\u00E5r tilsendt! Som gruppemedlem f\u00E5r du mulighet til \u00E5 jobbe p\u00E5 alt fra lavniv\u00E5 flykontrollere som s\u00F8rger for \u00E5 holde dronen stabil, til h\u00F8yniv\u00E5 ruteplanlegging og kollisjonsunng\u00E5else som s\u00F8rger for at dronen kan styre rundt i rommet og gjennomf\u00F8re prestisjefulle man\u00F8vre. ",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Reguleringsteknikk, C/C++, ROS,  tilstandsmaskin, embedded, ruteplanlegging")),
	                    React.createElement("p", { id: "ai-gruppemedlem" },
	                        React.createElement("h3", null, "AI gruppemedlem"),
	                        React.createElement("i", null, " \"Hva skal dronen gj\u00F8re, og hvorfor er det lurt?\" "),
	                        "Som medlem av AI gruppen jobber du med den overordnede kunstige intelligensen (AI) til dronen. Det er gruppen sitt ansvar \u00E5  produsere en AI som kan analysere informasjonen om verden rundt seg og gjennom dette skal den kunne ta beslutninger p\u00E5 egen h\u00E5nd og gjerne det smarteste valget. Som medlem av denne gruppen vil du v\u00E6re med p\u00E5 \u00E5 tenke nyskapende mens du trener droner i simulatorer, i virkeligheten og skriver avansert programvare. Du vil bli kurset i kunstig intelligens om du ikke har erfaring med det fra f\u00F8r. ",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Kunstig Intelligens Programmering, Maskinl\u00E6ring, Deep Learning, Reinforcement Learning, Algoritmer og Datastrukturer, Statistikk. ")),
	                    React.createElement("h3", null, "Sponsorkontakt"),
	                    React.createElement("p", { id: "sponsorkontakt" },
	                        "Har du lyst til \u00E5 v\u00E6re Ascend NTNU sin representant i n\u00E6ringslivet? Vi i Ascend er helt avhengig av v\u00E5re sponsorer for \u00E5 kunne gj\u00F8re det arbeidet vi gj\u00F8r. Som sponsorkontakt i Ascend har du som hovedoppgave \u00E5 skape mest mulig verdiskapning for v\u00E5re sponsorer. Du vil jobbe med \u00E5 finne nye sponsorer, forhandle kontrakter og oppretholde god kommunikasjon med v\u00E5re eksisternede sponsorer. Du vil ogs\u00E5 jobbe tett sammen med hele kommunikasjonsgruppen for \u00E5 videreutvikle Ascends \"image\" utad og spesielt event manageren v\u00E5r for \u00E5 planlegge og organisere sponsoraktiviteter.",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Presentasjonteknikk, Gode Forhandlingsevner, Utadvent, Organisert")),
	                    React.createElement("h3", null, "Grafisk designer"),
	                    React.createElement("p", { id: "grafisk-designer" },
	                        "Bli med p\u00E5 \u00E5 forme hele Ascend NTNU sitt \"image\" utad. Som grafisk designer vil du lage alt fra markedsmateriell til profileringartikler og du vil skape en ordentlig grafisk utforming i alt vi gj\u00F8r. Du vil jobbe tett sammen med hele kommunikasjons gruppen, blant annet ved \u00E5 bidra til v\u00E5r blog, lage v\u00E5rt aller f\u00F8rste magasin og bidra til utformingen av stand. Det er et pluss om du vil hjelpe til med videoer, 3D visualisering eller motion design, men det er ikke et krav. ",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Design, t-skjorter, genser, jakker, visittkort, medaljer, roll-ups, flyers, postere, webdesign, magasin design, redakt\u00F8r, video, motion design, 3D visualisering. ")),
	                    React.createElement("h3", null, "Event Manager"),
	                    React.createElement("p", { id: "event-manager" },
	                        "Som Event Manager f\u00E5r du muligheten til \u00E5 arrangere events som ikke bare n\u00E5r ut til alle studentene p\u00E5 NTNU, men i tillegg b\u00E5de til presse og n\u00E6ringsliv i hele Norge. Du f\u00E5r ansvaret for \u00E5 arrangere ulike stands og fremf\u00F8ringer p\u00E5 ulike arrangementer, b\u00E5de internt p\u00E5 NTNU og utad mot n\u00E6ringslivet. Du vil ogs\u00E5 f\u00E5 ansvaret for organiseringen av v\u00E5re opptaksperioder i tillegg til \u00E5 arrangere egne arrangementer som for eksempel robotikk dag og live-demo/unveiling. Som Event Manager vil du jobbe tett sammen med hele kommunikasjons gruppen, spesielt v\u00E5r sponsorkontakt for \u00E5 fremme Ascend til potensielle nye medlemmer og sponsorer. Du vil ogs\u00E5 v\u00E6re med p\u00E5 \u00E5 planlegge den \u00E5rlige turen v\u00E5r til USA. ",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Presentasjonteknikk, Organisert, Standutforming, Arrangementplanlegging, Organisering av stands.")),
	                    React.createElement("h3", null, "Webutvikler"),
	                    React.createElement("p", { id: "webutvikler" },
	                        "Har du lyst \u00E5 utvikle en full-stack, skalerbar og grafisk imponerende webside? Som webutvikler vil du ha ansvar for \u00E5 videreutvikle v\u00E5r hjemmeside ascendntnu.no. Det blir ogs\u00E5 din oppgave \u00E5 vise frem hvem vi er, v\u00E5re m\u00E5l og hvilke utfordringer vi m\u00F8ter p\u00E5 en interaktiv og spennende m\u00E5te, kanskje ved \u00E5 lage en liten spill app? Du vil jobbe tett sammen med hele kommunikasjons gruppen for \u00E5 videreutvikle Ascends \"image\" utad. Du kan ogs\u00E5 ta p\u00E5 deg ansvaret med system administrasjon, det vil si at du blant annet f\u00E5r bygge og vedlikeholde v\u00E5re byggservere og s\u00F8rge for at alt g\u00E5r s\u00E5 automatisk og knirkefritt som mulig. Du vil bli kurset i webutvikling (og noe sysadmin) om du ikke har erfaring med det fra f\u00F8r. ",
	                        React.createElement("br", null),
	                        React.createElement("i", { className: "key-words" }, "N\u00F8kkelord: Webutvikling, full-stack (backend og frontend), grafisk design, react, typescript, app utvikling. Sysadmin, continous integration, github hooks, server managment"))),
	                React.createElement(PageLayout_1.SubSection, { titleText: "Stillinger", key: "2" },
	                    React.createElement(PageLayout_1.SubSubSection, { titleText: "Prosjektleder/Nestleder" },
	                        React.createElement("p", null, "Prosjektleder er styrets leder og jobber med \u00E5 videreutvikle Ascend i \u00F8nsket retning basert p\u00E5 Ascends visjoner og m\u00E5l. Prosjektleder jobber tett opp mot alle Ascends undergrupper og koordinerer mye av arbeidet som skjer mellom gruppene. Sammen med kommunikasjonsgruppen jobber prosjektleder for \u00E5 fremme Ascends omd\u00F8mme, planlegge opptak, og jobbe med sponsorer. Arbeidsoppgavene man har vil variere fra uke til uke og gir muligheter til \u00E5 jobbe med de fleste aspekter i prosjektet. Faste oppgaver inkluderer \u00E5 lede styrem\u00F8ter og allm\u00F8ter, og ansvar for samarbeid med hovedsponsor."),
	                        React.createElement("p", null, "Som nestleder har man mange spennende oppgaver. F\u00F8rst og fremst er man hovedansvarlig for rekruttering av nytt styre, nye gruppemedlemmer, gruppeledere og arbeid med masteroppgaver. Man skal ogs\u00E5 bist\u00E5 prosjektleder med planlegging, oppf\u00F8lging og m\u00E5lsetting. Videre holder man medarbeidersamtaler for \u00E5 sikre at alle gruppemedlemmene blir h\u00F8rt, samt at man er en tillitsperson for gruppemedlemmene."),
	                        React.createElement("p", null, "Prosjektleder og nestleder jobber tett sammen og fordeler arbeidsoppgaver mellom seg. Dette samarbeidet gir en stor fleksibilitet n\u00E5r det kommer til arbeidsoppgaver, og lar begge to tilpasse ansvarsomr\u00E5der slik at man kan jobbe med det man har st\u00F8rst interesse for."),
	                        React.createElement("p", null,
	                            React.createElement("b", null, "Vi ser etter")),
	                        React.createElement("ul", null,
	                            React.createElement("li", null, "Deg som \u00F8nsker \u00E5 jobbe tett med hele organisasjonen og liker varierte arbeidsoppgaver"),
	                            React.createElement("li", null, "Deg som vil jobbe med eksterne akt\u00F8rer, sponsorer og andre samarbeidspartnere."),
	                            React.createElement("li", null, "Deg som vil finne gode l\u00F8sninger i samarbeid med andre og tar utfordringer p\u00E5 strak arm. "),
	                            React.createElement("li", null, "Deg som har god struktur og oversikt, og liker \u00E5 jobbe med organisasjonen som en helhet.")),
	                        React.createElement("p", null,
	                            "Har du sp\u00F8rsm\u00E5l om denne stillingen kan du kontakte Brage Eikanger (Prosjektleder) p\u00E5 ",
	                            React.createElement("a", { href: "mailto:" + this.emails[0] + "ascendntnu.no" },
	                                this.emails[0],
	                                "ascendntnu.no"),
	                            ", eller Vebj\u00F8rn Isaksen (Nestleder) p\u00E5 ",
	                            React.createElement("a", { href: "mailto:" + this.emails[1] + "ascendntnu.no" },
	                                this.emails[1],
	                                "ascendntnu.no"),
	                            ".")),
	                    React.createElement(PageLayout_1.SubSubSection, { titleText: "Teknisk Leder" },
	                        React.createElement("p", null, "Som teknisk leder har du det overordnede ansvaret for all teknisk arbeid i Ascend. Dette inneb\u00E6rer \u00E5 planlegge, organisere og samkj\u00F8re det tekniske arbeidet sammen med gruppelederne. Som teknisk leder er det din oppgave \u00E5 lede det tekniske arbeidet slik at alle de tekniske gruppene jobber mot samme m\u00E5l. Du m\u00E5 ha en god innsikt i hele systemet som utvikler slik at arbeidet kan legges til rette for \u00E5 unng\u00E5 potensielle tekniske problemer og integreres p\u00E5 en best mulig m\u00E5te. Teknisk leder jobber tett med alle de tekniske gruppelederene og gruppemedlemmene, og bist\u00E5r med det tekniske der det til enhver tid er st\u00F8rt behov. Jobben vil gi deg en innsikt og erfaring i en rekke forskjellige ingeni\u00F8rdisipliner, og gi deg et helhetsbilde som f\u00E5 andre har."),
	                        React.createElement("p", null, "Teknisk leder fungerer som representant for det tekniske inn mot styret og admin gruppen. Jobben inneb\u00E6rer derfor ogs\u00E5 \u00E5 jobbe sammen med de administrative stillingene. Oppgaver som \u00E5 planlegge innkj\u00F8p av teknisk utstyr sammen med \u00F8konomiansvarlig og bist\u00E5 med formidlingen av det tekniske arbeidet sammen med kommunikasjonslederen."),
	                        React.createElement("p", null,
	                            React.createElement("b", null, "Vi ser etter")),
	                        React.createElement("ul", null,
	                            React.createElement("li", null, "Du som har gode lederegenskaper."),
	                            React.createElement("li", null, "Du som har stor teknisk interesse for robotikk."),
	                            React.createElement("li", null, "Du som liker \u00E5 jobbe med store kompliserte systemer."),
	                            React.createElement("li", null, "Du som er strukturert, ryddig og organisert.")),
	                        React.createElement("p", null,
	                            "Har du sp\u00F8rsm\u00E5l om denne stillingen kan du kontakte Matias Christensen p\u00E5 ",
	                            React.createElement("a", { href: "mailto:" + this.emails[4] + "ascendntnu.no" },
	                                this.emails[4],
	                                "ascendntnu.no"),
	                            ".")),
	                    React.createElement(PageLayout_1.SubSubSection, { titleText: "Kommunikasjonsleder" },
	                        React.createElement("p", null, "For \u00E5 lykkes med dette ambisi\u00F8se prosjektet er Ascend avhengig av gode samarbeid, b\u00E5de med industri og utdanningsinstitusjoner. Som markedsansvarlig vil du s\u00F8rge for finansieringen og samarbeidene som bringer Ascend n\u00E6rmere sine m\u00E5l. Dette inneb\u00E6rer \u00E5 oppn\u00E5 avtaler med nye spennende sponsorer, samt \u00E5 pleie relasjonene til v\u00E5re eksisterende samarbeidspartnere. Det inneb\u00E6rer ogs\u00E5 h\u00E5ndtering av presse og skriving av pressemeldinger. Dette vil du bli kurset i hvis du ikke har erfaring med det fra f\u00F8r. Kommunikasjonsleder har ansvaret for at facebooksiden og internettsiden er vedlikeholdt og oppdatert jevnlig. Dette inneb\u00E6rer \u00E5 v\u00E6re kreativ og ha gode kommunikasjonsevner."),
	                        React.createElement("p", null, "Enda viktigere enn sponsorer og industrisamarbeid, er dyktige og engasjerte studenter. Ascend har som m\u00E5l \u00E5 bli en vedvarende studentorganisajon som er godt kjent p\u00E5 NTNU Gl\u00F8shaugen. Som kommunikasjonsleder har du all friheten til \u00E5 finne m\u00E5ter \u00E5 n\u00E5 ut til studentene p\u00E5, med konkrete og m\u00E5lbare resultater. Som en relativt nyoppstarta organisasjon (2015) vil du ha betydelig innvirkning p\u00E5 merkevarebyggingen til Ascend. Dette inneb\u00E6rer \u00E5 skape en kultur utad som inspirer studenter til \u00E5 drive med forskning og innovasjon p\u00E5 autonome droner."),
	                        React.createElement("p", null,
	                            React.createElement("b", null, "Vi ser etter")),
	                        React.createElement("ul", null,
	                            React.createElement("li", null, "Du som har interesse for markedsf\u00F8ring b\u00E5de i sosiale og fysiske medier."),
	                            React.createElement("li", null, "Du som er interessert i \u00E5 skape og pleie relasjoner til samarbeidspartnere og presse."),
	                            React.createElement("li", null, "Du som har erfaring med grafikk og/eller web-utvikling (et stort pluss - men ikke et krav)."),
	                            React.createElement("li", null, "Du som er l\u00F8sningsorientert, kreativ, ambisi\u00F8s, samarbeidsvillig, m\u00E5lrettet og resultatdrevet")),
	                        React.createElement("p", null,
	                            "Har du sp\u00F8rsm\u00E5l om denne stillingen kan du kontakte Emilie Udn\u00E6s p\u00E5 ",
	                            React.createElement("a", { href: "mailto:" + this.emails[2] + "ascendntnu.no" },
	                                this.emails[2],
	                                "ascendntnu.no"),
	                            ".")),
	                    React.createElement(PageLayout_1.SubSubSection, { titleText: "konomiansvarlig" },
	                        React.createElement("p", null, "Som \u00F8konomiansvarlig har du kontroll p\u00E5 organisasjonens ressursbruk. Ascend opererer som I likhet med andre organisasjoner innenfor visse \u00F8konomiske rammer, og en p\u00E5litelig samt forutsigbar flyt av ressurser kan dermed hjelpe resten av teamet \u00E5 oppn\u00E5 sitt fulle potensial."),
	                        React.createElement("p", null, "Din oppgave vil hovedsaklig v\u00E6re \u00E5 forsikre at styret har oversiktlig regnskap, kontobalanse og budsjetter tilgjengelig i forbindelse med avgj\u00F8relser for b\u00E5de teknisk og organisatorisk drift. I tillegg vil du ha ansvar for \u00E5 holde oversikt over interne utlegg, inventar og likviditet, og selvf\u00F8lgelig s\u00F8rge for at innkommende fakturaer blir betalt til rett tid."),
	                        React.createElement("p", null,
	                            React.createElement("b", null, "Vi ser etter")),
	                        React.createElement("ul", null,
	                            React.createElement("li", null, "Du som har interesse for \u00F8konomi, regnskapsf\u00F8ring og budsjettplanlegging."),
	                            React.createElement("li", null, "Du som har kunnskap om, eller interesse for \u00E5 l\u00E6re om f\u00F8ring av \u00F8konomi i organisasjoner."),
	                            React.createElement("li", null, "Du som har ryddige og oversiktlige arbeidsmetoder.")),
	                        React.createElement("p", null,
	                            "Har du sp\u00F8rsm\u00E5l om denne stillingen kan du kontakte Simon Blindheim p\u00E5 ",
	                            React.createElement("a", { href: "mailto:" + this.emails[3] + "ascendntnu.no" },
	                                this.emails[3],
	                                "ascendntnu.no"),
	                            ".")))
	            ]
	        };
	        var contents = {
	            'en': [
	                React.createElement("div", null)
	            ],
	            'no': [
	                React.createElement(PageLayout_1.Section, { titleText: "N nye hyder - Sk Ascend!", key: "1" },
	                    React.createElement("img", { src: "/images/teams/2017/ascend-group-2017.jpg", className: "fullscale-image" }),
	                    React.createElement("p", { style: { fontSize: '1.4em' } },
	                        React.createElement("b", null, "S\u00F8knadsfrist 1. september kl. 23:59")),
	                    React.createElement("p", { style: { fontSize: '1.4em', marginTop: "0px" } },
	                        React.createElement("a", { href: "https://www.facebook.com/events/675218906021421" },
	                            "Bli med p\u00E5 infom\u00F8te 31. August 16:15 i ",
	                            React.createElement("del", null, "EL3"),
	                            "S4")),
	                    React.createElement("p", null, "\u00D8nsker du \u00E5 v\u00E6re med p\u00E5 \u00E5 drive med cutting-edge droneteknologi i en ambisi\u00F8s og teknologi-fokusert studentorganisasjon?"),
	                    React.createElement("p", null, "Tidligere erfaring er ikke et krav for \u00E5 bli med i Ascend. Det viktigste er \u00E5 ha en interesse for det vi jobber med, og en interesse for \u00E5 l\u00E6re."),
	                    React.createElement("a", { className: "button active", style: { alignSelf: 'flex-start' }, href: "https://docs.google.com/forms/d/e/1FAIpQLSe2ieI86nG7RXWN12PTOT08pbPO9zJoaO2Xmq0IjTLKsdGuAA/viewform" }, "S\u00F8k her!"),
	                    positions[this.state.language][0],
	                    React.createElement("i", null,
	                        "Det er kun studenter som studerer p\u00E5 NTNU i \u00E5ret 2017/2018 som kan s\u00F8ke. Er du usikker p\u00E5 om dette gjelder for deg? Sp\u00F8r oss p\u00E5 ",
	                        React.createElement("a", { href: "mailto:hi@ascendntnu.no" }, "hi@ascendntnu.no")),
	                    React.createElement(PageLayout_1.SubSection, { titleText: "Hvorfor ske" },
	                        React.createElement("ul", null,
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Bli en del av et milj\u00F8."),
	                                " I Ascend blir du en del av et m\u00E5lrettet og teknologifokusert prosjekt der vi jobber sammen for \u00E5 n\u00E5 v\u00E5re m\u00E5l. "),
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Fra teori til praksis."),
	                                " I Ascend tar man noen av de mest avanserte konseptene man l\u00E6rer p\u00E5 NTNU fra l\u00E6reb\u00F8kene til virkeligheten."),
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Kombiner med graden din."),
	                                " Flere av medlemmene v\u00E5re skriver prosjekt/master-oppgave relatert til Ascend. I tillegg finnes det en \u00E5pning for \u00E5 drive med Ascend i Eksperter i Team."),
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Prosjekt/organisasjons-erfaring."),
	                                " I Ascend er du med p\u00E5 \u00E5 f\u00F8re et teknisk prosjekt fra start til slutt - dette gir mye verdifull erfaring og kompetanse p\u00E5 veien."),
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Cutting edge."),
	                                " Bli en del av en organisasjon som m\u00E5 ta i bruk og utvikle teknologi som er state of the art innenfor autonom robotikk. "),
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Kreativ, fleksibel og innovativ kultur"),
	                                " Vi \u00F8nsker \u00E5 holde en flytende arbeidskultur i Ascend slik at ditt bidrag til organisasjonen kan ogs\u00E5 involvere oppgaver utenfor stillingsbeskrivelsen som vil bli inspirert av dine interesser og erfaringer!"))),
	                    React.createElement(PageLayout_1.SubSection, { titleText: "Konkurransen" },
	                        React.createElement("p", null, "International Aerial robotics competition (IARC) er en \u00E5rlig konkurranse som avholdes i USA og Kina med m\u00E5l om \u00E5 presse grensene for hva man f\u00E5r til med autonome droner. Dette gj\u00F8r de ved \u00E5 presentere meningsfulle og nyttige oppdrag som er umulige \u00E5 l\u00F8se p\u00E5 det tidspunktet de lanseres. Ideen er at n\u00E5r den oppf\u00F8rselen som ettersp\u00F8rres til slutt demonstres i konkurransen, vil konkurransen ha bidratt til en meningsfull utvikling innenfor autonom robotikk. En utvikling som fortrinnsvis er til fordel for verden."),
	                        React.createElement("p", null,
	                            React.createElement("a", { href: "https://ascendntnu.no/blog/2017-07-20-the-competition", role: "button" }, "Les mer om konkurransen og om oppdraget vi skal l\u00F8se her.")))),
	                React.createElement(PageLayout_1.Section, { titleText: "N nye hyder - Sk Ascend!", key: "2" },
	                    React.createElement("img", { src: "/images/teams/2017/ascend-group-2017.jpg", className: "fullscale-image" }),
	                    React.createElement("p", null, "\u00D8nsker du \u00E5 v\u00E6re med p\u00E5 \u00E5 drive med cutting-edge droneteknologi i en ambisi\u00F8s og teknologi-fokusert studentorganisasjon?"),
	                    React.createElement("p", null, "Tidligere erfaring er ikke et krav for \u00E5 bli med i Ascend. Det viktigste er \u00E5 ha en interesse for det vi jobber med, og en interesse for \u00E5 l\u00E6re."),
	                    React.createElement("p", null, "Ascend NTNU har hovedopptak p\u00E5 h\u00F8sten hvert \u00E5r for \u00E5 ta inn nye medlemmer."),
	                    React.createElement("p", null,
	                        React.createElement("strong", null, "Ny mulighet vil annonseres til v\u00E5ren og h\u00F8sten neste \u00E5r. Hvis du vil bli oppdatert om denne - skriv deg opp p\u00E5 linken under!")),
	                    React.createElement("a", { className: "button active", style: { alignSelf: 'flex-start' }, href: "http://ascendntnu.us14.list-manage2.com/subscribe?u=dfce303a41ce42b342c75a3ef&id=002e04db12", target: "_blank" }, "Interesseliste for opptak"),
	                    React.createElement(PageLayout_1.SubSection, { titleText: "Hvorfor ske" },
	                        React.createElement("ul", null,
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Bli en del av et milj\u00F8."),
	                                " I Ascend blir du en del av et m\u00E5lrettet teknologifokusert prosjekt der vi jobber sammen for \u00E5 n\u00E5 v\u00E5re m\u00E5l. "),
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Fra teori til praksis."),
	                                " I Ascend tar man noen av de mest avanserte konseptene man l\u00E6rer p\u00E5 NTNU fra l\u00E6reb\u00F8kene til virkeligheten."),
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Kombiner med graden din."),
	                                " Flere av medlemmene v\u00E5re skriver prosjekt/master-oppgave relatert til Ascend. I tillegg finnes det en \u00E5pning for \u00E5 drive med Ascend i Eksperter i Team."),
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Prosjekt/organisasjons-erfaring."),
	                                " I Ascend er du med p\u00E5 \u00E5 f\u00F8re et teknisk prosjekt fra start til slutt - dette gir mye verdifull erfaring og kompetanse p\u00E5 veien."),
	                            React.createElement("li", null,
	                                React.createElement("strong", null, "Cutting edge."),
	                                " Bli en del av en organisasjon som m\u00E5 ta i bruk og utvikle teknologi som er state of the art innenfor autonom robotikk. "))),
	                    React.createElement(PageLayout_1.SubSection, { titleText: "Konkurransen" },
	                        React.createElement("p", null, "International Aerial robotics competition (IARC) er en \u00E5rlig konkurranse som avholdes i USA og Kina med m\u00E5l om \u00E5 presse grensene for hva man f\u00E5r til med autonome droner. Dette gj\u00F8r de ved \u00E5 presentere meningsfulle og nyttige oppdrag som er umulige \u00E5 l\u00F8se p\u00E5 det tidspunktet de lanseres. Ideen er at n\u00E5r den oppf\u00F8rselen som ettersp\u00F8rres til slutt demonstres i konkurransen, vil konkurransen ha bidratt til en meningsfull utvikling innenfor autonom robotikk. En utvikling som fortrinnsvis er til fordel for verden."),
	                        React.createElement("p", null,
	                            React.createElement("a", { href: "https://ascendntnu.no/blog/2017-07-20-the-competition", role: "button" }, "Les mer om konkurransen og om oppdraget vi skal l\u00F8se her."))))
	            ]
	        };
	        var about = {
	            'en': (React.createElement("div", null)),
	            'no': (React.createElement(PageLayout_1.Section, { titleText: "Om oss" },
	                React.createElement("p", null,
	                    "Ascend er en studentorganisasjon som skal representere NTNU i ",
	                    React.createElement("a", { href: "http://www.aerialroboticscompetition.org/" }, "The International Aerial Robotics Competition"),
	                    ". Vi \u00F8nsker \u00E5 skape et milj\u00F8 hvor studenter kan drive med autonome droner, og ha den \u00E5rlige konkurransen som et felles m\u00E5l. Vi ser p\u00E5 Ascend som en arena for \u00E5 videreutvikle tekniske ferdigheter s\u00E5 vel som ferdigheter innenfor prosjektstyring og andre administrative oppgaver."),
	                React.createElement(PageLayout_1.SubSection, { titleText: "Hvordan vi jobber" },
	                    React.createElement("ul", null,
	                        React.createElement("li", null,
	                            React.createElement("strong", null, "Flat og \u00E5pen struktur."),
	                            " Ascend NTNU har troen p\u00E5 at en flat og \u00E5pen struktur egner seg best for b\u00E5de trivsel og resultat. V\u00E5rt m\u00E5l er \u00E5 v\u00E6re en organisasjon der alle har anledning til \u00E5 bli h\u00F8rt og bidra p\u00E5 de omr\u00E5dene de \u00F8nsker."),
	                        React.createElement("li", null,
	                            React.createElement("strong", null, "Frihet og ansvar."),
	                            " Vi mener at motivasjon handler om \u00E5 bli gitt b\u00E5de ansvar og tillit. Vi velger \u00E5 stole p\u00E5 at medlemmene v\u00E5re f\u00E5r jobben gjort, fremfor \u00E5 bygge tidkrevende og demotiverende kontrollsystemer."),
	                        React.createElement("li", null,
	                            React.createElement("strong", null, "Learning by doing."),
	                            " Ingen i Ascend sitter p\u00E5 fullstendige l\u00F8sninger til utfordringene vi m\u00F8ter. Vi er derimot \u00E5pne for \u00E5 l\u00E6re nye konsepter og teknologier. V\u00E5r id\u00E9 er at veien til m\u00E5let g\u00E5r gjennom pr\u00F8ving og feiling, nye kunnskaper og gode r\u00E5dgivere."))),
	                React.createElement(PageLayout_1.SubSection, { titleText: "Vre samarbeidsplattformer" },
	                    React.createElement("ul", null,
	                        React.createElement("li", null,
	                            React.createElement("strong", null, "Slack: "),
	                            " ",
	                            React.createElement("a", { href: "https://slack.com/" }, "Slack"),
	                            " er en chatte-web-app for team. Med Slack f\u00E5r vi enkel, \u00E5pen og oversiktlig kommunikasjon - hvor alle f\u00E5r muligheten til \u00E5 f\u00F8lge med og bidra p\u00E5 de omr\u00E5dene de \u00F8nsker. P\u00E5 grunn av Slack er det nesten ingen epost innad i teamet."),
	                        React.createElement("li", null,
	                            React.createElement("strong", null, "Github: "),
	                            "Vi har koden v\u00E5r p\u00E5 ",
	                            React.createElement("a", { href: "https://github.com/" }, "github"),
	                            ", og bruker git-arbeidsflyter n\u00E5r vi samarbeider."),
	                        React.createElement("li", null,
	                            React.createElement("strong", null, "Jira: "),
	                            React.createElement("a", { href: "https://www.atlassian.com/software/jira" }, "Jira"),
	                            " er et prosjektstyringsverkt\u00F8y fra Atlassian. Vi bruker Jira for \u00E5 holde styr p\u00E5 hvilke oppgaver som jobbes med og hvilke som m\u00E5 fullf\u00F8res for \u00E5 ferdigstille de ulike delene av prosjektet."),
	                        React.createElement("li", null,
	                            React.createElement("strong", null, "Confluence: "),
	                            "Vi bruker ",
	                            React.createElement("a", { href: "https://www.atlassian.com/software/confluence" }, "Confluence"),
	                            " for \u00E5 ta vare p\u00E5 og dele kompetansen vi har i organisasjonen. Gjennom \u00E5 legge ting inn i wikiene l\u00E6rer organisasjonen stadig mer, til tross for at medlemmer kommer og g\u00E5r."))),
	                React.createElement(PageLayout_1.SubSection, { titleText: "Vrt tilholdssted" },
	                    React.createElement("p", null, "Til daglig holder vi til i Institutt for Teknisk Kybernetikk sin lab p\u00E5 taket av blokk A i El-bygget p\u00E5 Gl\u00F8shaugen, kjent som taklabben. Vi har b\u00E5de arbeidsstasjoner og drone-nett p\u00E5 plass. P\u00E5 den m\u00E5ten blir veien fra utvikling til testing kort. ")),
	                React.createElement(PageLayout_1.SubSection, { titleText: "Hvem vi jobber med" },
	                    React.createElement("p", null, "Vi har god kontakt med Institutt for Teknisk Kybernetikk (ITK), Institutt for Datateknikk og Informasjonsvitenskap (IDI), Forsvarets Forskningsinstitutt (FFI), Kongsberg Gruppen og oppstartselskapet Staaker. Gjennom instituttene f\u00E5r vi tilgang til diverse labber, utstyr og kompetanse. I tillegg skriver flere av v\u00E5re medlemmer prosjekt/master knyttet til Ascend for IDI og ITK. En oversikt over v\u00E5re sponsorer finner du nederst p\u00E5 hovedsiden v\u00E5r.")),
	                React.createElement(PageLayout_1.SubSection, { titleText: "Sprsml?" },
	                    React.createElement("p", null,
	                        "Hvis det er noe du lurer p\u00E5, send en mail til ",
	                        React.createElement("a", { href: "mailto:hi@ascendntnu.no" }, "hi@ascendntnu.no"),
	                        "."))))
	        };
	        var nextLanguage = 'no';
	        switch (this.state.language) {
	            case 'no':
	                nextLanguage = 'en';
	                break;
	            case 'en':
	                nextLanguage = 'no';
	                break;
	        }
	        var languageURL = '/' + nextLanguage;
	        if (nextLanguage === 'no')
	            languageURL = '';
	        var languageNames = {
	            'en': 'English',
	            'no': 'Norsk'
	        };
	        return (React.createElement("div", { className: "page page-join" },
	            React.createElement(breadcrumb_1.Breadcrumb, { routes: ['join'] }),
	            contents[this.state.language][1],
	            about[this.state.language]));
	    };
	    return JoinPage;
	}(React.Component));
	exports.JoinPage = JoinPage;
	exports.default = JoinPage;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var react_router_1 = __webpack_require__(5);
	var PageLayout_1 = __webpack_require__(72);
	var breadcrumb_1 = __webpack_require__(129);
	var historyViewer_1 = __webpack_require__(135);
	var ContactPage_1 = __webpack_require__(136);
	var AboutPage = (function (_super) {
	    __extends(AboutPage, _super);
	    function AboutPage() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AboutPage.prototype.render = function () {
	        return (React.createElement("div", { className: "page page-about" },
	            React.createElement(breadcrumb_1.Breadcrumb, { routes: ['about'] }),
	            React.createElement(PageLayout_1.Section, { titleText: "About Us" },
	                React.createElement(PageLayout_1.SubSection, { titleText: "Ascend NTNU - one of Norways most innovative student projects!" },
	                    React.createElement("p", null,
	                        "Ascend NTNU is one of the few aerial robotics teams at ",
	                        React.createElement("a", { href: "http://www.ntnu.edu/" }, "NTNU"),
	                        ". We are working towards becoming the best performing team at the ",
	                        React.createElement("a", { href: "http://www.aerialroboticscompetition.org/" }, "International Aerial Robotics Competition"),
	                        ", American venue. We aim high, work hard and create new and innovative solutions to some of the most challenging problems in cybernetics and autonomy as of today."),
	                    React.createElement("p", null, "Our group was founded during the spring of 2015. In 2016 we competed and became third in IARC. We are now, again, preparing for a new competition in 2017.")),
	                React.createElement(historyViewer_1.HistoryViewer, null),
	                React.createElement(PageLayout_1.SubSection, { titleText: "Our team and mission" },
	                    React.createElement("p", null,
	                        "We are currently ",
	                        React.createElement(react_router_1.Link, { to: "/team" }, "28 students"),
	                        " at NTNU studying electronics, computer science, IT, mechanics and cybernetics, working together to solve ",
	                        React.createElement("a", { href: "http://www.aerialroboticscompetition.org/rules.php" }, "Mission 7a"),
	                        ". The mission consists of 3 new major challenges:"),
	                    React.createElement("ul", null,
	                        React.createElement("li", null, "Interaction between aerial robot and moving objects"),
	                        React.createElement("li", null, "Navigation in a sterile environment with no external navigation aids such as GPS or SLAM."),
	                        React.createElement("li", null, "Interaction between competing autonomous air vehicles (mission 7b).")),
	                    React.createElement("iframe", { src: "https://player.vimeo.com/video/103487384", className: "about-mission-video", allowFullScreen: true }),
	                    React.createElement("p", null,
	                        React.createElement("i", { className: "small" }, "\"The International Aerial Robotics Competition is the longest running collegiate aerial robotics challenge in the world. Entering the third decade of advancing the state of the art in autonomous aerial robotic behavior, the competition continues to tackle challenges that are currently impossible for any flying robots owned by government or industry.\""),
	                        " - ",
	                        React.createElement("a", { href: "http://www.aerialroboticscompetition.org/" }, "www.aerialroboticscompetition.org")))),
	            React.createElement(ContactPage_1.ContactInfo, null)));
	    };
	    return AboutPage;
	}(React.Component));
	exports.AboutPage = AboutPage;
	exports.default = AboutPage;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var es6_promise_1 = __webpack_require__(80);
	es6_promise_1.polyfill();
	var blogArticle_1 = __webpack_require__(130);
	var HistoryViewer = (function (_super) {
	    __extends(HistoryViewer, _super);
	    function HistoryViewer(props) {
	        var _this = _super.call(this, props) || this;
	        _this.timelineScale = 2 / 50000000;
	        _this.mnd = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'des'];
	        _this.state = {
	            history: [],
	            historyElements: [],
	            pos: -300,
	            down: false,
	            startPos: 0,
	            width: 0,
	            selectedEvent: null,
	            eventViewHeight: null,
	        };
	        if (props.year)
	            _this.state.year = props.year;
	        _this.getHistory(_this.state.year || null);
	        _this.resizeHandler = _this.resizeHandler.bind(_this);
	        _this.mouseMoveHandler = _this.mouseMoveHandler.bind(_this);
	        _this.mouseUpHandler = _this.mouseUpHandler.bind(_this);
	        _this.loadedNewContent = _this.loadedNewContent.bind(_this);
	        _this.historyTimeline = [];
	        var fromDate = new Date(2014, 10);
	        var toDate = new Date();
	        var d = fromDate;
	        var i = 0;
	        var p;
	        while (toDate.getTime() + 5 * 30 * 24 * 60 * 60 * 1000 > d.getTime()) {
	            d = new Date(fromDate.getFullYear() + Math.floor((i + fromDate.getMonth()) / 12), (fromDate.getMonth() + i) % 12);
	            p = -Math.floor((d.getTime() - Date.now() + 30 * 24 * 3600 * 1000) * _this.timelineScale);
	            var style = {
	                right: p + "px",
	                width: 32 * 24 * 3600 * 1000 * _this.timelineScale + "px"
	            };
	            var title = null;
	            if (d.getMonth() === 0)
	                title = React.createElement("span", { className: "event-timeline-year" },
	                    d.getFullYear(),
	                    " ");
	            _this.historyTimeline.push(React.createElement("div", { key: i, className: "event-timeline", style: style },
	                title,
	                _this.mnd[d.getMonth()]));
	            i++;
	        }
	        return _this;
	    }
	    HistoryViewer.prototype.componentWillReceiveProps = function (nextProps) {
	    };
	    HistoryViewer.prototype.componentDidMount = function () {
	        var _this = this;
	        window.addEventListener('resize', this.resizeHandler);
	        window.addEventListener('mousemove', this.mouseMoveHandler);
	        window.addEventListener('mouseup', this.mouseUpHandler);
	        window.addEventListener('touchmove', this.mouseMoveHandler);
	        window.addEventListener('touchend', this.mouseUpHandler);
	        window.addEventListener('touchcancel', this.mouseUpHandler);
	        this.setState(Object.assign({}, this.state, {
	            width: document.querySelector('.history-viewer').clientWidth,
	            eventViewHeight: 0
	        }));
	        this.observer = new MutationObserver(function (mutations) {
	            mutations.forEach(function (mutation) {
	                switch (mutation.type) {
	                    case 'childList':
	                        var target_1 = mutation.target;
	                        Array.prototype.forEach.call(target_1.children, function (e) {
	                            e.querySelectorAll('img').forEach(function (img) {
	                                img.addEventListener('load', _this.loadedNewContent, false);
	                            });
	                        });
	                        break;
	                }
	                _this.setState(Object.assign({}, _this.state, {
	                    eventViewHeight: document.querySelector('.history-event-view-container').clientHeight
	                }));
	            });
	        });
	        var target = document.querySelector('.history-event-view');
	        this.observer.observe(target, {
	            childList: true,
	            characterData: true,
	            subtree: true,
	        });
	    };
	    HistoryViewer.prototype.componentWillUnmount = function () {
	        window.removeEventListener('resize', this.resizeHandler);
	        window.removeEventListener('mousemove', this.mouseMoveHandler);
	        window.removeEventListener('mouseup', this.mouseUpHandler);
	        window.removeEventListener('touchmove', this.mouseMoveHandler);
	        window.removeEventListener('touchend', this.mouseUpHandler);
	        window.removeEventListener('touchcancel', this.mouseUpHandler);
	        this.observer.disconnect();
	        this.historyElements = [];
	    };
	    HistoryViewer.prototype.loadedNewContent = function (evt) {
	        evt.target.removeEventListener('load', this.loadedNewContent, false);
	        this.setState(Object.assign({}, this.state, {
	            eventViewHeight: document.querySelector('.history-event-view-container').clientHeight
	        }));
	    };
	    HistoryViewer.prototype.resizeHandler = function (evt) {
	        this.setState(Object.assign({}, this.state, {
	            width: document.querySelector('.history-viewer').clientWidth,
	            eventViewHeight: document.querySelector('.history-event-view-container').clientHeight
	        }));
	    };
	    HistoryViewer.prototype.mouseMoveHandler = function (evt) {
	        if (this.state.down) {
	            var pos = 0;
	            if (evt.type === 'mousemove') {
	                pos = evt.clientX;
	            }
	            else {
	                //evt.preventDefault()
	                pos = evt.touches[0].clientX;
	            }
	            this.setState(Object.assign({}, this.state, {
	                pos: Math.max(Math.max(-400, -this.state.width / 2), Math.min(2 * 1400 - this.state.width, pos - this.state.startPos))
	            }));
	        }
	    };
	    HistoryViewer.prototype.mouseDownHandler = function (evt) {
	        var pos = 0;
	        if (evt.type === 'mousedown') {
	            pos = evt.clientX - this.state.pos;
	        }
	        else {
	            //evt.preventDefault()
	            pos = evt.touches[0].clientX - this.state.pos;
	        }
	        this.setState(Object.assign({}, this.state, {
	            down: true,
	            startPos: pos
	        }));
	    };
	    HistoryViewer.prototype.mouseUpHandler = function (evt) {
	        if (this.state.down) {
	            this.setState(Object.assign({}, this.state, {
	                down: false
	            }));
	        }
	    };
	    HistoryViewer.prototype.scrollHandler = function (evt) {
	        if (evt.deltaX !== 0)
	            evt.preventDefault();
	        var pos = Math.max(Math.max(-400, -this.state.width / 2), Math.min(2 * 1400 - this.state.width, this.state.pos - evt.deltaX));
	        if (pos !== this.state.pos) {
	            this.setState(Object.assign({}, this.state, {
	                pos: pos
	            }));
	        }
	    };
	    HistoryViewer.prototype.dateParser = function (date) {
	        var dateParsed = date.split(/[TZ\-:]/);
	        var d = [];
	        for (var i in dateParsed)
	            d.push(parseInt(dateParsed[i]));
	        var time = new Date(d[0], d[1] - 1, d[2], d[3], d[4], d[5]);
	        var dateFormatted = d[2] + ". " + this.mnd[d[1] - 1] + ". " + d[0];
	        return { dateFormatted: dateFormatted, dateParsed: dateParsed, time: time };
	    };
	    HistoryViewer.prototype.selectEventHandler = function (evt, event) {
	        var selectedEvent = event || this.state.history[2016][0];
	        this.setState(Object.assign({}, this.state, {
	            selectedEvent: selectedEvent === this.state.selectedEvent
	                ? null
	                : selectedEvent
	        }));
	        var events = document.querySelectorAll('.history-content > .event');
	        events.forEach(function (e) {
	            e.classList.remove('selected');
	        });
	        var target = evt.target.classList.contains('event')
	            ? evt.target
	            : evt.target.parentElement;
	        if (selectedEvent === this.state.selectedEvent)
	            target.classList.remove('selected');
	        else {
	            target.classList.add('selected');
	            var historyViewer = document.querySelector('.history-viewer');
	            var app_1 = document.querySelector('#app');
	            var startScroll_1 = app_1.scrollTop;
	            var scrollTo_1 = historyViewer.offsetTop - 64;
	            if (startScroll_1 < scrollTo_1) {
	                var interval_1 = setInterval(function () {
	                    app_1.scrollTop += 10 / (.1 + Math.pow((app_1.scrollTop - scrollTo_1) / (startScroll_1 - scrollTo_1) - .5, 2));
	                    if (app_1.scrollTop - scrollTo_1 >= 0) {
	                        app_1.scrollTop = scrollTo_1;
	                        clearInterval(interval_1);
	                    }
	                }, 10);
	            }
	        }
	    };
	    HistoryViewer.prototype.getHistory = function (year) {
	        var _this = this;
	        fetch('/api/v1/history/' + (year || '')).then(function (r) { return r.json(); }).then(function (r) {
	            var history = [];
	            for (var year_1 in r) {
	                for (var event_1 in r[year_1]) {
	                    var _a = _this.dateParser(r[year_1][event_1].date), dateFormatted = _a.dateFormatted, time = _a.time;
	                    r[year_1][event_1].dateFormatted = dateFormatted;
	                    r[year_1][event_1].time = time;
	                    r[year_1][event_1].pos = -(time.getTime() - Date.now()) * _this.timelineScale;
	                    history.push(r[year_1][event_1]);
	                }
	            }
	            _this.historyElements = history.map(function (event, i) {
	                var style = {
	                    right: event.pos,
	                    top: 30 + 42 * Math.cos(event.time.getTime() * _this.timelineScale / 5) + "px"
	                };
	                return (React.createElement("div", { key: i, className: "event " + event.categories, onClick: function (evt) { return _this.selectEventHandler(evt, event); }, style: style },
	                    React.createElement("div", { className: "event-title" }, event.title),
	                    React.createElement("div", { className: "event-date" }, event.dateFormatted)));
	            });
	            _this.setState(Object.assign({}, _this.state, {
	                history: r,
	                historyElements: _this.historyElements
	            }));
	        });
	    };
	    HistoryViewer.prototype.render = function () {
	        var historyContentStyles = {
	            left: Math.max(Math.max(-400, -this.state.width / 2), Math.min(2 * 1400 - this.state.width, this.state.pos)) + 'px'
	        };
	        var eventViewStyles = {
	            minHeight: this.state.selectedEvent
	                ? this.state.eventViewHeight + 'px'
	                : 0
	        };
	        return (React.createElement("div", { className: "history-viewer dark-theme" },
	            React.createElement("div", { className: "history-content-view", onMouseDown: this.mouseDownHandler.bind(this), onTouchStart: this.mouseDownHandler.bind(this), onWheel: this.scrollHandler.bind(this), draggable: false },
	                React.createElement("div", { className: "history-content", style: historyContentStyles },
	                    this.historyTimeline,
	                    this.state.historyElements)),
	            React.createElement("div", { className: "history-event-view " + (this.state.selectedEvent ? 'open' : ''), style: eventViewStyles },
	                React.createElement("div", { className: "page-container history-event-view-container" },
	                    React.createElement("div", { className: "history-event-view-block" },
	                        React.createElement("h1", { className: "history-event-view-title" }, this.state.selectedEvent && this.state.selectedEvent.title),
	                        React.createElement("p", { className: "history-event-view-content", dangerouslySetInnerHTML: {
	                                __html: this.state.selectedEvent && this.state.selectedEvent.content
	                            } })),
	                    this.state.selectedEvent && this.state.selectedEvent.image && (React.createElement("div", { className: "history-event-view-image" },
	                        React.createElement("img", { src: this.state.selectedEvent.image }))),
	                    this.state.selectedEvent && this.state.selectedEvent.post && (React.createElement("div", { className: "history-event-view-post" },
	                        React.createElement(blogArticle_1.BlogArticle, { post: this.state.selectedEvent.post })))))));
	    };
	    return HistoryViewer;
	}(React.Component));
	exports.HistoryViewer = HistoryViewer;
	exports.default = HistoryViewer;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var PageLayout_1 = __webpack_require__(72);
	var breadcrumb_1 = __webpack_require__(129);
	var ContactPage = (function (_super) {
	    __extends(ContactPage, _super);
	    function ContactPage() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ContactPage.prototype.render = function () {
	        return (React.createElement("div", { className: "page page-about" },
	            React.createElement(breadcrumb_1.Breadcrumb, { routes: ['about'] }),
	            React.createElement(ContactInfo, null)));
	    };
	    return ContactPage;
	}(React.Component));
	exports.ContactPage = ContactPage;
	exports.default = ContactPage;
	var ContactInfo = (function (_super) {
	    __extends(ContactInfo, _super);
	    function ContactInfo() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ContactInfo.prototype.render = function () {
	        return (React.createElement(PageLayout_1.Section, { titleText: "Contact Info" },
	            React.createElement(ContactUs, null),
	            React.createElement(Addresses, null),
	            React.createElement(OrganisationalDocuments, null),
	            React.createElement(FormalInfo, null)));
	    };
	    return ContactInfo;
	}(React.Component));
	exports.ContactInfo = ContactInfo;
	var ContactUs = (function (_super) {
	    __extends(ContactUs, _super);
	    function ContactUs() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ContactUs.prototype.render = function () {
	        return (React.createElement(PageLayout_1.SubSection, { titleText: "Contact us" },
	            React.createElement("p", null,
	                "Send an email to ",
	                React.createElement("a", { href: "mailto:hi@ascendntnu.no" }, "hi@ascendntnu.no"),
	                ", and we\u2019ll get back to you.")));
	    };
	    return ContactUs;
	}(React.Component));
	exports.ContactUs = ContactUs;
	var Addresses = (function (_super) {
	    __extends(Addresses, _super);
	    function Addresses() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Addresses.prototype.render = function () {
	        return (React.createElement(PageLayout_1.SubSection, { titleText: "Addresses" },
	            React.createElement("p", null,
	                React.createElement("strong", null, "Postal address"),
	                ", ",
	                React.createElement("a", { href: "http://maps.google.com/?q=O.+S.+Bragstads+Plass+2,+7034+Trondheim,+Norway" }, "click here to view in google maps")),
	            React.createElement("address", null,
	                "Ascend NTNU",
	                React.createElement("br", null),
	                "Gl\u00F8shaugen",
	                React.createElement("br", null),
	                "O.S. Bragstads plass 2 A/B",
	                React.createElement("br", null),
	                "7034 Trondheim",
	                React.createElement("br", null),
	                "Norway"),
	            React.createElement("p", null,
	                React.createElement("strong", null, "Physical address")),
	            React.createElement("address", null,
	                "Ascend NTNU",
	                React.createElement("br", null),
	                "EL-bygget, NTNU Gl\u00F8shaugen",
	                React.createElement("br", null),
	                "7491 Trondheim",
	                React.createElement("br", null),
	                "Norway")));
	    };
	    return Addresses;
	}(React.Component));
	exports.Addresses = Addresses;
	var OrganisationalDocuments = (function (_super) {
	    __extends(OrganisationalDocuments, _super);
	    function OrganisationalDocuments() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    OrganisationalDocuments.prototype.render = function () {
	        return (React.createElement(PageLayout_1.SubSection, { titleText: "Organisational documents" },
	            React.createElement("p", null, "We plan on publishing core organisational documents here as we finish them."),
	            React.createElement("ul", null,
	                React.createElement("li", null,
	                    React.createElement("strong", null, "Our statutes (in norwegian: vedtekter):"),
	                    " Our statutes are available on github in ",
	                    React.createElement("a", { href: "https://github.com/AscendNTNU/Vedtekter" }, "this repo"),
	                    ". ",
	                    React.createElement("a", { href: "https://github.com/AscendNTNU/Vedtekter/raw/master/vedtekter.pdf" }, "Click here to view the pdf"),
	                    ". The statutes are written in Norwegian."))));
	    };
	    return OrganisationalDocuments;
	}(React.Component));
	exports.OrganisationalDocuments = OrganisationalDocuments;
	var FormalInfo = (function (_super) {
	    __extends(FormalInfo, _super);
	    function FormalInfo() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    FormalInfo.prototype.render = function () {
	        return (React.createElement(PageLayout_1.SubSection, { titleText: "Formal information about Ascend NTNU" },
	            React.createElement("p", null,
	                "We are registered in ",
	                React.createElement("a", { href: "http://www.brreg.no/english/" }, "The Br\u00F8nn\u00F8ysund Register Centre"),
	                ". See ",
	                React.createElement("a", { href: "http://w2.brreg.no/enhet/sok/detalj.jsp?orgnr=915737641" }, "our listing here"),
	                "."),
	            React.createElement("p", null,
	                React.createElement("strong", null, "Organisational number:"),
	                " ",
	                React.createElement("a", { href: "tel:99521772" }, "995 21 772"))));
	    };
	    return FormalInfo;
	}(React.Component));
	exports.FormalInfo = FormalInfo;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var react_router_1 = __webpack_require__(5);
	var PageLayout_1 = __webpack_require__(72);
	var breadcrumb_1 = __webpack_require__(129);
	var sponsorlist_1 = __webpack_require__(79);
	var SponsorPage = (function (_super) {
	    __extends(SponsorPage, _super);
	    function SponsorPage(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            year: props.params.year || 2018,
	        };
	        return _this;
	    }
	    SponsorPage.prototype.changeYear = function (evt) {
	        var year = evt.target.value;
	        react_router_1.browserHistory.push('/sponsors/' + year);
	        this.setState({
	            year: year,
	        });
	    };
	    SponsorPage.prototype.componentWillReceiveProps = function (nextProps) {
	        var nextYear = parseInt(nextProps.params.year) || 2018;
	        var year = parseInt(this.props.params.year) || this.state.year;
	        if (nextYear != year) {
	            year = nextYear;
	            this.setState({
	                year: year,
	            });
	        }
	    };
	    SponsorPage.prototype.render = function () {
	        var title = (React.createElement("span", null,
	            "Our sponsors ",
	            React.createElement("select", { className: "select-sponsor select", onChange: this.changeYear.bind(this), defaultValue: this.state.year + '' },
	                React.createElement("option", { value: "2016" }, "2016"),
	                React.createElement("option", { value: "2017" }, "2017"),
	                React.createElement("option", { value: "2018" }, "2018"))));
	        return (React.createElement("div", { className: "page page-sponsors" },
	            React.createElement(breadcrumb_1.Breadcrumb, { routes: ['sponsors'] }),
	            React.createElement(PageLayout_1.Section, { titleText: title, className: "centered page-container-big" },
	                React.createElement(sponsorlist_1.SponsorList, { year: this.state.year }))));
	    };
	    return SponsorPage;
	}(React.Component));
	exports.SponsorPage = SponsorPage;
	exports.default = SponsorPage;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var PageLayout_1 = __webpack_require__(72);
	var breadcrumb_1 = __webpack_require__(129);
	var MissionPage = (function (_super) {
	    __extends(MissionPage, _super);
	    function MissionPage(props) {
	        var _this = _super.call(this, props) || this;
	        _this.missions = [
	            {
	                titles: ['Mission 7', 'Why is this a challenge?'],
	                contents: [
	                    (React.createElement("div", { id: "mission-7" },
	                        React.createElement("p", null,
	                            "Mission 7 is split into two parts, a and b. Part b will begin when enough teams have completed part a. Here we will give a brief overview of the mission, for a complete version of the rules see ",
	                            React.createElement("a", { href: "http://www.aerialroboticscompetition.org/rules.php" }, "the official rules"),
	                            "."),
	                        React.createElement("div", { className: "split-img-container" },
	                            React.createElement("figure", { className: "split-img" },
	                                React.createElement("img", { className: "img-responsive", alt: "Mission start state", src: "/public/assets/start-state.png" }),
	                                React.createElement("figcaption", { className: "text-center" }, "Fig1-a: Start state of the competition")),
	                            React.createElement("figure", { className: "split-img" },
	                                React.createElement("img", { className: "img-responsive", alt: "Desired end state", src: "/public/assets/end-state.png" }),
	                                React.createElement("figcaption", { className: "text-center" }, "Fig1-b: End state of a successful run"))),
	                        React.createElement("p", null, "The mission takes place indoors on a 20x20 meter grid arena. The square arena has two white edges, one green edge and one red edge, as shown in figure 1. In the middle of the arena, 10 ground robots (Roomba vacuum cleaner robots) start driving from the middle at a speed of 1/3 m/s, outwards towards the edges. The ground robots move in a specific pattern:"),
	                        React.createElement("code", null,
	                            "Every 20 seconds they rotate 180 degrees.",
	                            '\n',
	                            "Every 5 seconds they rotate a random amount of degrees on the interval [-20, 20].",
	                            '\n',
	                            "If they bump into anything, they rotate 180 degrees."),
	                        React.createElement("span", { className: "img-float-right" }),
	                        React.createElement("figure", null,
	                            React.createElement("img", { className: "img-responsive", alt: "Assembled bot", src: "/public/assets/assembled_bot_700px.png" }),
	                            React.createElement("figcaption", { className: "text-center" }, "Fig 2: Ground robot with tactile switch on top")),
	                        React.createElement("p", null, "In addition to the ground robots, there are four obstacle robots. The obstacle robots are Roombas as well, but have a 1-2 meter high pole on top. They are programmed to drive around in a circle, and are there to create havoc. If the drone touches the obstacle robots more than two times the run will be terminated."),
	                        React.createElement("p", null, "Our drone\u2019s mission is to \u201Cherd\u201D or guide these ground robots over the green edge, and to keep them from running over any of the other edges, as shown in figure 2. It has to do this autonomously; we are not allowed to control its movement in any way. To interact with the ground robots we have two possibilities."),
	                        React.createElement("code", null,
	                            "Tapping a tactile button on the top of the ground robots, turning them 45 degrees, clockwise.",
	                            '\n',
	                            "Bumping into the groud robots from the front, turning them 180 degrees."),
	                        React.createElement("p", null),
	                        React.createElement("div", { className: "split-img-container" },
	                            React.createElement("figure", { className: "split-img" },
	                                React.createElement("img", { className: "img-responsive", alt: "Test", src: "/public/assets/test.png" }),
	                                React.createElement("figcaption", { className: "text-center" }, "Fig 3-a: Drone landing on the tactile switch")),
	                            React.createElement("figure", { className: "split-img" },
	                                React.createElement("img", { className: "img-responsive", alt: "Desired end state", src: "/public/assets/180-degree-turn-cartoon.png" }),
	                                React.createElement("figcaption", { className: "text-center" }, "Fig 3-b: Drone landing in front of a ground robot"))),
	                        React.createElement("p", null, "All sensors we use, have to be onboard the drone. We are allowed to have an external machine for number crunching, but other than that the drone act alone. Each run is 10 min long, and each team has three rounds each to try to complete the mission."),
	                        React.createElement("p", null, "To complete part a of mission 7 we have to herd at least four ground robots to over the green line during one of our runs. Teams who complete part a will move over to part b. Part b is a competition between two teams, where each team have their own \"goal side\" and try to herd as many ground robots over their own side as possible."))),
	                    (React.createElement("div", null,
	                        React.createElement("p", null, "The goal of IARC is to push the limits of autonomous flying vehicles, so what limits are they trying to push with mission 7? The organizers have set up three aspects which the participants will have to master to complete this challenge. Printed as is from the rules we have:"),
	                        React.createElement("code", null, "First, interaction between aerial robots and moving objects (specifically, autonomous ground robots). Second, navigation in a sterile environment with no external navigation aids such as GPS or large stationary points of reference such as walls. Third, interaction between competing autonomous air vehicles."),
	                        React.createElement("p", null),
	                        React.createElement(PageLayout_1.SubSubSection, { titleText: "Navigation" },
	                            React.createElement("p", null, "Let's start with the second aspect: \"navigation in a sterile environment with no external navigation aids such as GPS or large stationary points of reference such as walls\". Navigation has always been a part of the IARC missions, and have been the main challenge in many of them. In mission 7 they have purposely made many of the existing navigational tools illegal or useless. As the competition is indoors we cannot use GPS, as GPS is highly unreliable indoors, and because it would break the rule of not using external navigation aids. A common technique for flying indoor which does not break this rule is SLAM. SLAM or Simultaneous Localisation And Mapping is a method using lidar or cameras where the drone continuously creates a map of its environment. SLAM works wonderfully when flying in corridors or smaller rooms, as it typically uses walls, columns and other stationary objects to localise itself. Mission 5 and 6 relied heavily on SLAM usage. Mission 7 on the other hand, is designed to render SLAM useless. As the arena is completely flat except the robots, and the robots continuously move in semi random motions, SLAM has no stationary objects navigate by. All in all, to navigate the arena new innovative tools needs to be developed."),
	                            React.createElement("p", null, "Every square of the grid making up the arena, looks equivalent; the only unique, and stationary features in the whole mission are the corners. As two sides are white, one is blue and another is red (see fig 1), every corner is unique, and if the drones position relative to the corners are known, the drone knows where it is. To fly safely, all the obstacle robots needs to be avoided. The obstacle robots are programmed to drive in a 5m radius circle in the middle of the arena, but from experience, they will stray from the circle every run. On top of everything else, there is a hidden challenge in all of this. As all the sensors are onboard the drone, what we can observe varies with the position and orientation of the drone. If the drone is a couple of meters up in the air, it can observe most of the arena, we can, however not be a couple of meters in the air at all times. Whenever we need to interact with the ground robots the drone has to land, and what we can observe from the cameras is highly reduced."),
	                            React.createElement("p", null,
	                                "To solve these challenges we have developed multiple systems to find global position and avoid collisions. To read about the systems we used in the 2016 competition, check out our summary of last years systems ",
	                                React.createElement("a", { href: "https://ascendntnu.no/publications/iarc16/" }, "here"),
	                                ". More information about this years systems will be published in our ",
	                                React.createElement("a", { href: "https://ascendntnu.no/blog" }, "blog"),
	                                "  after the competition.")),
	                        React.createElement(PageLayout_1.SubSubSection, { titleText: "Interaction" },
	                            React.createElement("p", null,
	                                "Moving on to the first aspect: \"interaction between aerial robots and moving objects\". The tactile switches on the ground robots are ~10cm X 10cm, the ground robots move at a speed of 0.33m/s, and their movement is only deterministic upto 5 seconds at the time. Landing on these robots and pressing the tactile switch is a challenge in its own right, but there are several other challenges to overcome before we can think about landing on the robots. First, the drone must be able to detect and track the ground robots. Then, as there is only 10 minutes to complete the mission, there is not enough time to guide the ground robots over the green line one by one. Therefore the drone needs to be able to plan the best course of action live in a highly dynamic environment. The problem can be modeled as a less known generalisation of the travelling salesman problem called Time-dependent Orienteering Problem with Time Windows (TDOPTW). Read more about TDOPTW in our previous members' ",
	                                React.createElement("a", { href: "https://brage.bibsys.no/xmlui/handle/11250/2407635" }, "master thesis"),
	                                "."),
	                            React.createElement("p", null, "Another way of characterising the complexity of the task and environment for the classification system introduced in Russell and Norvig (2009) [1]. In the table below we can see the different aspects used to classify the different environments. The left column represents less complexity and the right column represents a higher degree of complexity. As one can see from the checkmarks, IARC scores high on complexity on all fronts. If the system is known or unknown at the moment is arguable, but come part b and the challenge is firmly in the right column."),
	                            React.createElement("figure", null,
	                                React.createElement("img", { className: "img-responsive", alt: "AI classification", src: "/public/assets/AI_classification.png" }),
	                                React.createElement("figcaption", { className: "text-center" }, "Fig 4: AI-environment classification table")),
	                            React.createElement("p", null,
	                                "These challenges encompasses all of Ascend's technical groups. To read about how we detect the ground robots read our perception group's ",
	                                React.createElement("a", { href: "https://ascendntnu.no/blog/2017-03-10-perception-update" }, "blog"),
	                                ". Our planning group have been working hard on the drones AI; to read about their approach you can check out ",
	                                React.createElement("a", { href: "https://ascendntnu.no/blog/2017-02-14-planning-update" }, "part 1"),
	                                " and ",
	                                React.createElement("a", { href: "https://ascendntnu.no/blog/2017-02-20-planning-update" }, "part 2"),
	                                ".")),
	                        React.createElement(PageLayout_1.SubSubSection, { titleText: "Competing with other drones" },
	                            React.createElement("p", null, "Moving from part a to part b introduces yet another challenge: interacting with another team's drone. Not only do we have to take into account the randomness presented in the mission itself, but also whatever the other team's drone might do. And their drone moves faster than the ground robots, with unknown behaviour, and in 3 dimensions. All in all the introduction of another drone takes all the challenges of part a and turns them up to 11. The complete set of rules for part b are yet to be published, but we might have some idea on how to confuse the competition."),
	                            React.createElement("img", { className: "img-responsive", alt: "Ground robot drone", src: "/public/assets/ground_robot_drone.jpg" }))))
	                ]
	            },
	            {
	                titles: ['Mission 6'],
	                contents: [
	                    (React.createElement("div", { id: "mission-6" },
	                        React.createElement("p", null, "Mission 6 continued where Mission 5 ended but increased the difficultly by requiring the autonomous robots to interact with their environment. The robots had to locate an opening in a building, enter when a surveillance camera was not looking, navigate crowded hallways, avoid or disable security systems, interpret signage in Arabic, and finally reach a particular room without bumping any walls or landing. From there, the robot had to locate a particular paper inbox containing a flash drive. It had to then retrieve that flash drive, replace it with an identical blank flash drive, and exit the building within a short time span. This mission saw the first dual-venue competition, with simultaneous events occurring in both the United States and China. After three years, a team from Tsinghua University repeatedly demonstrated the entirety of the mission.")))
	                ]
	            },
	            {
	                titles: ['Mission 5'],
	                contents: [
	                    (React.createElement("div", { id: "mission-5" },
	                        React.createElement("p", null, "The fifth mission picked up where the fourth mission left off by demonstrating the fully autonomous aerial robotic behaviors necessary to rapidly negotiate the confined internal spaces of a structure. This was a logical next step since the previous mission required a vehicle to enter a building. The nuclear reactor complex explosion scenario of the fourth mission was used as the backdrop for the fifth mission. The fifth mission required a fully autonomous aerial vehicle (presupposed to have been launched from a \"mothership\" just outside the structure as demonstrated during the fourth mission) to penetrate a structure and negotiate a more complex interior space containing hallways, small rooms, obstacles, and dead ends, in order to search for a designated target without the aid of global-positioning navigational aids. Finally, the aerial robot had to relay pictures of the nuclear control panel to a monitoring station some distance from the structure.")))
	                ]
	            },
	            {
	                titles: ['Mission 4'],
	                contents: [
	                    (React.createElement("div", { id: "mission-4" },
	                        React.createElement("p", null, "This mission involved flying to an abandoned village from a distance of 3 kilometers and identifying a particular structure based on a symbol on the building. Once the structure has been identified, a sensor probe had to be sent into the structure to perform reconnaissance and return video of a particular item of interest. Access to the structure was be through open portals (doors, windows, other openings) that had to be identified by the aerial robots. The total number of portals was not known beforehand. Operation within the structure was required in order to access the desired target. The robot had to relay clear images of the desired target back 3 kilometers to the judges. After seven years of steady progression, a team from the Georgia Institute of Technology completed the entire mission.")))
	                ]
	            },
	            {
	                titles: ['Mission 3'],
	                contents: [
	                    (React.createElement("div", { id: "mission-3" },
	                        React.createElement("p", null, "The third mission began in 1998. It was a search and rescue mission requiring fully autonomous robots to take off, fly to a disaster area, search for survivors and the dead amid raging fires, broken water mains, clouds of toxic gas, and rubble from destroyed buildings. The scenario was recreated at the U.S. Department of Energy's Hazardous Material Management and Emergency Response (HAMMER) training facility where these hazards could be recreated. Because of the realism of the scenario, animatrons were used instead of human actors to simulate survivors that were incapable of extracting themselves from the disaster area. An aerial robot from Germany's Technische Universit\u00E4t Berlin was able to detect and avoid all of the obstacles (many of which could have destroyed the robot itself), identify all the dead on the ground and the survivors (distinguishing between the two based on movement), and relay pictures of the survivors along with their locations back to first responders who would attempt a rescue.")))
	                ]
	            },
	            {
	                titles: ['Mission 2'],
	                contents: [
	                    (React.createElement("div", { id: "mission-2" },
	                        React.createElement("p", null, "The competition mission was then toughened and made a bit less abstract by requiring teams to search for a toxic waste dump, map the location of partially buried, randomly oriented, toxic waste drums, identify the contents of each drum from the hazard labels found somewhere on the outside of each drum, and bring a sample back from one of the drums; all without any human intervention whatsoever. In 1996, a team from the Massachusetts Institute of Technology and Boston University, with backing from Draper Labs, created a small fully autonomous flying robot that repeatedly and correctly mapped the location of all five of the toxic waste drums, and correctly identified the contents of two from the air, thereby completing approximately seventy five percent of the mission. The following year, an aerial robot developed by a team from Carnegie Mellon University completed the entire mission.")))
	                ]
	            },
	            {
	                titles: ['Mission 1'],
	                contents: [
	                    (React.createElement("div", { id: "mission-6" },
	                        React.createElement("p", null, "The initial mission started in 1991 with the goal of moving a metallic disc from one side of an arena to another with a completely autonomous flying robot. This was seen by many as almost impossible for a fully autonomous flying robot. The college teams continued to improve their entries over the next two years. During that time, the competition saw its first autonomous takeoff, flight, and landing by a team from the Georgia Institute of Technology. Three years later, in 1995, a team from Stanford University was able to acquire a single disk and move it from one side of the arena to the other in a fully-autonomous flight half a decade earlier than some pundits had predicted.")))
	                ]
	            }
	        ];
	        return _this;
	    }
	    MissionPage.prototype.render = function () {
	        var missions = this.missions.map(function (e, i) {
	            return e.contents.map(function (content, k) { return (React.createElement(PageLayout_1.SubSubSection, { titleText: e.titles[k], key: k }, content)); });
	        });
	        return (React.createElement("div", { className: "page page-mission" },
	            React.createElement(breadcrumb_1.Breadcrumb, { routes: ['mission'] }),
	            React.createElement(PageLayout_1.SubSection, { className: "page-container-big" },
	                React.createElement("h1", null, "Missions")),
	            React.createElement(PageLayout_1.Section, { titleText: "Who are we" },
	                React.createElement("p", null, "Ascend NTNU is a student organization at the Norwegian University of Science and Technology. Ascend NTNU was founded with the primary mission of participating in (and winning) the International Aerial Robotics Competition in 2016 and onwards."),
	                React.createElement(PageLayout_1.SubSection, { titleText: "The International Aerial Competition" },
	                    React.createElement("p", null, "The International Aerial Competition (IARC) is the longest running collegiate aerial robotics challenge in the world, whose primary goal is to \u201Cmove the state-of-the-art in aerial robotics forward\u201D. In order to succeed with this ambitious goal, IARC poses challenges deemed \u201Cimpossible\u201D when introduced. The missions remains the same until one or more teams completes the challenges. The first IARC was held in 1991, and now, 26 years later, 6 missions have been completed; the longest mission running for 8 years before Georgia Institute of Technology solved the mission.")),
	                React.createElement(PageLayout_1.SubSection, { titleText: "The Missions" },
	                    React.createElement("p", null, "The missions have evolved with the arrival of new technology to continuously push the limits. Mission 1, issued in 1991, was to move a metallic disc from one side of an arena to another. Not a challenging mission by today's standard, but remove a quarter of a century's worth of technologic development and you have yourself a challenge. In the last mission to be completed, mission 6, it is however, not hard to see the challenge. The description of the mission was:"),
	                    React.createElement("blockquote", null, "The robots had to locate an opening in a building, enter when a surveillance camera was not looking, navigate crowded hallways, avoid or disable security systems, interpret signage in Arabic, and finally reach a particular room without bumping any walls or landing. From there, the robot had to locate a particular paper inbox containing a flash drive. It had to then retrieve that flash drive, replace it with an identical blank flash drive, and exit the building within a short time span."),
	                    React.createElement("p", null, "After four years, Tsinghua University completed the mission and pushed the competition along. Which brings us to today's challenge, and the mission Ascend NTNU is trying to solve: mission 7."),
	                    React.createElement("p", null,
	                        "For more information and about the different missions read about ",
	                        React.createElement("a", { href: "http://www.aerialroboticscompetition.org/pastmissions.php" }, "past missions"),
	                        " on IARC's webpage."),
	                    missions))));
	    };
	    return MissionPage;
	}(React.Component));
	exports.MissionPage = MissionPage;
	exports.default = MissionPage;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var React = __webpack_require__(3);
	var react_router_1 = __webpack_require__(5);
	var PageLayout_1 = __webpack_require__(72);
	var breadcrumb_1 = __webpack_require__(129);
	var CVPage = (function (_super) {
	    __extends(CVPage, _super);
	    function CVPage(props) {
	        var _this = _super.call(this, props) || this;
	        _this.state = {
	            students: [],
	            key: props.params.key || null,
	            categories: {
	                groups: [],
	                years: [],
	                studyCodes: [],
	            },
	        };
	        _this.fetchStudents();
	        return _this;
	    }
	    CVPage.prototype.componentWillReceiveProps = function (nextProps) {
	        this.fetchStudents(nextProps);
	    };
	    CVPage.prototype.fetchStudents = function (props) {
	        var _this = this;
	        if (props === void 0) { props = this.props; }
	        fetch('/api/v1/cv/' + (props.params.key || '')).then(function (r) { return r.json(); }).then(function (data) {
	            var groups = [];
	            var years = [];
	            var studyCodes = [];
	            for (var _i = 0, _a = data.students; _i < _a.length; _i++) {
	                var student = _a[_i];
	                if (groups.indexOf(student.group) === -1)
	                    groups.push(student.group);
	                if (years.indexOf(student.year) === -1)
	                    years.push(student.year);
	                if (studyCodes.indexOf(student.study) === -1)
	                    studyCodes.push(student.study);
	            }
	            _this.setState(Object.assign({}, _this.state, {
	                students: data.students,
	                error: data.error || null,
	                public: !props.params.key || !!data.error,
	                categories: {
	                    groups: groups,
	                    years: years,
	                    studyCodes: studyCodes,
	                },
	            }));
	        });
	    };
	    CVPage.prototype.updateKeyHandler = function (evt) {
	        this.setState(Object.assign({}, this.state, {
	            key: evt.target.value,
	            error: '',
	        }));
	    };
	    CVPage.prototype.render = function () {
	        var _this = this;
	        var students = null;
	        var error = null;
	        if (this.state.error) {
	            error = React.createElement("div", { style: { color: 'red', fontStyle: 'italic' } }, this.state.error);
	        }
	        if (this.state.students) {
	            students = this.state.students.map(function (e, i) { return (React.createElement("div", { key: i, className: "row" },
	                React.createElement("span", { "data-colname": "Name", className: "col col-name" },
	                    React.createElement("span", null, e.first_name + " " + (e.middle_name ? (e.middle_name + ' ') : '') + e.last_name)),
	                React.createElement("span", { "data-colname": "Study", className: "col col-study" },
	                    React.createElement("span", null,
	                        e.year,
	                        ". ",
	                        e.study.toUpperCase())),
	                React.createElement("span", { "data-colname": "Group", className: "col col-group" },
	                    React.createElement("span", null, e.group)),
	                React.createElement("span", { "data-colname": "Description", className: "col col-desc" },
	                    React.createElement("span", { dangerouslySetInnerHTML: { __html: e.description.replace(/\\r\\n|\\n/g, '<br />') } })),
	                React.createElement("span", { "data-colname": "CV", className: "col col-cv" },
	                    React.createElement("span", null,
	                        React.createElement("a", { href: '/api/v1/cv/' + _this.props.params.key + '/' + e.cv },
	                            e.cv.split('.').pop().toUpperCase(),
	                            "-file"))))); });
	        }
	        return (React.createElement("div", { className: "page page-cv" },
	            React.createElement(breadcrumb_1.Breadcrumb, { routes: ['CV'] }),
	            React.createElement(PageLayout_1.Section, { titleText: "CV database" },
	                this.state.public && React.createElement("div", null,
	                    React.createElement("input", { defaultValue: this.props.params.key, onInput: this.updateKeyHandler.bind(this), placeholder: "Key for private profiles" }),
	                    this.state.key && React.createElement(react_router_1.Link, { to: '/cv/' + this.state.key, className: "button active" }, "Access private profiles")),
	                this.state.key && error,
	                React.createElement("div", { className: "cv-students table" },
	                    React.createElement("div", { className: "h-row" },
	                        React.createElement("span", { className: "h-col col-name" }, "Name"),
	                        React.createElement("span", { className: "h-col col-study" }, "Study"),
	                        React.createElement("span", { className: "h-col col-study" }, "Group"),
	                        React.createElement("span", { className: "h-col col-desc" }, "Description"),
	                        React.createElement("span", { className: "h-col col-cv" }, "CV")),
	                    students))));
	    };
	    return CVPage;
	}(React.Component));
	exports.CVPage = CVPage;
	exports.default = CVPage;


/***/ })
/******/ ]);
//# sourceMappingURL=bundle.js.map